define the function _split_statements with an argument content.,def _split_statements ( content ) :
"call the function re.compile with an argument raw string ""^((?:'[^']*'|[^'])*?)--.*$"", substitute the result for comment_re.","comment_re = re . compile ( r""^((?:'[^']*'|[^'])*?)--.*$"" )"
statements is an empty list.,statements = [ ]
statement is an empty list.,statement = [ ]
"split content by newline character, for every line in result,","for line in content . split ( ""\n"" ) :"
"call the method comment_re.sub with an arguments: raw string '\1' and line, strip the whitespaces surrounding the result, return it.","cleaned_line = comment_re . sub ( r""\1"" , line ) . strip ( )"
"if cleaned_line is false,",if not cleaned_line :
"skip this loop iteration,",continue
append cleaned_lien to statement.,statement . append ( cleaned_line )
"if cleaned_line ends with ';' character,","if cleaned_line . endswith ( "";"" ) :"
"join statements into a string, separated by white spaces, append it to statements.","statements . append ( "" "" . join ( statement ) )"
statement is an empty list.,statement = [ ]
return statements.,return statements
"define the function custom_sql_for_model with 3 arguments: app_config, style and connection.","def custom_sql_for_model ( model , style , connection ) :"
substitute model._meta for opts.,opts = model . _meta
app_dirs is an empty list.,app_dirs = [ ]
"call the method apps.get_app_config with an argument model._met.app_label, substitute path field of the result for app_dir.",app_dir = apps . get_app_config ( model . _meta . app_label ) . path
"join app_dir and string 'sql' into a file path, use the result as an argument for the call to the function os.path.normpath,","app_dirs . append ( os . path . normpath ( os . path . join ( app_dir , 'sql' ) ) )"
"append the result to app_dirs. join app_dir and string 'models/sql' into a file path, use the result as an argument for the call to the function os.path.normpath,","old_app_dir = os . path . normpath ( os . path . join ( app_dir , 'models/sql' ) )"
"append the result to old_app_dirs. if file path old_app_dir exists,",if os . path . exists ( old_app_dir ) :
"call the function warnings.warn with 2 arguments: string ""Custom SQL location '<app_label>/models/sql' is deprecated, use '<app_label>/sql' instead."" and RemovedInDjango19Warning.","warnings . warn ( ""Custom SQL location '<app_label>/models/sql' is "" ""deprecated, use '<app_label>/sql' instead."" , RemovedInDjango19Warning )"
append old_app_dir to app_dirs.,app_dirs . append ( old_app_dir )
output is an empty list.,output = [ ]
"if opts.managed is true,",if opts . managed :
"for every f in opts.local_fields that has an 'post_create_sql' attribute, append f to a list, substitute the resulting list for post_sql_fields.","post_sql_fields = [ f for f in opts . local_fields if hasattr ( f , 'post_create_sql' ) ]"
"for every f in post_sql_fields,",for f in post_sql_fields :
"call the method f.post_create_sql with arguments: style and model._meta.db_table, extend the output with the result.","output . extend ( f . post_create_sql ( style , model . _meta . db_table ) )"
"once split at the '.' value under the 'ENGINE' key of the connection.settings_dict dictionary, substitute last element of the result for backend_name.",backend_name = connection . settings_dict [ 'ENGINE' ] . split ( '.' ) [ - 1 ]
sql_files is an empty list.,sql_files = [ ]
"for every app_dir in app_dirs,",for app_dir in app_dirs :
"join into a file path: app_dir and string %s.%s.sql, where '%s' is replaced by opts.model_name and backend_name, respectively,","sql_files . append ( os . path . join ( app_dir , ""%s.%s.sql"" % ( opts . model_name , backend_name ) ) )"
"append the result to sql_files. join into a file path: app_dir and string %s.%s.sql, where '%s' is replaced by opts.model_name, append the result to sql_files.","sql_files . append ( os . path . join ( app_dir , ""%s.sql"" % opts . model_name ) )"
"for every sql_file in sql_files,",for sql_file in sql_files :
"if file path sql_file exists,",if os . path . exists ( sql_file ) :
"call the function codecs.open with 3 arguments: sql_file, string 'r' and encoding set to settings.FILE_CHARSET, with the result renamed to fp,","with codecs . open ( sql_file , 'r' , encoding = settings . FILE_CHARSET ) as fp :"
"call the method connection.ops.prepare_sql_script with 2 arguments: return value of the function fp.read,","output . extend ( connection . ops . prepare_sql_script ( fp . read ( ) , _allow_fallback = True ) )"
"and _allow_fallback set to boolean True, extend the output with the result. return output.",return output
"define the function emit_pre_migrate_signal with 4 arguments: create_models, verbosity, interactive and db.","def emit_pre_migrate_signal ( create_models , verbosity , interactive , db ) :"
"for app_config in return value of the method apps.get_app_configs,",for app_config in apps . get_app_configs ( ) :
"if app_config.models_module is None,",if app_config . models_module is None :
"skip this loop iteration,",continue
"if verbosity is greater or equal to integer 2,",if verbosity >= 2 :
"replace '%s' in string ""Running pre-migrate handlers for application %s"" with app_config.label, print it to the standard output.","print ( ""Running pre-migrate handlers for application %s"" % app_config . label )"
"call the method models.signals.pre_migrate.send with 5 arguments: sender set to app_config, app_config set to app_config,","models . signals . pre_migrate . send ( sender = app_config , app_config = app_config , verbosity = verbosity , interactive = interactive , using = db )"
"verbosity set to verbosity, interactive set to interactive and using set to db. call the method models.signals.pre_syncdb.send with 6 arguments: sender set to app_config.models_module,","models . signals . pre_syncdb . send ( sender = app_config . models_module , app = app_config . models_module , create_models = create_models , verbosity = verbosity , interactive = interactive , db = db )"
"app set to app_config.models_module, create_models set to create_models, verbosity set to verbosity, interactive set to interactive, and db set to db. define the function emit_post_migrate_signal with 4 arguments: created_models, verbosity, interactive and db.","def emit_post_migrate_signal ( created_models , verbosity , interactive , db ) :"
"for app_config in return value of the method apps.get_app_configs,",for app_config in apps . get_app_configs ( ) :
"if app_config.models_module is None,",if app_config . models_module is None :
"skip this loop iteration,",continue
"if verbosity is greater or equal to integer 2,",if verbosity >= 2 :
"replace '%s' in string ""Running post-migrate handlers for application %s"" with app_config.label, print it to the standard output.","print ( ""Running post-migrate handlers for application %s"" % app_config . label )"
"call the method models.signals.post_migrate.send with 5 arguments: sender set to app_config, app_config set to app_config,","models . signals . post_migrate . send ( sender = app_config , app_config = app_config , verbosity = verbosity , interactive = interactive , using = db )"
"verbosity set to verbosity, interactive set to interactive and using set to db. call the method models.signals.post_syncdb.send with 6 arguments: sender set to app_config.models_module,","models . signals . post_syncdb . send ( sender = app_config . models_module , app = app_config . models_module , created_models = created_models , verbosity = verbosity , interactive = interactive , db = db )"
import module cgi.,import cgi
import module errno.,import errno
import module mimetypes.,import mimetypes
import module os.,import os
import module posixpath.,import posixpath
import module re.,import re
import module shutil.,import shutil
import module stat.,import stat
import module sys.,import sys
import module tempfile.,import tempfile
from os import path into default name space.,from os import path
import module django.,import django
from django.template import Template and Context into default name space.,"from django . template import Template , Context"
from django.utils import archive into default name space.,from django . utils import archive
from django.utils.six.moves.urllib.request import urlretrieve into default name space.,from django . utils . six . moves . urllib . request import urlretrieve
from django.utils._os import rmtree_errorhandle into default name space.,from django . utils . _os import rmtree_errorhandler
from django.core.management.base import BaseCommand and CommandError into default name space.,"from django . core . management . base import BaseCommand , CommandError"
from django.core.management.utils import handle_extensions into default name space.,from django . core . management . utils import handle_extensions
"call the function re.compile with 2 arguments: string '^([a-z]):' and re.I, substitute the result for _drive_re.","_drive_re = re . compile ( '^([a-z]):' , re . I )"
"call the function re.compile with 2 arguments: string '^([a-z])[:|]' and re.I, substitute the result for _url_drive_re.","_url_drive_re = re . compile ( '^([a-z])[:|]' , re . I )"
derive the class TemplateCommand from the BaseCommand base class.,class TemplateCommand ( BaseCommand ) :
requires_system_checks is boolean False.,requires_system_checks = False
can_import_settings is boolean False.,can_import_settings = False
"url_schemes is list of strings 'http', 'https' and 'ftp'.","url_schemes = [ 'http' , 'https' , 'ftp' ]"
leave_locale_alone is boolean True.,leave_locale_alone = True
define the method add_aguments with arguments self and parser.,"def add_arguments ( self , parser ) :"
call the method parser.add_argument with 2 arguments: string 'name' and help set to string 'Name of the application or project.'.,"parser . add_argument ( 'name' , help = 'Name of the application or project.' )"
"call the method parser.add_argument with 3 arguments: string 'directory', nargs set to '?' and help set to string 'Name of the application or project.'.","parser . add_argument ( 'directory' , nargs = '?' , help = 'Optional destination directory' )"
call the method parser.add_argument with 2 arguments: string '--template' and help set to string 'The path or URL to load the template from.'.,"parser . add_argument ( '--template' , help = 'The path or URL to load the template from.' )"
"call the method parser.add_argument with 6 arguments: string '--extension', string '-e', dest set to string 'extensions',","parser . add_argument ( '--extension' , '-e' , dest = 'extensions' , action = 'append' , default = [ 'py' ] , help = 'The file extension(s) to render (default: ""py""). ' 'Separate multiple extensions with commas, or use ' '-e multiple times.' )"
"action set to 'append', default is a list containing string 'py' and help set to string: 'The file extension(s) to render (default: ""py""). Separate multiple extensions with commas, or use -e multiple times.'. call the method parser.add_argument with 6 arguments: string '--name', string '-n', dest set to string 'files',","parser . add_argument ( '--name' , '-n' , dest = 'files' , action = 'append' , default = [ ] , help = 'The file name(s) to render. ' 'Separate multiple extensions with commas, or use ' '-n multiple times.' )"
"action set to string 'append', default as an empty list and help set to a string: 'The file name(s) to render. Separate multiple extensions with commas, or use -n multiple times.'. define the method handle with 5 arguments: self, app_or_project, name, target set to None and unpacked dictionary options.","def handle ( self , app_or_project , name , target = None , ** options ) :"
substitute app_or_project for self.app_or_project.,self . app_or_project = app_or_project
self.paths_to_remove is an empty list.,self . paths_to_remove = [ ]
substitute value under the 'verbosity' key of the options dictionary for self.verbosity.,self . verbosity = options [ 'verbosity' ]
call the method self.validate_name with 2 arguments name and app_or_project.,"self . validate_name ( name , app_or_project )"
"if target is None,",if target is None :
"join the current working directory and name into a file path, substitute it for top_dir.","top_dir = path . join ( os . getcwd ( ) , name )"
"try,",try :
make a directory top_dir.,os . makedirs ( top_dir )
"if OSError renamed to e, exception is caught,",except OSError as e :
"if e.errno equals errno.EEXIST,",if e . errno == errno . EEXIST :
"replace '%s' in string ""'%s' already exists"" with top_dir, substitute it for message.","message = ""'%s' already exists"" % top_dir"
"if not,",else :
substitute e for message.,message = e
raise an CommandError exception with an argument message.,raise CommandError ( message )
"if not,",else :
"ge the absolute path of the return value of the function path.expanduser with the argument target, substitute it for top_dir.",top_dir = os . path . abspath ( path . expanduser ( target ) )
"if file path top_dir doesnt exists,",if not os . path . exists ( top_dir ) :
"raise an CommandError exception with an argument string ""Destination directory '%s' does not exist, please create it first."",","raise CommandError ( ""Destination directory '%s' does not "" ""exist, please create it first."" % top_dir )"
"where '%s' is replaced with top_dir. call the function handle_extensions with 2 arguments: value under the 'extensions' key of the options dictionary,","extensions = tuple ( handle_extensions ( options [ 'extensions' ] , ignored = ( ) ) )"
"and ignored as an empty tuple, convert the result into a tuple and substitute it for extensions. extra_files is an empty list.",extra_files = [ ]
for every file in value under the 'files' key of the options dictionary.,for file in options [ 'files' ] :
"split file by ',' character, apply on its every element a lambda function which takes an argument x,","extra_files . extend ( map ( lambda x : x . strip ( ) , file . split ( ',' ) ) )"
"and returns x striped of the surrounding whitespaces, extend the extra_files with the mapped list. if self.verbosity is greater or equal to integer 2,",if self . verbosity >= 2 :
"call the method self.stdout.write, with an argument string ""Rendering %s template files with extensions: %s\n"",","self . stdout . write ( ""Rendering %s template files with "" ""extensions: %s\n"" % ( app_or_project , ', ' . join ( extensions ) ) )"
"where '%s' is replaced with app_or_project and extensions joined into a string, separated by a string ', '. call the method self.stdout.write, with an argument string ""Rendering %s template files with filenames: %s\n"",","self . stdout . write ( ""Rendering %s template files with "" ""filenames: %s\n"" % ( app_or_project , ', ' . join ( extra_files ) ) )"
"where '%s' is replaced with app_or_project and extra_files joined into a string, separated by a string ', '. append string '_name' to app_or_project, substitute it for base_name.",base_name = '%s_name' % app_or_project
"append string '_template' to app_or_project, substitute it for base_subdir.",base_subdir = '%s_template' % app_or_project
"append string '_directory' to app_or_project, substitute it for base_directory.",base_directory = '%s_directory' % app_or_project
"if second last element of django.VERSION is not equal to a string 'final',",if django . VERSION [ - 2 ] != 'final' :
docs_version is a string 'dev'.,docs_version = 'dev'
"if not,",else :
"convert first 2 elements of django.VERSION into a strings, join them together, separated by a '.', substitute the result for docs_version.",docs_version = '%d.%d' % django . VERSION [ : 2 ]
"context is an instance of a class Context, created with 2 arguments: dictionary created by apllying options to unpacked dictionary containing 3 entries:","context = Context ( dict ( options , ** { base_name : name , base_directory : top_dir , 'docs_version' : docs_version , } ) , autoescape = False )"
"name for base_name, top_dir for base_directory and docs_version for 'docs_version' and autoescape set to boolean False. from django.conf import settings into a default name space,",from django . conf import settings
"if settings.configured is false,",if not settings . configured :
call the method settings.configure.,settings . configure ( )
call the method self.handle_template with 2 arguments: value under the 'template' key of the options dictionary and base_subdir.,"template_dir = self . handle_template ( options [ 'template' ] , base_subdir )"
increment length of template_dir by one and substitute it for prefix_length.,prefix_length = len ( template_dir ) + 1
"for every root, dirs and files in subdirectory tree starting from the base dir template_dir,","for root , dirs , files in os . walk ( template_dir ) :"
"slice root starting from the prefix_length index to the end, substitute it for path_rest.",path_rest = root [ prefix_length : ]
"call the method path_rest.replace with arguments base_name and name, substitute the result for relative_dir.","relative_dir = path_rest . replace ( base_name , name )"
"if relative_dir is true,",if relative_dir :
"join top_dir and relative_dir into a file path, substitute it for target_dir.","target_dir = path . join ( top_dir , relative_dir )"
"if target_dir path doesnt exists,",if not path . exists ( target_dir ) :
"make target_dir directory,",os . mkdir ( target_dir )
"for dirname in dirs,",for dirname in dirs [ : ] :
"if dirname starts with character '.' or dirname equals a string '__pycache__',",if dirname . startswith ( '.' ) or dirname == '__pycache__' :
remove dirname key from dirs.,dirs . remove ( dirname )
"for every filename in files,",for filename in files :
"if filename ends with '.pyo', '.pyc' or '.py.class',","if filename . endswith ( ( '.pyo' , '.pyc' , '.py.class' ) ) :"
"skip this loop iteration,",continue
"join root and filename into a file path, substitute it for old_path.","old_path = path . join ( root , filename )"
"join top_dir, relative_dir and return value of the function filename.replace called with 2 arguments: base_name and name,","new_path = path . join ( top_dir , relative_dir , filename . replace ( base_name , name ) )"
"into a file path, substitute it for new_path. if new_path file path exists,",if path . exists ( new_path ) :
raise a CommandError exception with an argument:,"raise CommandError ( ""%s already exists, overlaying a "" ""project or app into an existing "" ""directory won't replace conflicting "" ""files"" % new_path )"
"string ""%s already exists, overlaying a project or app into an existing directory won't replace conflicting files"", where '%s"" is replaced with new_path. open old_path file in 'rb' mode, with file descriptor renamed to template_file,","with open ( old_path , 'rb' ) as template_file :"
"call the method template_file.read, substitute it for content.",content = template_file . read ( )
"if filename ends with extensions or filename is contained in extra_files,",if filename . endswith ( extensions ) or filename in extra_files :
"call the method content.decode with an argument string 'utf-8', substitute it for content.",content = content . decode ( 'utf-8' )
"template is an instance of Template class, created with an argument content.",template = Template ( content )
"call the method template.render with an argument context, substitute it for content.",content = template . render ( context )
"call the method content.encode with an argument string 'utf-8', substitute it for content.",content = content . encode ( 'utf-8' )
"open new_path file in 'wb' mode, with file descriptor renamed to new_file,","with open ( new_path , 'wb' ) as new_file :"
write content to new_file file.,new_file . write ( content )
"if self.verbosity is greater or equal to integer 2,",if self . verbosity >= 2 :
"replace '%s' in string ""Creating %s\n"" with new_path, write it to the self.stdout stream.","self . stdout . write ( ""Creating %s\n"" % new_path )"
"try,",try :
call the function shutil.copymode with arguments old_path and new_path.,"shutil . copymode ( old_path , new_path )"
call the method self.make_writeable with an argument new_path.,self . make_writeable ( new_path )
"if OSError exception is caught,",except OSError :
"replace '%s' in string ""Notice: Couldn't set permission bits on %s. You're probably using an uncommon filesystem setup. No problem."",","self . stderr . write ( ""Notice: Couldn't set permission bits on %s. You're "" ""probably using an uncommon filesystem setup. No "" ""problem."" % new_path , self . style . NOTICE )"
"with new_path and self.style.NOTICE, respectively, write it to self.stderr stream. if self.paths_to_remove is true,",if self . paths_to_remove :
"if self.verbosity is greater or equal to integer 2,",if self . verbosity >= 2 :
"write string ""Cleaning up temporary files.\n"" to self.stdout stream.","self . stdout . write ( ""Cleaning up temporary files.\n"" )"
"for every path_to_remove in self.paths_to_remove,",for path_to_remove in self . paths_to_remove :
"if path_to_remove is file,",if path . isfile ( path_to_remove ) :
"remove file path_to_remove,",os . remove ( path_to_remove )
"if not,",else :
call the function shutil.rmtree with 2 arguments: path_to_remove and onerror set to rmtree_errorhandler.,"shutil . rmtree ( path_to_remove , onerror = rmtree_errorhandler )"
"define the method handle_template with 3 arguments: self, template and subdir.","def handle_template ( self , template , subdir ) :"
"if template is None,",if template is None :
"join first element of django.__path__, string 'conf' and subdir into a valid file path, return it.","return path . join ( django . __path__ [ 0 ] , 'conf' , subdir )"
"if not,",else :
"if template starts with a string 'file://',",if template . startswith ( 'file://' ) :
remove first 7 elements form template.,template = template [ 7 : ]
"call the method path.expanduser with an argument template, substitute it for expanded_template.",expanded_template = path . expanduser ( template )
"call the method path.normpath with an argument expanded_template, substitute it for expanded_template.",expanded_template = path . normpath ( expanded_template )
"if expanded_template is a directory,",if path . isdir ( expanded_template ) :
return expanded_template.,return expanded_template
"call the method self.is_url with an argument template, if it evaluates to true,",if self . is_url ( template ) :
"call the method self.download with an argument template, substitute the result for absolute_path.",absolute_path = self . download ( template )
"if not,",else :
"get the absolute file path of the expanded_template, substitute it for absolute_path.",absolute_path = path . abspath ( expanded_template )
"if file path absolute_path exists,",if path . exists ( absolute_path ) :
"call the method self.extract with an argument absolute_path, return the result.",return self . extract ( absolute_path )
"raise an CommandError exception with an argument string ""couldn't handle %s template %s."", replace '%s' with self.app_or_project and template.","raise CommandError ( ""couldn't handle %s template %s."" % ( self . app_or_project , template ) )"
"define validate_name with 3 arguments: self, name and app_or_project.","def validate_name ( self , name , app_or_project ) :"
"if name is None,",if name is None :
"raise an CommandError exception with an argument string ""you must provide %s %s name"", where '%s' is replaced with string 'an',","raise CommandError ( ""you must provide %s %s name"" % ( ""an"" if app_or_project == ""app"" else ""a"" , app_or_project ) )"
"and app_or_project if app_or_project equals to string 'app', if not, it is replaced with 'a' and app_or_project. call the method re.search with 2 arguments: raw string '^[_a-zA-Z]\w*$' and name, if it evaluates to false,","if not re . search ( r'^[_a-zA-Z]\w*$' , name ) :"
"call the method re.search with 2 arguments: raw string '^[_a-zA-Z]' and name, if it evaluates to false,","if not re . search ( r'^[_a-zA-Z]' , name ) :"
message is a string 'make sure the name begins with a letter or underscore'.,message = 'make sure the name begins with a letter or underscore'
"if not,",else :
"message is a string 'use only numbers, letters and underscores'.","message = 'use only numbers, letters and underscores'"
"raise an CommandError with an argument string ""%r is not a valid %s name. Please %s."", were '%r' is replaced with name,","raise CommandError ( ""%r is not a valid %s name. Please %s."" % ( name , app_or_project , message ) )"
"and '%s' is replaced with app_or_project and message, respectively. define the method download with arguments self and url.","def download ( self , url ) :"
define the function cleanup_url with an argument url.,def cleanup_url ( url ) :
"strip url of surrounding '/' characters, substitute it for tmp.",tmp = url . rstrip ( '/' )
"split tmp at '/' character, substitute the last element of the result for filename.",filename = tmp . split ( '/' ) [ - 1 ]
"if url ends with '/' character,",if url . endswith ( '/' ) :
"append '/' to tmp, substitute it for display_url.",display_url = tmp + '/'
"if not,",else :
substitute url for display_url.,display_url = url
return filename and display_url.,"return filename , display_url"
replace '%s' in string 'django_%s_template_' with self.app_or_project.,prefix = 'django_%s_template_' % self . app_or_project
call the function tempfile.mkdtemp with arguments: prefix set to prefix and suffix set to string '_download'.,"tempdir = tempfile . mkdtemp ( prefix = prefix , suffix = '_download' )"
append the tempdir to self.paths_to_remove.,self . paths_to_remove . append ( tempdir )
"call the function cleanup_url with an argument url, assign the result to filename and display_url, respectively.","filename , display_url = cleanup_url ( url )"
"if self.verbosity is greater or equal to integer 2,",if self . verbosity >= 2 :
"replace '%s' in string ""Downloading %s\n"", with display_url, write it to self.stdout stream.","self . stdout . write ( ""Downloading %s\n"" % display_url )"
"try,",try :
"call the function urlretrieve with arguments url and tempdir and filename joined into a file path, assign the result to the_path, and info, respectively.","the_path , info = urlretrieve ( url , path . join ( tempdir , filename ) )"
"if IOErro, renamed to e, exception is caught,",except IOError as e :
"raise an CommandError exception with an argument string ""couldn't download URL %s to %s: %s"", where '%s' is replaced with url,","raise CommandError ( ""couldn't download URL %s to %s: %s"" % ( url , filename , e ) )"
"filename and e. split the_path at the '/' character, substitute last element of the result for used_name.",used_name = the_path . split ( '/' ) [ - 1 ]
"get the value under the 'content-disposition' key of the info dictionary, substitute it for content_disposition.",content_disposition = info . get ( 'content-disposition' )
"if content_disposition is true,",if content_disposition :
"call the method cgi.parse_header with an argument content_disposition, assign the result to _ and params, respectively.","_ , params = cgi . parse_header ( content_disposition )"
"get the value under the 'filename' key of the params dictionary, if the key exists substitute it for guessed_filename,",guessed_filename = params . get ( 'filename' ) or used_name
"if not, substitute used_name for guessed_filename. if not,",else :
substitute used_name for guessed_filename.,guessed_filename = used_name
"call the method self.splitext with an argument guessed_filename, substitute the second element of the result for ext.",ext = self . splitext ( guessed_filename ) [ 1 ]
"get the value under the 'content-type' key of the info dictionary, substitute it for content_type.",content_type = info . get ( 'content-type' )
"if ext is false and content_type is true,",if not ext and content_type :
"call the method mimetypes.guess_extension with an argument content_type, substitute result for ext.",ext = mimetypes . guess_extension ( content_type )
"if ext is true,",if ext :
append ext to guessed_filename.,guessed_filename += ext
"if used_name is not equal to guessed_filename,",if used_name != guessed_filename :
"join tempdir and guessed_filename into a file path, substitute it for guessed_path.","guessed_path = path . join ( tempdir , guessed_filename )"
call the function shutil.move with arguments the_path and guessed_path.,"shutil . move ( the_path , guessed_path )"
return guessed_path.,return guessed_path
return the_path.,return the_path
define the method splitext with arguments self and the_path.,"def splitext ( self , the_path ) :"
call the method posixpath.splitext with an argument the_path.,"base , ext = posixpath . splitext ( the_path )"
"convert base to lowercase, if it ends with string '.tar',",if base . lower ( ) . endswith ( '.tar' ) :
"take last four elements of base and append ext to it, substitute result for ext.",ext = base [ - 4 : ] + ext
substitute last four elements of base for base.,base = base [ : - 4 ]
return base and ext.,"return base , ext"
define the function with arguments self and filename.,"def extract ( self , filename ) :"
"replace '%s' in string 'django_%s_template_' with self.app_or_project, substitute it for prefix.",prefix = 'django_%s_template_' % self . app_or_project
"call the method tempfile.mkdtemp with 2 arguments: prefix set to prefix, suffix set to string '_extract', substitute the result for tempdir.","tempdir = tempfile . mkdtemp ( prefix = prefix , suffix = '_extract' )"
append tempdir to self.self.paths_to_remove.,self . paths_to_remove . append ( tempdir )
if self.verbosity is greater or equal to integer 2.,if self . verbosity >= 2 :
"substitute '%s' in string ""Extracting %s\n"" with filename, write it to self.stdout stream.","self . stdout . write ( ""Extracting %s\n"" % filename )"
"try,",try :
call the method archive.extract with arguments: filename and tempdir.,"archive . extract ( filename , tempdir )"
return tempdir.,return tempdir
"if archive.ArchiveException or IOError, renamed to e, exception are caught,","except ( archive . ArchiveException , IOError ) as e :"
"raise an CommandError with an argument string ""couldn't extract file %s to %s: %s"", where '%s' is replaced with filename, tempdir and e.","raise CommandError ( ""couldn't extract file %s to %s: %s"" % ( filename , tempdir , e ) )"
define the method is_url with arguments self and template.,"def is_url ( self , template ) :"
"if character ':' is not contained in template,",if ':' not in template :
return boolean False.,return False
"split template once at the first character ':', convert the first element to lowercase and substitute it for scheme.","scheme = template . split ( ':' , 1 ) [ 0 ] . lower ( )"
"if scheme is countaine in self.url_schemes return boolean True, otherwise return False.",return scheme in self . url_schemes
define the method make_writeable with arguments self and filename.,"def make_writeable ( self , filename ) :"
"if sys.platform starts with string 'java',",if sys . platform . startswith ( 'java' ) :
return nothing.,return
"if call to the method os.access with arguments: filename and os.W_OK, evaluates to false,","if not os . access ( filename , os . W_OK ) :"
"call the function os.stat with an argument filename, substitute the result for st.",st = os . stat ( filename )
"call the method stat.S_IMODE with an argument st.st_mode, calculate binary OR with the result and stat.S_IWUSR, as operands,",new_permissions = stat . S_IMODE ( st . st_mode ) | stat . S_IWUSR
substitute the result for new_permission. call the function os.chmod wiht arguments filename and new_permissions.,"os . chmod ( filename , new_permissions )"
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
import module os.,import os
from subprocess import PIPE and Popen into default name space.,"from subprocess import PIPE , Popen"
import module sys.,import sys
from django.utils.encoding import force_text and DEFAULT_LOCALE_ENCODING into default name space.,"from django . utils . encoding import force_text , DEFAULT_LOCALE_ENCODING"
from django.utils import six into default name space.,from django . utils import six
from .base import CommandError into default name space.,from . base import CommandError
define the function popen_wrapper with 2 arguments: args and os_err_exc_type set to CommandError.,"def popen_wrapper ( args , os_err_exc_type = CommandError ) :"
"try,",try :
"p is a instance of Popen class, created with 6 arguments: args, shell set to boolean False, stdout set to PIPE,","p = Popen ( args , shell = False , stdout = PIPE , stderr = PIPE , close_fds = os . name != 'nt' , universal_newlines = True )"
"stderr set to PIPE, close_fds set to boolean True is os.name is not equal to 'nt', universal_newlines set to boolean True. if OSError, renamed to e, exception is caught,",except OSError as e :
"call the force_text function with 3 arguments: e.strerror, DEFAULT_LOCALE_ENCODING and strings_only set to boolean True.","strerror = force_text ( e . strerror , DEFAULT_LOCALE_ENCODING , strings_only = True )"
"call the method six.reraise 3 with arguments: os_err_exc_type, return value of the function os_err_exc_type,","six . reraise ( os_err_exc_type , os_err_exc_type ( 'Error executing %s: %s' % ( args [ 0 ] , strerror ) ) , sys . exc_info ( ) [ 2 ] )"
"called with string as an argument 'Error executing %s: %s', where '%s' is replaced by: first element of args and strerror, respective, and third element of the result of the function sys.exc_info. call the method p.communicate, assign the result to output and errors, respectively.","output , errors = p . communicate ( )"
"return a tuple containing 3 entries: output, result of the function force_text, called with 3 arguments: errors,","return ( output , force_text ( errors , DEFAULT_LOCALE_ENCODING , strings_only = True ) , p . returncode )"
DEFAULT_LOCALE_ENCODING and strings_only set to boolean True and p.returncode. define the function handle_extensions with 2 arguments: extensions set to tuple containing string 'html' and ignored set to tuple containing string 'py'.,"def handle_extensions ( extensions = ( 'html' , ) , ignored = ( 'py' , ) ) :"
"ext_list is an empty list,",ext_list = [ ]
"for every ext in extensions,",for ext in extensions :
"delete all the whitespaces from ext, split it by ',' character, extend ext_list with the result.","ext_list . extend ( ext . replace ( ' ' , '' ) . split ( ',' ) )"
"for every i and ext in enumerated iterable ext_list,","for i , ext in enumerate ( ext_list ) :"
"if ext doesnt start with '.' character,",if not ext . startswith ( '.' ) :
prepend '.' to the i-th element of the ext_list.,ext_list [ i ] = '.%s' % ext_list [ i ]
"if striped x by '.' character is not contained in ignored, for every x in ext_list put x into a set, return the resulting set.",return set ( x for x in ext_list if x . strip ( '.' ) not in ignored )
"define the function find_command with 3 arguments: cmd, path set to None and pathext set to None.","def find_command ( cmd , path = None , pathext = None ) :"
"if path is None,",if path is None :
"call the function os.environ.get with 2 arguments: string 'PATH' and an empty string, split the result at the os.pathsep, substitute the result for path.","path = os . environ . get ( 'PATH' , '' ) . split ( os . pathsep )"
"if path is an instance of six.string_types,","if isinstance ( path , six . string_types ) :"
path is an list containing path.,path = [ path ]
"if pathext is None,",if pathext is None :
"call the method os.environ.get with 2 arguments: strings 'PATHEXT' and '.COM;.EXE;.BAT;.CMD', split the result at os.pathsep, substitute it for pathext.","pathext = os . environ . get ( 'PATHEXT' , '.COM;.EXE;.BAT;.CMD' ) . split ( os . pathsep )"
"for ext in pathext,",for ext in pathext :
"if cmd ends with ext,",if cmd . endswith ( ext ) :
pathext is an list containing an empty string.,pathext = [ '' ]
break the loop execution.,break
"for every p in path,",for p in path :
"join p and cmd into a file path, substitute it for f.","f = os . path . join ( p , cmd )"
"if f is a file,",if os . path . isfile ( f ) :
return f.,return f
"for every ext in pathext,",for ext in pathext :
"add ext to f, substitute the result for fext.",fext = f + ext
"if fext is a file,",if os . path . isfile ( fext ) :
return fext.,return fext
return None.,return None
import module collections.,import collections
from math import ceil into default name space.,from math import ceil
from django.utils import six into default name space.,from django . utils import six
derive the class InvalidPage from the Exception base class.,class InvalidPage ( Exception ) :
do nothing.,pass
derive the class PageNotAnInteger from the InvalidPage base class.,class PageNotAnInteger ( InvalidPage ) :
do nothing.,pass
derive the class EmptyPage from the InvalidPage base class.,class EmptyPage ( InvalidPage ) :
do nothing.,pass
derive the class Paginator from the object base class.,class Paginator ( object ) :
"def the method __init__ with 5 arguments: self, object_list, per_page, orphans set to integer 0 and allow_empty_first_page set to boolean True.","def __init__ ( self , object_list , per_page , orphans = 0 , allow_empty_first_page = True ) :"
substitute object_list for self.object_list.,self . object_list = object_list
convert per_page into an integer and substitute it for self.per_page.,self . per_page = int ( per_page )
convert orphans into an integer and substitute it for self.orphans.,self . orphans = int ( orphans )
substitute allow_empty_first_page for self.allow_empty_first_page.,self . allow_empty_first_page = allow_empty_first_page
self._num_pages and self._count are None.,self . _num_pages = self . _count = None
define the method validate_number with self class instance and number as arguments.,"def validate_number ( self , number ) :"
"try,",try :
convert number into an integer and substitute it for number,number = int ( number )
"if TypeError or ValueError exceptions are caught,","except ( TypeError , ValueError ) :"
raise an exception PageNotAnInteger with string 'That page number is not an integer' as an argument.,raise PageNotAnInteger ( 'That page number is not an integer' )
"if number is lesser than integer 1,",if number < 1 :
raise an EmptyPage exception with string 'That page number is less than 1' as an argument.,raise EmptyPage ( 'That page number is less than 1' )
"if number is greater than self.num_pages,",if number > self . num_pages :
"if number equals a integer 1 and self.allow_empty_first_page is true,",if number == 1 and self . allow_empty_first_page :
do nothing.,pass
"if not,",else :
raise an EmptyPage exception with string 'That page contains no results' as an argument.,raise EmptyPage ( 'That page contains no results' )
return number.,return number
define the method page with self class instance and number as arguments.,"def page ( self , number ) :"
"call the method self.validate_number with an argument number, substitute it for number.",number = self . validate_number ( number )
"decrement number by one, multiply it with self.per_page, substitute the result for bottom.",bottom = ( number - 1 ) * self . per_page
"sum bottom and self.per_page, substitute the result for top.",top = bottom + self . per_page
"if sum of the top and self.orphans is greater or equal to self.count,",if top + self . orphans >= self . count :
substitute self.count for top.,top = self . count
"call the self._get_pages method with 3 arguments: self.object_list from the bottom to the top index, number and self, return the result.","return self . _get_page ( self . object_list [ bottom : top ] , number , self )"
"define the method _get_page with self class instance, unpacked list args and unpacked dictionary kwargs as arguments.","def _get_page ( self , * args , ** kwargs ) :"
"return a instance of the class Page, created with 2 arguments: unpacked list args and unpacked dictionary kwargs.","return Page ( * args , ** kwargs )"
define the method _get_count with an argument self.,def _get_count ( self ) :
"if self._count is None,",if self . _count is None :
"try,",try :
substitute the return value of the method self.object_list.count for self._count.,self . _count = self . object_list . count ( )
"if TypeError or AttributeError exceptions are caught,","except ( AttributeError , TypeError ) :"
substitute length of self.object_list for self._count.,self . _count = len ( self . object_list )
return self._count.,return self . _count
count is a property object with _get_count as a getter method.,count = property ( _get_count )
define the method _get_num_pages with an argument self.,def _get_num_pages ( self ) :
"if self._num_pages is None,",if self . _num_pages is None :
"if self.count equals a integer 0 and self.allow_empty_first_page is false,",if self . count == 0 and not self . allow_empty_first_page :
self._num_pages is a integer 0.,self . _num_pages = 0
"if not,",else :
"get greater value between integer 1 and result of subtraction of self.orphans from self.count, substitute it for hits.","hits = max ( 1 , self . count - self . orphans )"
"divide hits by a floating point number self.per_page, convert its ceiling value to an integer and substitute it for self._num_pages.",self . _num_pages = int ( ceil ( hits / float ( self . per_page ) ) )
return self._num_pages.,return self . _num_pages
num_pages is a property object with _get_num_pages as a getter method.,num_pages = property ( _get_num_pages )
define the method _get_page_range with an argument self.,def _get_page_range ( self ) :
return all the integers from the integer 1 to the self.num_pages.,"return range ( 1 , self . num_pages + 1 )"
page_range is a property object with _get_page_range as a getter method.,page_range = property ( _get_page_range )
substitute Paginator for QuerySetPaginator.,QuerySetPaginator = Paginator
derive the class Page from the collections.Sequence base class.,class Page ( collections . Sequence ) :
"define the method __init__ with 4 arguments: self, object_list, number, and paginator.","def __init__ ( self , object_list , number , paginator ) :"
substitute object_list for self.object_list.,self . object_list = object_list
substitute number for self.number.,self . number = number
substitute paginator for self.paginator.,self . paginator = paginator
define the method __repr__ with an argument self.,def __repr__ ( self ) :
"return the string '<Page %s of %s>', with occurrences of '%s' replaced by self.number and self.paginator.num_pages, respectively.","return '<Page %s of %s>' % ( self . number , self . paginator . num_pages )"
define the method __len__ with an argument self.,def __len__ ( self ) :
return the length of self.object_list.,return len ( self . object_list )
define the method __getitem__ with arguments self and index.,"def __getitem__ ( self , index ) :"
"if index is not an instance of six.integer_types or tuple type,","if not isinstance ( index , ( slice , ) + six . integer_types ) :"
"raise a TypeError exception,",raise TypeError
"if self.object is not an instance of list type,","if not isinstance ( self . object_list , list ) :"
convert self.object_list to a list.,self . object_list = list ( self . object_list )
return self.object_list element at index.,return self . object_list [ index ]
define the method has_next with an argument self.,def has_next ( self ) :
"if self.number is lesser than self.paginator.num_pages, return boolean True, otherwise return boolean False.",return self . number < self . paginator . num_pages
define the method has_previous with an argument self.,def has_previous ( self ) :
"if self.number is greater than integer 1, return boolean True, otherwise return boolean False.",return self . number > 1
define the method has_other_pages with an argument self.,def has_other_pages ( self ) :
"call the method self.has_previous, if it evaluate to false, call the self.has_next method, return the result.",return self . has_previous ( ) or self . has_next ( )
define the method next_page_number with an argument self.,def next_page_number ( self ) :
"call the method self.paginator.validate_number with self.number incremented by 1 as argument, return the result.",return self . paginator . validate_number ( self . number + 1 )
define the method previous_page_number with an argument self.,def previous_page_number ( self ) :
"call the method self.paginator.validate_number with self.number decremented by 1 as argument, return the result.",return self . paginator . validate_number ( self . number - 1 )
define the method start_index with an argument self.,def start_index ( self ) :
"if self.paginator.count equals a integer 0,",if self . paginator . count == 0 :
return integer 0.,return 0
"decrement self.number by one, multiply it by self.paginator.per_page, increment the result by one, return it.",return ( self . paginator . per_page * ( self . number - 1 ) ) + 1
define the method end_index with an argument self.,def end_index ( self ) :
"if self.number equals to self.paginator.num_pages,",if self . number == self . paginator . num_pages :
return self.paginator.count.,return self . paginator . count
"multiply self.number and self.paginator.per_page, return the result.",return self . number * self . paginator . per_page
import module importlib.,import importlib
from django.conf import settings into default name space.,from django . conf import settings
from django.utils import six into default name space.,from django . utils import six
from django.core.serializers.base import SerializerDoesNotExist into default name space.,from django . core . serializers . base import SerializerDoesNotExist
"BUILTIN_SERIALIZERS is a dictionary containing 4 inital entries: ""django.core.serializers.xml_serializer"" for ""xml"",","BUILTIN_SERIALIZERS = { ""xml"" : ""django.core.serializers.xml_serializer"" , ""python"" : ""django.core.serializers.python"" , ""json"" : ""django.core.serializers.json"" , ""yaml"" : ""django.core.serializers.pyyaml"" , }"
"""django.core.serializers.python"" for ""python"", ""django.core.serializers.json"" for ""json"", and ""django.core.serializers.pyyaml"" for ""yaml"". _serializers is an empty dictionary.",_serializers = { }
derive the class BadSerializer from the object base class.,class BadSerializer ( object ) :
internal_use_only is boolean False.,internal_use_only = False
define the __init__method with arguments self and exception.,"def __init__ ( self , exception ) :"
substitute exception for self.exception.,self . exception = exception
"define the __call__method with arguments self, unpacked list args and unpacked dictionary kwargs.","def __call__ ( self , * args , ** kwargs ) :"
raise an self.exception exception.,raise self . exception
"define the function register_serializer with 3 arguments: format, serializer_module and serializers set to None.","def register_serializer ( format , serializer_module , serializers = None ) :"
"if serializers is None and _serializers is false,",if serializers is None and not _serializers :
call the function _load_serializers.,_load_serializers ( )
"try,",try :
"call the function importlib.import_module with an argument serializer_module, substitute it for module.",module = importlib . import_module ( serializer_module )
"if ImportError, renamed to exc, exception is caught,",except ImportError as exc :
"ba_serializer is a instance of BadSerializer class, created with an argument exc.",bad_serializer = BadSerializer ( exc )
"create a instance of a class BadSerializerModule from the object base class, with elements Deserializer set to bad_serializer and Serializer set to bad_serializer.","module = type ( 'BadSerializerModule' , ( object , ) , { 'Deserializer' : bad_serializer , 'Serializer' : bad_serializer , } )"
"if serializers is None,",if serializers is None :
substitute module for the value under the format key of the _serializers dictionary.,_serializers [ format ] = module
"if not,",else :
substitute module for the value under the format key of the serializers dictionary.,serializers [ format ] = module
define the function unregister_serializer with an argument format.,def unregister_serializer ( format ) :
"if _serializers is false,",if not _serializers :
call the function _load_serializers.,_load_serializers ( )
"if format is not contained in _serializers,",if format not in _serializers :
raise a SerializerDoesNotExist exception with an argument format.,raise SerializerDoesNotExist ( format )
delete the _serializers dictionary entry at the format key.,del _serializers [ format ]
define the function get_serializer with an argument format.,def get_serializer ( format ) :
"if _serializers is false,",if not _serializers :
call the function _load_serializers.,_load_serializers ( )
"if format is not contained in _serializers,",if format not in _serializers :
raise a SerializerDoesNotExist exception with an argument format.,raise SerializerDoesNotExist ( format )
"get the value under the format key of the _serializers dictionary, return the Serializer filed of the result.",return _serializers [ format ] . Serializer
define the function get_serializer_formats.,def get_serializer_formats ( ) :
"if _serializers is false,",if not _serializers :
call the function _load_serializers.,_load_serializers ( )
"convert _serializers into a list, return it.",return list ( _serializers )
define the function get_public_serializer_formats.,def get_public_serializer_formats ( ) :
"f _serializers is false,",if not _serializers :
call the function _load_serializers.,_load_serializers ( )
"append k into a list for every k and v in return value of the six.iteritems function with an argument _serializers,","return [ k for k , v in six . iteritems ( _serializers ) if not v . Serializer . internal_use_only ]"
"only if v.Serializer.internal_use_only is false, return the resulting list. define the function get_deserializer with an argument format.",def get_deserializer ( format ) :
"f _serializers is false,",if not _serializers :
call the function _load_serializers.,_load_serializers ( )
"if format is not contained in _serializers,",if format not in _serializers :
raise a SerializerDoesNotExist exception with an argument format.,raise SerializerDoesNotExist ( format )
"get the value under the format key of the _serializers dictionary, return the Deserializer filed of the result.",return _serializers [ format ] . Deserializer
"define the function serializer with 3 arguments: format, queryset and unpacked dictionary options.","def serialize ( format , queryset , ** options ) :"
"call the get_serializer function with an argument format, call the return value object and substitute it for s.",s = get_serializer ( format ) ( )
call the s.serialize method with arguments queryset and unpacked dictionary options.,"s . serialize ( queryset , ** options )"
"evaluate the method s.getvalue, return the result.",return s . getvalue ( )
"define the function deserialize with 3 arguments: format, stream_or_string and unpacked dictionary options.","def deserialize ( format , stream_or_string , ** options ) :"
"call the get_deserializer function with an argument format, substitute the result for d.",d = get_deserializer ( format )
"call the object d with arguments stream_or_string and unpacked dictionary options, return the result.","return d ( stream_or_string , ** options )"
define the function _load_serializers.,def _load_serializers ( ) :
use the global variable _serializers.,global _serializers
serializers is an empty dictionary.,serializers = { }
"for every format in BUILTIN_SERIALIZERS,",for format in BUILTIN_SERIALIZERS :
"call the function register_serializer with 3 arguments: format, value under the format key of the BUILTIN_SERIALIZERS dictionary and serializers.","register_serializer ( format , BUILTIN_SERIALIZERS [ format ] , serializers )"
"if setting has an ""SERIALIZATION_MODULES"" attribute,","if hasattr ( settings , ""SERIALIZATION_MODULES"" ) :"
"for every format in settings.SERIALIZATION_MODULES,",for format in settings . SERIALIZATION_MODULES :
"call the function register_serializer with 3 arguments: format, value under the format key of the settings.SERIALIZATION_MODULES dictionary and serializers.","register_serializer ( format , settings . SERIALIZATION_MODULES [ format ] , serializers )"
substitute serializers for _serializers.,_serializers = serializers
import module warnings.,import warnings
from django.db import models into default name space.,from django . db import models
from django.utils import six into default name space.,from django . utils import six
from django.utils.deprecation import RemovedInDjango19Warning into default name space.,from django . utils . deprecation import RemovedInDjango19Warning
derive the class SerializerDoesNotExist from the KeyError base class.,class SerializerDoesNotExist ( KeyError ) :
do nothing.,pass
derive the class SerializationError from the Exception base class.,class SerializationError ( Exception ) :
do nothing.,pass
derive the class DeserializationError from the Exception base class.,class DeserializationError ( Exception ) :
do nothing.,pass
derive the class Serializer from the object base class.,class Serializer ( object ) :
internal_use_only is a boolean False.,internal_use_only = False
"define the method serialize with 3 arguments: self, queryset and unpacked dictionary options.","def serialize ( self , queryset , ** options ) :"
substitute options for self.options.,self . options = options
"remove the 'stream' key from the options dictionary and substitute it for self.stream,","self . stream = options . pop ( ""stream"" , six . StringIO ( ) )"
"if the key doesnt exists call the six.String function and substitute the result for self.stream. remove the 'fields' key from the options dictionary and substitute it for self.selected_fields,","self . selected_fields = options . pop ( ""fields"" , None )"
"if the key doesnt exists substitute None for self.selected_fields. remove the 'use_natural_keys' key from the options dictionary and substitute it for self.use_natural_keys,","self . use_natural_keys = options . pop ( ""use_natural_keys"" , False )"
"if the key doesnt exists substitute boolean False for self.use_natural_keys. if self.use_natural_keys is true,",if self . use_natural_keys :
"call the function warnings.warn with 2 arguments: string ""``use_natural_keys`` is deprecated; use ``use_natural_foreign_keys`` instead."" and RemovedInDjango19Warning.","warnings . warn ( ""``use_natural_keys`` is deprecated; use ``use_natural_foreign_keys`` instead."" , RemovedInDjango19Warning )"
"remove the 'use_natural_primary_keys' key from the options dictionary and substitute it for self.use_natural_foreign_keys,","self . use_natural_foreign_keys = options . pop ( 'use_natural_foreign_keys' , False ) or self . use_natural_keys"
"if the key doesnt exists substitute self.use_natural_keys for self.use_natural_foreign_keys. remove the 'use_natural_primary_keys' key from the options dictionary and substitute it for self.use_natural_primary_keys,","self . use_natural_primary_keys = options . pop ( 'use_natural_primary_keys' , False )"
if the key doesnt exists substitute boolean False for self.use_natural_primary_keys. call the method self.start_serialization,self . start_serialization ( )
self.first is boolean True.,self . first = True
"for every obj in queryset,",for obj in queryset :
call the self.start_object with an argument obj.,self . start_object ( obj )
substitute obj._meta.concrete_model for concrete_model.,concrete_model = obj . _meta . concrete_model
"for every field in concrete_model._meta.local_fields,",for field in concrete_model . _meta . local_fields :
"if field.serialize is true,",if field . serialize :
"if field.rel is None,",if field . rel is None :
if self.selected_fields is None or field.attname is contained in self.selected_fields,if self . selected_fields is None or field . attname in self . selected_fields :
call the method self.handle_field with arguments obj and filed.,"self . handle_field ( obj , field )"
"if not,",else :
if self.selected_fields is None or last three elements of field.attname are contained in self.selected_fields:,if self . selected_fields is None or field . attname [ : - 3 ] in self . selected_fields :
call the method self.handle_fk_field with arguments obj and field.,"self . handle_fk_field ( obj , field )"
"for every field in concrete_model._meta.many_to_many,",for field in concrete_model . _meta . many_to_many :
"if field.serialize is true,",if field . serialize :
"if self.selected_fields is None or field.attname is contained in self.selected_fields,",if self . selected_fields is None or field . attname in self . selected_fields :
call the method self.handle_m2m_field with arguments obj and filed.,"self . handle_m2m_field ( obj , field )"
call the method self.end_object with an argument obj.,self . end_object ( obj )
"if self.first is true,",if self . first :
self.first is boolean False.,self . first = False
call the method self.end_serialization.,self . end_serialization ( )
"call the method self.getvalue, return the result.",return self . getvalue ( )
