nl,code
from threading import local into default name space.,from threading import local
import module warnings.,import warnings
from django.conf import settings into default name space.,from django . conf import settings
from django.core import signals into default name space.,from django . core import signals
"from django.core.cache.backends.base import InvalidCacheBackendError, CacheKeyWarning and BaseCache into default name space.","from django . core . cache . backends . base import ( InvalidCacheBackendError , CacheKeyWarning , BaseCache )"
from django.core.exceptions import ImproperlyConfigured into default name space.,from django . core . exceptions import ImproperlyConfigured
from django.utils.deprecation import RemovedInDjango19Warning into default name space.,from django . utils . deprecation import RemovedInDjango19Warning
from django.utils.module_loading import import_string into default name space.,from django . utils . module_loading import import_string
"__all__ is an list containing 6 elements: 'get_cache', 'cache', 'DEFAULT_CACHE_ALIAS', 'InvalidCacheBackendError',","__all__ = [ 'get_cache' , 'cache' , 'DEFAULT_CACHE_ALIAS' , 'InvalidCacheBackendError' , 'CacheKeyWarning' , 'BaseCache' , ]"
'CacheKeyWarning' and 'BaseCache' DEFAULT_CACHE_ALIAS is a string 'default'.,DEFAULT_CACHE_ALIAS = 'default'
"if DEFAULT_CACHE_ALIAS is not contained in settings.CACHES,",if DEFAULT_CACHE_ALIAS not in settings . CACHES :
"raise an exception ImproperlyConfigured with string ""You must define a '%s' cache"" as argument, with '%s' replaced with DEFAULT_CACHE_ALIAS converted into a string.","raise ImproperlyConfigured ( ""You must define a '%s' cache"" % DEFAULT_CACHE_ALIAS )"
define the function get_cache with backend and dictionary pair of elements kwargs as arguments.,"def get_cache ( backend , ** kwargs ) :"
"call the function warnings.warn with string ""'get_cache' is deprecated in favor of 'caches'."", RemovedInDjango19Warning,","warnings . warn ( ""'get_cache' is deprecated in favor of 'caches'."" , RemovedInDjango19Warning , stacklevel = 2 )"
"and stacklevel set to 2 as arguments. call the _create_cache with backend and dictionary kwargs as arguments, substitute the result for cache.","cache = _create_cache ( backend , ** kwargs )"
call the function signals.request_finished.connect with argument cache.close.,signals . request_finished . connect ( cache . close )
return cache.,return cache
define the function _create_cache with backend and dictionary pair of elements kwargs as arguments.,"def _create_cache ( backend , ** kwargs ) :"
"try,",try :
"try,",try :
substitute value under the backend key of settings.CACHES dictionary for conf.,conf = settings . CACHES [ backend ]
"if KeyError exception is caught,",except KeyError :
"try,",try :
call the function import_string with argument backend.,import_string ( backend )
"if ImportError, renamed to e, exception is caught,",except ImportError as e :
"raise and exception InvalidCacheBackendError with string ""Could not find backend '%s': %s"" as argument, replace '%s' with backend and e, respectively.","raise InvalidCacheBackendError ( ""Could not find backend '%s': %s"" % ( backend , e ) )"
"remove 'LOCATION' key from kwargs dictionary and put it into location, or use an empty string if key doesnt exists.","location = kwargs . pop ( 'LOCATION' , '' )"
substitute kwargs for params.,params = kwargs
"if not,",else :
"call the function conf.copy, substitute it for params.",params = conf . copy ( )
call the function params.update with argument kwargs.,params . update ( kwargs )
remove 'BACKEND' key from params dictionary and put it into backend.,backend = params . pop ( 'BACKEND' )
"remove 'LOCATION' key from kwargs dictionary and put it into location, or use an empty string if key doesnt exists.","location = params . pop ( 'LOCATION' , '' )"
"call the import_string with argument backend, substitute it for backend_cls.",backend_cls = import_string ( backend )
"if ImportError, renamed to e, is caught,",except ImportError as e :
"aise and exception InvalidCacheBackendError with string ""Could not find backend '%s': %s"" as argument, replace '%s' with backend and e, respectively.","raise InvalidCacheBackendError ( ""Could not find backend '%s': %s"" % ( backend , e ) )"
"evaluate the function backend_cls with location and params as arguments, return the result.","return backend_cls ( location , params )"
derive the class CacheHandler from the object base class.,class CacheHandler ( object ) :
define the __init__ method with argument self.,def __init__ ( self ) :
"call the function local, substitute the result for self._caches.",self . _caches = local ( )
define the __getitem__ method with self and alias arguments.,"def __getitem__ ( self , alias ) :"
"try,",try :
return value under the alias key of self._caches.caches dictionary.,return self . _caches . caches [ alias ]
"except if AttributeError is caught,",except AttributeError :
self._caches.caches is an empty dictionary.,self . _caches . caches = { }
"except if KeyError exception is caught,",except KeyError :
do nothing.,pass
"if alias is not contained in setting.CACHES,",if alias not in settings . CACHES :
"raise and exception InvalidCacheBackendError with string ""Could not find config for '%s' in settings.CACHES"" as argument, replace '%s' with alias.","raise InvalidCacheBackendError ( ""Could not find config for '%s' in settings.CACHES"" % alias )"
call the function _create_cache with argument alias.,cache = _create_cache ( alias )
substitute cache for value under the alias key of self._caches.caches dictionary.,self . _caches . caches [ alias ] = cache
reuturn cache.,return cache
define the method all with argument self.,def all ( self ) :
"get attribute 'caches' from the self._caches if exists, otherwise get an empty dictionary, call the values method on the return value, return it.","return getattr ( self . _caches , 'caches' , { } ) . values ( )"
"call the CacheHandler function, substitute the result for caches.",caches = CacheHandler ( )
derive the class DefaultCacheProxy from the base class object.,class DefaultCacheProxy ( object ) :
define the method __getattr__ with self and name as arguments.,"def __getattr__ ( self , name ) :"
"get attribute name from value under the DEFAULT_CACHE_ALIAS key of caches dictionary, return it.","return getattr ( caches [ DEFAULT_CACHE_ALIAS ] , name )"
"define the method __setattr__ with self, name and value as arguments.","def __setattr__ ( self , name , value ) :"
"set the attribute name from value under the DEFAULT_CACHE_ALIAS key of caches dictionary to value, return it.","return setattr ( caches [ DEFAULT_CACHE_ALIAS ] , name , value )"
define the method __delattr__ with self and name as arguments.,"def __delattr__ ( self , name ) :"
delete the attribute name from the cache dictionary under the DEFAULT_CACHE_ALIAS key.,"return delattr ( caches [ DEFAULT_CACHE_ALIAS ] , name )"
define the method __contains__ with self and key as arguments.,"def __contains__ ( self , key ) :"
"if key if contained in value under the DEFAULT_CACHE_ALIAS key of caches dictionary, return boolean True, otherwise return False.",return key in caches [ DEFAULT_CACHE_ALIAS ]
define the method __eq__ with self and other as arguments.,"def __eq__ ( self , other ) :"
"if value under the DEFAULT_CACHE_ALIAS key of caches dictionary equals to other, return boolean True, otherwise return False.",return caches [ DEFAULT_CACHE_ALIAS ] == other
define the method __ne__ with self and other as arguments.,"def __ne__ ( self , other ) :"
"if value under the DEFAULT_CACHE_ALIAS key of caches dictionary is not equal to other, return boolean True, otherwise return False.",return caches [ DEFAULT_CACHE_ALIAS ] != other
"call the DefaultCacheProxy function, substitute it for cache.",cache = DefaultCacheProxy ( )
define the function close_caches with dictionary pair of elements kwargs as argument.,def close_caches ( ** kwargs ) :
for every cache in return value of the function caches.all.,for cache in caches . all ( ) :
call the function cache.close.,cache . close ( )
call the function signals.request_finished.connect with argument close_caches.,signals . request_finished . connect ( close_caches )
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
import module time.,import time
import module warnings.,import warnings
from django.core.exceptions import ImproperlyConfigured and DjangoRuntimeWarning into default name space.,"from django . core . exceptions import ImproperlyConfigured , DjangoRuntimeWarning"
from django.utils.module_loading import import_string into default name space.,from django . utils . module_loading import import_string
derive class InvalidCacheBackendError from the ImproperlyConfigured base class.,class InvalidCacheBackendError ( ImproperlyConfigured ) :
do nothing.,pass
derive class CacheKeyWarning from the DjangoRuntimeWarning base class.,class CacheKeyWarning ( DjangoRuntimeWarning ) :
do nothing.,pass
DEFAULT_TIMEOUT is a instance of the class object.,DEFAULT_TIMEOUT = object ( )
MEMCACHE_MAX_KEY_LENGTH is integer 250.,MEMCACHE_MAX_KEY_LENGTH = 250
"define the function default_key_func with 3 arguments, key, key_prefix and version.","def default_key_func ( key , key_prefix , version ) :"
"convert key_prefix, version and key into strings, concatenate them respectively, with character ':' as delimiter, return the result.","return '%s:%s:%s' % ( key_prefix , version , key )"
define the function get_key_func with argument key_func.,def get_key_func ( key_func ) :
"if key_func is not of None type,",if key_func is not None :
"if key_function is callable object,",if callable ( key_func ) :
return key_func.,return key_func
"if not,",else :
"evaluate the function import_string with key_func as argument, return the result.",return import_string ( key_func )
return default_key_func.,return default_key_func
derive the class BaseCache from the object base class.,class BaseCache ( object ) :
define the initialization function __init__ with self class instance and params as arguments.,"def __init__ ( self , params ) :"
"call the params.get method with string 'TIMEOUT' and integer 300 as arguments, use the string 'timeout' and previous result as the arguments for the call to the params.get method, substitute the result for timeout.","timeout = params . get ( 'timeout' , params . get ( 'TIMEOUT' , 300 ) )"
"if timeout is not None,",if timeout is not None :
"try,",try :
convert timeout into an integer.,timeout = int ( timeout )
"if ValueError or TypeError exceptions occurred,","except ( ValueError , TypeError ) :"
timeout is integer 300.,timeout = 300
substitute timeout for self.default_timeout.,self . default_timeout = timeout
"call the params.get with string 'OPTIONS' and empty dictionary as arguments, substitute the result for options.","options = params . get ( 'OPTIONS' , { } )"
"call the options.get method with string 'MAX_ENTRIES' and integer 300 as arguments, use the string 'max_entries' and previous result as the arguments for the call to the params.get method, substitute the result for max_entries.","max_entries = params . get ( 'max_entries' , options . get ( 'MAX_ENTRIES' , 300 ) )"
"try,",try :
"convert max_entries into a string, substitute it for self._max_entries.",self . _max_entries = int ( max_entries )
"if ValueError or TypeError exceptions occurred,","except ( ValueError , TypeError ) :"
self._max_entries is integer 300.,self . _max_entries = 300
"call the options.get method with string 'CULL_FREQUENCY' and integer 3 as arguments, use the string 'cull_frequency' and previous result as the arguments for the call to the params.get method, substitute the result for cull_frequency.","cull_frequency = params . get ( 'cull_frequency' , options . get ( 'CULL_FREQUENCY' , 3 ) )"
"try,",try :
convert cull_frequency into an integer and substitute it for self._cull_frequency.,self . _cull_frequency = int ( cull_frequency )
"if ValueError or TypeError exceptions occurred,","except ( ValueError , TypeError ) :"
self._cull_frequency is integer 3.,self . _cull_frequency = 3
"call the params.get method with string 'KEY_PREFIX' and an empty string as arguments, substitute the result for self._key_prefix.","self . key_prefix = params . get ( 'KEY_PREFIX' , '' )"
"call the params.get method wit string 'VERSION' and integer 1 as arguments, substitute the result for self.version.","self . version = params . get ( 'VERSION' , 1 )"
"call the method params.get with 2 arguments, string 'KEY_FUNCTION' and None, use the result as the argument for the call to the function get_key_func, substitute the result for the self.key_func.","self . key_func = get_key_func ( params . get ( 'KEY_FUNCTION' , None ) )"
"define the method get_backend_timeout with self class instance and timeout set to DEFAULT_TIMEOUT as arguments,","def get_backend_timeout ( self , timeout = DEFAULT_TIMEOUT ) :"
"if timeout equals to DEFAULT_TIMEOUT,",if timeout == DEFAULT_TIMEOUT :
substitute self.default_timeout for timeout.,timeout = self . default_timeout
"else if timeout equals to integer 0,",elif timeout == 0 :
timeout is a integer -1.,timeout = - 1
"if timeouts is None return None, otherwise return the sum of function time.time return value and timeout.",return None if timeout is None else time . time ( ) + timeout
"define the function make_key with self class instance, key and version set to None as arguments.","def make_key ( self , key , version = None ) :"
"if version is None,",if version is None :
substitute self.version for version.,version = self . version
"call the method self.key_function with key, self.key_prefix and version as arguments, substitute the result for new_key.","new_key = self . key_func ( key , self . key_prefix , version )"
return new_key.,return new_key
"define the method add with 5 arguments, self, key, value, timeout defaulting to DEFAULT_TIMEOUT and version defaulting to None.","def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :"
docsring,""""""" Set a value in the cache if the key does not already exist. If timeout is given, that timeout will be used for the key; otherwise the default cache timeout will be used. Returns True if the value was stored, False otherwise. """""""
raise an exception of class NotImplementedError with string 'subclasses of BaseCache must provide an add() method' as argument.,raise NotImplementedError ( 'subclasses of BaseCache must provide an add() method' )
"define the method get with 4 arguments, self, key, default set to None and version set to None.","def get ( self , key , default = None , version = None ) :"
"raise an exception of class NotImplementedError, with string 'subclasses of BaseCache must provide a get() method' as argument.",raise NotImplementedError ( 'subclasses of BaseCache must provide a get() method' )
"define the method set with 5 arguments, self, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.","def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :"
"raise an exception of class NotImplementedError, with string 'subclasses of BaseCache must provide a set() method' as argument.",raise NotImplementedError ( 'subclasses of BaseCache must provide a set() method' )
"define delete method with self class instance, key and version set to None, as arguments.","def delete ( self , key , version = None ) :"
"raise an exception of class NotImplementedError, with string 'subclasses of BaseCache must provide a delete() method' as argument.",raise NotImplementedError ( 'subclasses of BaseCache must provide a delete() method' )
"define the get_many method with self class instance, keys and version set to None as arguments.","def get_many ( self , keys , version = None ) :"
d is an empty dictionary.,d = { }
"for every k in keys,",for k in keys :
"call the self.get method with k and version set to version as arguments, substitute the result for val.","val = self . get ( k , version = version )"
"if val is not None,",if val is not None :
substitute val for value under the k key of dictionary d.,d [ k ] = val
return d.,return d
"define method has_key with self class instance, key and version set to None as arguments.","def has_key ( self , key , version = None ) :"
"call the self.get method with key and version set to version as arguments, return it if it is not None.","return self . get ( key , version = version ) is not None"
"define the method incr with 4 arguments, self class instance, key, delta defaulting to integer 1 and version defaulting to None.","def incr ( self , key , delta = 1 , version = None ) :"
"call the method self.get with key and version set to version as arguments, substitute the result for value.","value = self . get ( key , version = version )"
"if value is None,",if value is None :
"raise an exception of class ValueError, with string ""Key '%s' not found"" as argument, where '%s' is substituted for key.","raise ValueError ( ""Key '%s' not found"" % key )"
"add value and delta together, substitute the result for new_value.",new_value = value + delta
"call the self.set method with key, new_value and version set to version as arguments.","self . set ( key , new_value , version = version )"
return new_value.,return new_value
"define the method decr with arguments self, key, delta defaulting to integer 1 and version defaulting to None.","def decr ( self , key , delta = 1 , version = None ) :"
"call the self.incr method with key, negative delta and version set to version as arguments.","return self . incr ( key , - delta , version = version )"
define the private method __contains__ with self class instance and key as arguments.,"def __contains__ ( self , key ) :"
"evaluate the self.has_key method with key as argument, return the result.",return self . has_key ( key )
"define the method set_many with arguments, self, data, timeout defaulting to DEFAULT_TIMEOUT and version set to None.","def set_many ( self , data , timeout = DEFAULT_TIMEOUT , version = None ) :"
"for every key and value in data.items method return value,","for key , value in data . items ( ) :"
"call the method self.set with arguments key, value, timeout set to timeout, version set to version.","self . set ( key , value , timeout = timeout , version = version )"
"define the method delete_many with arguments self, keys and version defaulting to None.","def delete_many ( self , keys , version = None ) :"
"for every key in keys,",for key in keys :
call the delete method with key and version set to version as arguments.,"self . delete ( key , version = version )"
"define the method clear with self class instance as the argument,",def clear ( self ) :
raise an exception NotImplementedError with string 'subclasses of BaseCache must provide a clear() method' as argument.,raise NotImplementedError ( 'subclasses of BaseCache must provide a clear() method' )
define the method validate_key with self class instance and key as arguments.,"def validate_key ( self , key ) :"
"if length of key is greater than MEMCACHE_MAX_KEY_LENGTH,",if len ( key ) > MEMCACHE_MAX_KEY_LENGTH :
"substitute '%s' in string 'Cache key will cause errors if used with memcached: %s (longer than %s)' with key,","warnings . warn ( 'Cache key will cause errors if used with memcached: ' '%s (longer than %s)' % ( key , MEMCACHE_MAX_KEY_LENGTH ) , CacheKeyWarning )"
"and MEMCACHE_MAX_KEY_LENGTH, call the function warnings.warn with previous string and CacheKeyWarning as arguments. for every char in key,",for char in key :
"if ascii value of char is smaller than integer 33 or is equal to integer 127,",if ord ( char ) < 33 or ord ( char ) == 127 :
"substitute '%r' in string 'Cache key contains characters that will cause errors if used with memcached: %r' with key,","warnings . warn ( 'Cache key contains characters that will cause ' 'errors if used with memcached: %r' % key , CacheKeyWarning )"
"call the function warnings.warn with previous string and CacheKeyWarning as arguments. define the method incr_version with 4 arguments, self, key, delta defaulting to integer 1 and version defaulting to None.","def incr_version ( self , key , delta = 1 , version = None ) :"
"if version is None,",if version is None :
substitute self.version for version.,version = self . version
"call the self.get method with arguments key and version set to version, substitute the result for value.","value = self . get ( key , version = version )"
"if value is None,",if value is None :
"raise an exception of the class ValueError with string ""Key '%s' not found"" as argument, '%s' is substituted for key.","raise ValueError ( ""Key '%s' not found"" % key )"
"call the method self.set with key, value, version incremented by delta, as arguments.","self . set ( key , value , version = version + delta )"
call the self.delete method with key and version set to version as arguments.,"self . delete ( key , version = version )"
"sum version and delta together, return the result.",return version + delta
"define the method decr_version with 4 arguments, self, key, delta defaulting to integer 1 and version defaulting to None.","def decr_version ( self , key , delta = 1 , version = None ) :"
"call the method self.incr_version with key, negative delta and version as arguments.","return self . incr_version ( key , - delta , version )"
"define the close method with 2 arguments, self and dictionary of argument pairs kwargs.","def close ( self , ** kwargs ) :"
docstirng,"""""""Close the cache connection"""""""
do nothing.,pass
import module base64.,import base64
from datetime import datetime into default name space.,from datetime import datetime
"try,",try :
"from django.utils.six.moves import cPickle as pickle, into default namespace.",from django . utils . six . moves import cPickle as pickle
"if ImportError exception occurred,",except ImportError :
import pickle.,import pickle
from django.conf import settings into default name space.,from django . conf import settings
from django.core.cache.backends.base import BaseCache and DEFAULT_TIMEOUT into default name space.,"from django . core . cache . backends . base import BaseCache , DEFAULT_TIMEOUT"
"from django.db import connections, transaction, router and DatabaseError into default name space.","from django . db import connections , transaction , router , DatabaseError"
from django.db.backends.utils import typecast_timestamp into default name space.,from django . db . backends . utils import typecast_timestamp
from django.utils import timezone and six into default name space.,"from django . utils import timezone , six"
from django.utils.encoding import force_bytes into default name space.,from django . utils . encoding import force_bytes
derive class Options from the base class object.,class Options ( object ) :
define the initialization method __init__ with self class instance and table as arguments.,"def __init__ ( self , table ) :"
substitute table for self.db_table.,self . db_table = table
self.app_label is a string 'django_cache'.,self . app_label = 'django_cache'
self.model_name is a string 'cacheentry'.,self . model_name = 'cacheentry'
self.verbose_name is a string 'cache entry'.,self . verbose_name = 'cache entry'
self.verbose_name_plural is a string 'cache entries'.,self . verbose_name_plural = 'cache entries'
self.object_name is a string 'CacheEntry'.,self . object_name = 'CacheEntry'
self.abstract is boolean False.,self . abstract = False
self.managed is boolean True.,self . managed = True
self.proxy is boolean False.,self . proxy = False
derive class BaseDatabaseCache from BaseCache base class.,class BaseDatabaseCache ( BaseCache ) :
"define the initialization method __init__ with self, table and params as arguments.","def __init__ ( self , table , params ) :"
call the BaseCache.__init__ method with self class instance and params as the arguments.,"BaseCache . __init__ ( self , params )"
substitute table for self._table.,self . _table = table
derive CacheEntry class from the object base class.,class CacheEntry ( object ) :
_meta is class Options class instance initialized with table argument.,_meta = Options ( table )
substitute CacheEntry for self.cache_model_class.,self . cache_model_class = CacheEntry
derive DatabaseCache from the BaseDatabaseCache base class.,class DatabaseCache ( BaseDatabaseCache ) :
"define the method get with 4 arguments, self class instance, key, default set to None and version set to None.","def get ( self , key , default = None , version = None ) :"
"call the method self.make_key Whit key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
"call the method router.db_for_read with self.cache_model_class as argument, substitute the result for db.",db = router . db_for_read ( self . cache_model_class )
"call the ops.quote_name method with argument self._table on the value under the db key of connections dictionary, substitute the result for table.",table = connections [ db ] . ops . quote_name ( self . _table )
"call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,",with connections [ db ] . cursor ( ) as cursor :
"call the method cursor.execute with string ""SELECT cache_key, value, expires FROM %s WHERE cache_key = %%s"" as argument,","cursor . execute ( ""SELECT cache_key, value, expires FROM %s "" ""WHERE cache_key = %%s"" % table , [ key ] )"
"substitute the '%s' with table and list containing key, respectively. call the cursor.fetchone method, substitute the result for row.",row = cursor . fetchone ( )
"if row is None,",if row is None :
return default.,return default
"call the timezone.now function, substitute the result for now.",now = timezone . now ( )
substitute third element of row list for expires.,expires = row [ 2 ]
"if features.needs_datetime_string_cast field of the object represented stored under the db key of connections dictionary is true,","if connections [ db ] . features . needs_datetime_string_cast and not isinstance ( expires , datetime ) :"
"and expires is not an instance of datetime. convert expires to a string, use it as argument for the call to the function typecast_timestamp, substitute the result for expires.",expires = typecast_timestamp ( str ( expires ) )
"if expires is lesser than now,",if expires < now :
"call the method router.db_for_write with argument self.cache_model_class, substitute the result for db.",db = router . db_for_write ( self . cache_model_class )
"call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,",with connections [ db ] . cursor ( ) as cursor :
"call the method cursor.execute with string ""DELETE FROM %s WHERE cache_key = %%s"" as argument,","cursor . execute ( ""DELETE FROM %s "" ""WHERE cache_key = %%s"" % table , [ key ] )"
"substitute the '%s' with table and list containing key, respectively. return default.",return default
"call the method ops.process_clob with second element of row as argument, on the object under the db key of connections dictionary, substitute the result for value.",value = connections [ db ] . ops . process_clob ( row [ 1 ] )
"call the function force_bytes with argument value, use the result as an argument for the call to the method base64.b64decode,",return pickle . loads ( base64 . b64decode ( force_bytes ( value ) ) )
"use the result as the argument for the function call to the pickle.loads, return the result. define the method set with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.","def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with key as argument.,self . validate_key ( key )
"call the method self._base_set with string 'set', key, value and timeout as arguments.","self . _base_set ( 'set' , key , value , timeout )"
"define the method add with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.","def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with key as argument.,self . validate_key ( key )
"call the method self._base_set with string 'add', key, value and timeout as arguments, return the result.","return self . _base_set ( 'add' , key , value , timeout )"
"define the protected method _base_set with 4 arguments, self class instance, key, value and timeout set to DEFAULT_TIMEOUT.","def _base_set ( self , mode , key , value , timeout = DEFAULT_TIMEOUT ) :"
"call the method self.get_backend_timeout with argument timeout, substitute the result for timeout.",timeout = self . get_backend_timeout ( timeout )
"call the method router.db_for_write with argument self.cache_model_class, substitute the result for db.",db = router . db_for_write ( self . cache_model_class )
"call the ops.quote_name method with argument self._table on the object under the db key of connections dictionary, substitute the result for table.",table = connections [ db ] . ops . quote_name ( self . _table )
"call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,",with connections [ db ] . cursor ( ) as cursor :
"call the method cursor.execute with string ""SELECT COUNT(*) FROM %s"" as argument, substitute the '%s' with table.","cursor . execute ( ""SELECT COUNT(*) FROM %s"" % table )"
"fetch one record from the database cursor points at, substitute the first element of return value for num.",num = cursor . fetchone ( ) [ 0 ]
"call the timezone.now function, substitute the result for now.",now = timezone . now ( )
"call the function now.replace with microseconds set to integer 0, substitute the result for now.",now = now . replace ( microsecond = 0 )
"if timeout is None,",if timeout is None :
substitute the datetime.max for exp.,exp = datetime . max
"otherwise is settings.USE_TI is true,",elif settings . USE_TZ :
"call the function datetime.utcfromtimestamp with argument timeout, substitute it for exp.",exp = datetime . utcfromtimestamp ( timeout )
"if not,",else :
"call the function datetime.fromtimestamp with argument timeout, substitute it for exp.",exp = datetime . fromtimestamp ( timeout )
"call the exp.replace with microsecond set to integer 0, substitute the result for exp.",exp = exp . replace ( microsecond = 0 )
"if num is greater than self._max_entries,",if num > self . _max_entries :
"call the method self._cull with db, cursor and now as arguments.","self . _cull ( db , cursor , now )"
"call the method pickle.dumps with value and pickle.HIGHEST_PROTOCOL as arguments, substitute it for pickled.","pickled = pickle . dumps ( value , pickle . HIGHEST_PROTOCOL )"
"call the method base64.b64encode with argument pickled, substitute the result for b64encoded.",b64encoded = base64 . b64encode ( pickled )
"if six.PY3 is true,",if six . PY3 :
"call the method b64encoded.decode with string 'latin1' as argument, substitute the result for b64encoded.",b64encoded = b64encoded . decode ( 'latin1' )
"try,",try :
"with return value of the function transaction.atomic with using set to db as arguments, perform the following,",with transaction . atomic ( using = db ) :
"call the method cursor.execute with string ""SELECT cache_key, expires FROM %s WHERE cache_key = %%s"" as argument,","cursor . execute ( ""SELECT cache_key, expires FROM %s "" ""WHERE cache_key = %%s"" % table , [ key ] )"
"substitute the '%s' with table and list containing key, respectively. fetch one entry from the database that cursor points at, substitute it for the result.",result = cursor . fetchone ( )
"if result is true,",if result :
substitute the second element of result for current_expires.,current_expires = result [ 1 ]
if features.needs_datetime_string_cast field of object under the db key of connections dictionary is true and current_expires is not an instance of datetime object.,"if ( connections [ db ] . features . needs_datetime_string_cast and not isinstance ( current_expires , datetime ) ) :"
"convert current_expires to a string, use it as the argument for the call to the function typecast_timestamp, substitute the result for current_expires.",current_expires = typecast_timestamp ( str ( current_expires ) )
"on the object under the db key of connections dictionary call the method ops.value_to_db_datetime with argument exp, substitute the result for the exp.",exp = connections [ db ] . ops . value_to_db_datetime ( exp )
"if mode equals to string 'add' and current_expires is lesser than now, or mode equals to string 'set', and result is true,",if result and ( mode == 'set' or ( mode == 'add' and current_expires < now ) ) :
"call the method cursor.execute with string ""UPDATE %s SET value = %%s, expires = %%s WHERE cache_key = %%s"" as argument,","cursor . execute ( ""UPDATE %s SET value = %%s, expires = %%s "" ""WHERE cache_key = %%s"" % table , [ b64encoded , exp , key ] )"
"substitute the '%s' with table and 3 elements of a list: b64encoded, exp and key, respectively. if not,",else :
"call the method cursor.execute with string ""INSERT INTO %s (cache_key, value, expires) VALUES (%%s, %%s, %%s)"",","cursor . execute ( ""INSERT INTO %s (cache_key, value, expires) "" ""VALUES (%%s, %%s, %%s)"" % table , [ key , b64encoded , exp ] )"
"substitute the '%s' with table and 3 elements of a list: b64encoded, exp and key, respectively. if DatabaseError exception is caught,",except DatabaseError :
return boolean False.,return False
"if not,",else :
return boolean True.,return True
"define the method delete with self class instance, key and version set to None as arguments.","def delete ( self , key , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
"call the method router.db_for_write with argument self.cache_model_class, substitute the result for db.",db = router . db_for_write ( self . cache_model_class )
"call the ops.quote_name method with argument self._table on the object under the db key of connections dictionary, substitute the result for table.",table = connections [ db ] . ops . quote_name ( self . _table )
"call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,",with connections [ db ] . cursor ( ) as cursor :
"call the method cursor.execute with string ""DELETE FROM %s WHERE cache_key = %%s"" as argument,","cursor . execute ( ""DELETE FROM %s WHERE cache_key = %%s"" % table , [ key ] )"
"substitute the '%s' with table and list containing key, respectively. define the method has_key with self class instance, key and version defaulting to None as arguments.","def has_key ( self , key , version = None ) :"
"call the self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
call the self.validate_key method with argument key.,self . validate_key ( key )
"call the method router.db_for_write with argument self.cache_model_class, substitute the result for db.",db = router . db_for_read ( self . cache_model_class )
"call the ops.quote_name method with argument self._table on the object under the db key of connections dictionary, substitute the result for table.",table = connections [ db ] . ops . quote_name ( self . _table )
"if settings.USE_TZ is true,",if settings . USE_TZ :
"call the function datetime.utcnow, substitute the result for now.",now = datetime . utcnow ( )
"if not,",else :
"call the function datetime.now, substitute the result to now.",now = datetime . now ( )
"call the method now.replace with the argument microsecond set to integer 0, substitute the result for now.",now = now . replace ( microsecond = 0 )
"call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,",with connections [ db ] . cursor ( ) as cursor :
"call the method cursor.execute with string ""SELECT cache_key FROM %s WHERE cache_key = %%s and expires > %%s"" as argument,","cursor . execute ( ""SELECT cache_key FROM %s "" ""WHERE cache_key = %%s and expires > %%s"" % table , [ key , connections [ db ] . ops . value_to_db_datetime ( now ) ] )"
"substitute the '%s' with table and list containing return value of the method call ops.value_to_db_datetime with argument now on the object under the db key of connections dictionary, respectively. if exists return next entry from the database that cursor points at.",return cursor . fetchone ( ) is not None
"define the protected method _cull with self class instance, db, cursor and now as arguments.","def _cull ( self , db , cursor , now ) :"
if self._cull_frequency equals to integer 0.,if self . _cull_frequency == 0 :
call the self.clear method.,self . clear ( )
"if not,",else :
"call the method now.replace with argument tzinfo set to None, substitute it for now.",now = now . replace ( tzinfo = None )
"call the ops.quote_name method with argument self._table on the object under the db key of connections dictionary, substitute the result for table.",table = connections [ db ] . ops . quote_name ( self . _table )
"call the method cursor.execute with string ""DELETE FROM %s WHERE expires < %%s"" as argument,","cursor . execute ( ""DELETE FROM %s WHERE expires < %%s"" % table , [ connections [ db ] . ops . value_to_db_datetime ( now ) ] )"
"substitute the '%s' with table and list containing return value of the method call ops.value_to_db_datetime with argument now on the object under the db key of connections dictionary, respectively. call the method cursor.execute with string ""SELECT COUNT(*) FROM %s"" as argument, substitute the '%s' with table.","cursor . execute ( ""SELECT COUNT(*) FROM %s"" % table )"
"fetch next entry for the database that cursor points into, substitute first element of it for num.",num = cursor . fetchone ( ) [ 0 ]
"if num is greater than self._max_entries,",if num > self . _max_entries :
"divide num by self._cull_frequency, floor the result and substitute it for cull_num.",cull_num = num // self . _cull_frequency
"evaluate the method connections[db].ops.cache_key_culling_sql, evaluate the result by table modulus, call the method cursor.execute,","cursor . execute ( connections [ db ] . ops . cache_key_culling_sql ( ) % table , [ cull_num ] )"
"with previous result and list containing cull_num, respectively as arguments. call the method cursor.execute with string ""DELETE FROM %s WHERE cache_key < %%s"" as argument,","cursor . execute ( ""DELETE FROM %s "" ""WHERE cache_key < %%s"" % table , [ cursor . fetchone ( ) [ 0 ] ] )"
"substitute the '%s' with table and list containing first element of cursor.fetchone method, respectively. define the method clear with argument self.",def clear ( self ) :
"call the method router.db_for_write with argument self.cache_model_class, substitute the result for db.",db = router . db_for_write ( self . cache_model_class )
"call the ops.quote_name method with argument self._table on the object under the db key of connections dictionary, substitute the result for table.",table = connections [ db ] . ops . quote_name ( self . _table )
"call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,",with connections [ db ] . cursor ( ) as cursor :
"call the method cursor.execute with string ""DELETE FROM %s"" as argument, substitute the '%s' with table.",cursor . execute ( 'DELETE FROM %s' % table )
derive the class CacheClass from the DatabaseCache base class.,class CacheClass ( DatabaseCache ) :
do nothing.,pass
from django.core.cache.backends.base import BaseCache and DEFAULT_TIMEOUT into default name space.,"from django . core . cache . backends . base import BaseCache , DEFAULT_TIMEOUT"
derive the class DummyCache from the base class BaseCache.,class DummyCache ( BaseCache ) :
"define initialization method __init__ with 4 arguments: self, host, list of arguments args and dictionary of arguments kwargs.","def __init__ ( self , host , * args , ** kwargs ) :"
"call the BaseCache initialization method __init__ with 3 arguments self, list of arguments args and dictionary of arguments kwargs.","BaseCache . __init__ ( self , * args , ** kwargs )"
"define the method add with 5 arguments: self, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.","def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute it for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
return boolean True.,return True
"define the method get with 4 arguments: self, key, default set to None and version set to None.","def get ( self , key , default = None , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute it for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
return default.,return default
"define the method set with 5 arguments: self, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.","def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute it for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
"define the method delete with 3 arguments: self, key, and version set to None.","def delete ( self , key , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute it for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
"define the method get_many with 3 arguments: self, keys, and version set to None.","def get_many ( self , keys , version = None ) :"
return an empty dictionary.,return { }
"define the method has_key with 3 arguments: self, key, and version set to None.","def has_key ( self , key , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute it for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
return boolean False.,return False
"define the method set_many with 4 arguments: self, data, timeout set to DEFAULT_TIMEOUT and version set to None.","def set_many ( self , data , timeout = DEFAULT_TIMEOUT , version = None ) :"
do nothing,pass
"define the method delete_many with 3 arguments: self, keys, and version set to None.","def delete_many ( self , keys , version = None ) :"
do nothing.,pass
define the method clear with argument self.,def clear ( self ) :
do nothing.,pass
derive the class CacheClass from the DummyCache base class.,class CacheClass ( DummyCache ) :
do nothing.,pass
import module errno.,import errno
import module glob.,import glob
import module hashlib.,import hashlib
import module io.,import io
import module os.,import os
import module random.,import random
import module tempfile.,import tempfile
import module time.,import time
import module zlib.,import zlib
from django.core.cache.backends.base import BaseCache and DEFAULT_TIMEOUT into default name space.,"from django . core . cache . backends . base import BaseCache , DEFAULT_TIMEOUT"
from django.core.files.move import file_move_safe into default name space.,from django . core . files . move import file_move_safe
from django.utils.encoding import force_bytes into default name space.,from django . utils . encoding import force_bytes
"try,",try :
from django.utils.six.moves import cPickle as pickle into default name space.,from django . utils . six . moves import cPickle as pickle
"if ImportError exception is caught,",except ImportError :
import pickle.,import pickle
derive the class FileBasedCache from BaseCache base class.,class FileBasedCache ( BaseCache ) :
cache_suffix is a string '.djcache'.,cache_suffix = '.djcache'
"define the initialization method __init__ with arguments: self class instance, dir and params.","def __init__ ( self , dir , params ) :"
call method __init__ with argument params from the base class of the FileBaseCache.,"super ( FileBasedCache , self ) . __init__ ( params )"
"get absolute directory path of dir, substitute it for self._dir.",self . _dir = os . path . abspath ( dir )
call the self._createdir method.,self . _createdir ( )
"define the method add with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.","def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :"
"evaluate method self.has_key with key and version as arguments, if the result is true,","if self . has_key ( key , version ) :"
return boolean False.,return False
"call the method self.set with key, value, timeout and version as arguments.","self . set ( key , value , timeout , version )"
return boolean True.,return True
"define the method get with 5 arguments, self class instance, key, default set to None and version set to None.","def get ( self , key , default = None , version = None ) :"
"call the function self._key_to_file with key and version as arguments, substitute it for fname.","fname = self . _key_to_file ( key , version )"
"if fname file path exists,",if os . path . exists ( fname ) :
"try,",try :
"with return value of the function io.open with fname and string 'rb' as arguments, named as f,","with io . open ( fname , 'rb' ) as f :"
"evaluate self._is_expired method with f as argument, if the result is false,",if not self . _is_expired ( f ) :
"call f.read function, use the result as the argument for zlib.decompress function call, call the pickle.loads function with the previous result as argument, return the result.",return pickle . loads ( zlib . decompress ( f . read ( ) ) )
"if IOError, renamed to e, exception is caught,",except IOError as e :
"if e.errno equals to errno.ENOENT,",if e . errno == errno . ENOENT :
do nothing.,pass
return default.,return default
"define the method set with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.","def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :"
call the self._createdir method.,self . _createdir ( )
"call the function self._key_to_file with key and version as arguments, substitute it for fname.","fname = self . _key_to_file ( key , version )"
call the method self._cull.,self . _cull ( )
"call the method tempfile.mkstemp with dir set to self._dir, substitute result for fd and tmp_path, respectively.","fd , tmp_path = tempfile . mkstemp ( dir = self . _dir )"
renamed is boolean False.,renamed = False
"try,",try :
"with return value of the function io.open with fname and string 'rb' as arguments, named as f,","with io . open ( fd , 'wb' ) as f :"
"call the method self.get_backend_timeout with argument timeout, substitute it for expiry.",expiry = self . get_backend_timeout ( timeout )
"call the function pickle.dumps with expiry and integer -1 as arguments, use the result as the argument for the call to f.write function.","f . write ( pickle . dumps ( expiry , - 1 ) )"
"call the function pickle.dumps with argument value, use the result and integer -1 as arguments for the call to the function zlib.compress, use the result as an argument for the call to the f.write method.","f . write ( zlib . compress ( pickle . dumps ( value ) , - 1 ) )"
"call the function file_move_safe with tmp_path, fname, allow_overwrite set to boolean True as arguments.","file_move_safe ( tmp_path , fname , allow_overwrite = True )"
renamed is boolean True.,renamed = True
"finally perform,",finally :
"if renamed is boolean False,",if not renamed :
remove file tmp_path.,os . remove ( tmp_path )
"define the method delete with self class instance, key and version defaulting to None as arguments.","def delete ( self , key , version = None ) :"
"call the function self._key_to_file with key and version as arguments, use the result as an argument for the call to the self._delete method.","self . _delete ( self . _key_to_file ( key , version ) )"
define the method _delete with self and fname as arguments.,"def _delete ( self , fname ) :"
"if fname doesnt start with self._dir and fname file path doesnt exists,",if not fname . startswith ( self . _dir ) or not os . path . exists ( fname ) :
return nothing.,return
"try,",try :
call the function os.remove with argument fname.,os . remove ( fname )
"if exception OSError, renamed to e, is caught,",except OSError as e :
"if e.errno does not equals to errno.ENOENT,",if e . errno != errno . ENOENT :
raise an exception.,raise
"define the method has_key with self class instance, key and version defaulting to None as arguments.","def has_key ( self , key , version = None ) :"
"call the function self._key_to_file with key and version as arguments, substitute it for fname.","fname = self . _key_to_file ( key , version )"
"if fname file path exists,",if os . path . exists ( fname ) :
"with call to the io.open function with fname and string 'rb' as arguments, renamed to f,","with io . open ( fname , 'rb' ) as f :"
"call the method self._is_expired with argument f, invert the boolean result and return it.",return not self . _is_expired ( f )
return boolean False.,return False
define the method _cull with argument self.,def _cull ( self ) :
"call the self._list_cache_files method, substitute the result for filelist.",filelist = self . _list_cache_files ( )
num_entries is length of filelist.,num_entries = len ( filelist )
"if num_entries is lesser than self._max_entries,",if num_entries < self . _max_entries :
return nothing.,return
if self._cull_frequency equals to integer 0.,if self . _cull_frequency == 0 :
evaluate self.clear method and return the result.,return self . clear ( )
"divide num_entries by self._cull_frequency, convert the result to an integer, call the random.sample function with filelist and previous result as arguments, substitute the result for filelist.","filelist = random . sample ( filelist , int ( num_entries / self . _cull_frequency ) )"
"for every fname in filelist,",for fname in filelist :
call self._delete method with argument fname.,self . _delete ( fname )
define the method _createdir with argument self.,def _createdir ( self ) :
"if self._dir path doesnt exists,",if not os . path . exists ( self . _dir ) :
"try,",try :
call os.makedirs function with self._dir and hexadecimal 0o700 as arguments.,"os . makedirs ( self . _dir , 0o700 )"
"if OSError, renamed to e, exception is caught,",except OSError as e :
"if e.errno is not equal to errno.EEXIST,",if e . errno != errno . EEXIST :
"raise an EnvironmentError exception with string ""Cache directory '%s' does not exist and could not be created"" as argument,","raise EnvironmentError ( ""Cache directory '%s' does not exist "" ""and could not be created'"" % self . _dir )"
"substitute '%s' with self._dir converted to a string. define the method key_to_file with self class instance, key and version defaulting to None as arguments.","def _key_to_file ( self , key , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
"join into a string: md5 hash sum of force_bytes(key) and self.cache_suffix, compose root file path out of self._dir and previous result, return it.","return os . path . join ( self . _dir , '' . join ( [ hashlib . md5 ( force_bytes ( key ) ) . hexdigest ( ) , self . cache_suffix ] ) )"
define the method clear with argument self.,def clear ( self ) :
"if self._dir file path does not exists,",if not os . path . exists ( self . _dir ) :
return nothing.,return
"if fname is contained in self._list_cache_files method return value,",for fname in self . _list_cache_files ( ) :
call the self._delete method with argument fname.,self . _delete ( fname )
define the method _is_expired with self and f as arguments.,"def _is_expired ( self , f ) :"
"call the function pickle.load with argument f, substitute the result for exp.",exp = pickle . load ( f )
"if exp is not None and exp is lesser than return value of the function time.time,",if exp is not None and exp < time . time ( ) :
call close method on a file stream.,f . close ( )
call the self._delete method with argument f.name.,self . _delete ( f . name )
return boolean True.,return True
return boolean False.,return False
define the method _list_cache_files with argument self.,def _list_cache_files ( self ) :
"if self._dir file path does not exists,",if not os . path . exists ( self . _dir ) :
return an empty list.,return [ ]
"for every fname in return value of the glob.glob1 function called with 2 arguments: self._dir and ,","filelist = [ os . path . join ( self . _dir , fname ) for fname in glob . glob1 ( self . _dir , '*%s' % self . cache_suffix ) ]"
"self.cache_suffix converted to a string, appended to the character '*', call os.path.join with self._dir and fname as arguments, filelist is a list containing all the previous results. return filelist.",return filelist
derive the class CacheClass from the base class FileBasedCache.,class CacheClass ( FileBasedCache ) :
do nothing.,pass
import module time.,import time
"try,",try :
from django.utils.six.moves import cPickle as pickle into default name space.,from django . utils . six . moves import cPickle as pickle
"if ImportError exception is caught,",except ImportError :
import pickle.,import pickle
from django.core.cache.backends.base import BaseCache and DEFAULT_TIMEOUT into default name space.,"from django . core . cache . backends . base import BaseCache , DEFAULT_TIMEOUT"
from django.utils.synch import RWLock into default name space.,from django . utils . synch import RWLock
__caches is an empty dictionary.,_caches = { }
__expire_info is an empty dictionary.,_expire_info = { }
__locks is an empty dictionary.,_locks = { }
derive the class LocMemCache from the base class BaseCache.,class LocMemCache ( BaseCache ) :
"define the initialization method __init__ with 3 arguments: self, name and params.","def __init__ ( self , name , params ) :"
call the __init__ method with self and params arguments from the base class BaseCache.,"BaseCache . __init__ ( self , params )"
"call the _caches.setdefault method with name and empty dictionary as arguments, substitute the result for self_cache.","self . _cache = _caches . setdefault ( name , { } )"
"call the _expire_info.setdefault method with name and empty dictionary as arguments, substitute the result for self_expire_info.","self . _expire_info = _expire_info . setdefault ( name , { } )"
"call the _lock.setdefault method with name and RWLock() as arguments, substitute the result for self_lock.","self . _lock = _locks . setdefault ( name , RWLock ( ) )"
"define the method add with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.","def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
call the pickle.dumps function with value and pickle.HIGHEST_PROTOCOL as arguments.,"pickled = pickle . dumps ( value , pickle . HIGHEST_PROTOCOL )"
"call the self._lock.writer method, with the result perform the following,",with self . _lock . writer ( ) :
"evaluate self._has_expired with argument key, if the result is True,",if self . _has_expired ( key ) :
"call the method self._set with key, pickled and timeout as arguments.","self . _set ( key , pickled , timeout )"
return boolean True.,return True
return boolean False.,return False
"define the method get with 4 arguments, self class instance, key, default set to None and version set to None.","def get ( self , key , default = None , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
substitute None for pickled.,pickled = None
"call the self._lock.reader method, with the result perform the following,",with self . _lock . reader ( ) :
"evaluate the method self._has_expired with argument key, if it as False,",if not self . _has_expired ( key ) :
substitute value under the key key of self._cache dictionary for pickled.,pickled = self . _cache [ key ]
if pickled is not None.,if pickled is not None :
"try,",try :
"evaluate pickle.loads with argument pickled, return the result.",return pickle . loads ( pickled )
"if pickle.PickleError exception is caught,",except pickle . PickleError :
return default.,return default
"call the self._lock.writer method, with the result perform the following,",with self . _lock . writer ( ) :
"try,",try :
delete the value under key key of self._cache dictionary.,del self . _cache [ key ]
delete the value under key key of self._expire_info.,del self . _expire_info [ key ]
"if KeyError exception is caught,",except KeyError :
do nothing.,pass
return default.,return default
"define the method _set with 4 arguments, self class instance, key, value and timeout set to DEFAULT_TIMEOUT.","def _set ( self , key , value , timeout = DEFAULT_TIMEOUT ) :"
"if length of self._cache is greater or equal to self._max_entries,",if len ( self . _cache ) >= self . _max_entries :
call the self._cull method.,self . _cull ( )
substitute value for the value under the key key of self._cache dictionary.,self . _cache [ key ] = value
"call the self.get_backend_timeout with argument timeout, substitute it for the value under the key key of self._expire_info dictionary.",self . _expire_info [ key ] = self . get_backend_timeout ( timeout )
"define the method get with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.","def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
"call the function pickle.dumps with value and pickle.HIGHEST_PROTOCOL as the arguments, substitute the result for pickled.","pickled = pickle . dumps ( value , pickle . HIGHEST_PROTOCOL )"
"call the self._lock.writer method, with the result perform the following,",with self . _lock . writer ( ) :
"call the method self._set with key, pickled and timeout as arguments.","self . _set ( key , pickled , timeout )"
"define the method incr with self class instance, key, delta set to integer 1 and version set to None, as arguments.","def incr ( self , key , delta = 1 , version = None ) :"
"call the self.get method with key and version set to version as arguments, substitute the result for value.","value = self . get ( key , version = version )"
"if value is None,",if value is None :
"raise an ValueError exception with string ""Key '%s' not found"" as argument, substitute '%s' with key converted into a string.","raise ValueError ( ""Key '%s' not found"" % key )"
new_value is a sum of value and delta.,new_value = value + delta
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
"call the function pickle.dumps with value and pickle.HIGHEST_PROTOCOL as the arguments, substitute the result for pickled.","pickled = pickle . dumps ( new_value , pickle . HIGHEST_PROTOCOL )"
"call the self._lock.writer method, with the result perform the following,",with self . _lock . writer ( ) :
substitute pickled for value under the key key of self._cache dictionary.,self . _cache [ key ] = pickled
return new_value.,return new_value
"define the method has_key with self class instance, key and version defaulting to None as arguments.","def has_key ( self , key , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
"call the self._lock.reader method, with the result perform the following,",with self . _lock . reader ( ) :
"if call to the _has_expired method with argument key evaluates to boolean False,",if not self . _has_expired ( key ) :
return boolean True.,return True
"call the self._lock.writer method, with the result perform the following,",with self . _lock . writer ( ) :
"try,",try :
delete the value under the key key of self._cache dictionary.,del self . _cache [ key ]
delete the value under the key key of self._expire_info dictionary.,del self . _expire_info [ key ]
"if KeyError exception is caught,",except KeyError :
do nothing.,pass
return boolean False.,return False
define the method _has_expired with self and key as arguments.,"def _has_expired ( self , key ) :"
"call the method self._expire_info.get with key and integer -1 as arguments, substitute the result for exp.","exp = self . _expire_info . get ( key , - 1 )"
"if exp is None or exp is greater than the return value of the call to the function time.time,",if exp is None or exp > time . time ( ) :
return boolean False.,return False
return boolean True.,return True
define the method _cull with argument self.,def _cull ( self ) :
if self._cull_frequency equals to integer 0.,if self . _cull_frequency == 0 :
call self.clear method.,self . clear ( )
"if not,",else :
"for every i and k in enumerated values of self._cache, if i is divisible by self._cull_frequency, append k to doomed list.","doomed = [ k for ( i , k ) in enumerate ( self . _cache ) if i % self . _cull_frequency == 0 ]"
"for every k in doomed,",for k in doomed :
call the method self._delete with argument k.,self . _delete ( k )
define the method _delete with arguments self and key.,"def _delete ( self , key ) :"
"try,",try :
delete the value under the key key of self._cache dictionary.,del self . _cache [ key ]
"if KeyError exception is caught,",except KeyError :
do nothing.,pass
"try,",try :
delete the value under the key key of the self._expire_info dictionary.,del self . _expire_info [ key ]
"if KeyError exception is caught,",except KeyError :
do nothing.,pass
"define the method delete with self class instance, key and version defaulting to None as arguments.","def delete ( self , key , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
"call the self._lock.writer method, with the result perform the following,",with self . _lock . writer ( ) :
call the method self._delete with argument key.,self . _delete ( key )
define the method clear with argument self.,def clear ( self ) :
call the method self._cache.clear.,self . _cache . clear ( )
call the method self._expire_info.clear.,self . _expire_info . clear ( )
derive the class CacheClass from the base class LocMemCache.,class CacheClass ( LocMemCache ) :
do nothing.,pass
import module time.,import time
import module pickle.,import pickle
from django.core.cache.backends.base import BaseCache and DEFAULT_TIMEOUT into default name space.,"from django . core . cache . backends . base import BaseCache , DEFAULT_TIMEOUT"
from django.utils import six into default name space.,from django . utils import six
from django.utils.deprecation import RenameMethodsBase and RemovedInDjango19Warning into default name space.,"from django . utils . deprecation import RenameMethodsBase , RemovedInDjango19Warning"
from django.utils.encoding import force_str into default name space.,from django . utils . encoding import force_str
from django.utils.functional import cached_property into default name space.,from django . utils . functional import cached_property
derive the class BaseMemcachedCacheMethods from RenameMethodsBase the base class.,class BaseMemcachedCacheMethods ( RenameMethodsBase ) :
"renamed methods is a tuple containing 3 elements: '_get_memcache_timeout', 'get_backend_timeout' and RemovedInDjango19Warning.","renamed_methods = ( ( '_get_memcache_timeout' , 'get_backend_timeout' , RemovedInDjango19Warning ) , )"
derive the class BaseMemcachedCache from base class BaseMemcachedCacheMethods and BaseCache.,"class BaseMemcachedCache ( six . with_metaclass ( BaseMemcachedCacheMethods , BaseCache ) ) :"
"define the method __init__ with, self, server, params, library, value_not_found_exception as arguments.","def __init__ ( self , server , params , library , value_not_found_exception ) :"
call the initialization method with argument params for the base class of the BaseMemcachedCache class.,"super ( BaseMemcachedCache , self ) . __init__ ( params )"
"if server is an instance of six.string_types,","if isinstance ( server , six . string_types ) :"
"split server with ';' as delimiter, substitute the result for self._servers.",self . _servers = server . split ( ';' )
"if not,",else :
substitute server for self._servers.,self . _servers = server
substitute value_not_found_exception for self.LibraryValueNotFoundException.,self . LibraryValueNotFoundException = value_not_found_exception
substitute library for self._lib.,self . _lib = library
"call the params.get function with string 'OPTIONS' and None as arguments, substitute the result for self._options.","self . _options = params . get ( 'OPTIONS' , None )"
"property decorator,",@ property
define the method _cache with argument self.,def _cache ( self ) :
"if self object has an attribute '_client',","if getattr ( self , '_client' , None ) is None :"
"call the self._lib.Client with argument self._servers, substitute the result for self._client.",self . _client = self . _lib . Client ( self . _servers )
return self._client.,return self . _client
define the method get_backend_timeout with self and timeout set to DEFAULT_TIMEOUT as arguments.,"def get_backend_timeout ( self , timeout = DEFAULT_TIMEOUT ) :"
"if timeout equals to DEFAULT_TIMEOUT,",if timeout == DEFAULT_TIMEOUT :
substitute self.default_timeout for timeout.,timeout = self . default_timeout
"if timeout is None,",if timeout is None :
return integer 0.,return 0
"else if timeout converted into an integer equals to integer 0,",elif int ( timeout ) == 0 :
timeout is a integer -1.,timeout = - 1
"if timeout is greater than integer 2592000,",if timeout > 2592000 :
"convert return value of the function time.time to an integer, increment timeout by it.",timeout += int ( time . time ( ) )
"convert timeout into an integer, return it.",return int ( timeout )
"define the method make_key with self class instance, key and version defaulting to None as arguments.","def make_key ( self , key , version = None ) :"
"call the method make_key with arguments key and version from the base class of the class BaseMemcachedCache, use it as an argument for the call to the function force_str, return the result.","return force_str ( super ( BaseMemcachedCache , self ) . make_key ( key , version ) )"
"define the method add with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.","def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
"call the method self._cache.add with key, value, self.get_backend_timeout(timeout) as arguments.","return self . _cache . add ( key , value , self . get_backend_timeout ( timeout ) )"
"define the method get with 5 arguments, self class instance, key, default set to None and version set to None.","def get ( self , key , default = None , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
"call the self._cache.get method with argument key, substitute the result for val.",val = self . _cache . get ( key )
"if val is None,",if val is None :
return default.,return default
return val.,return val
"define the method set with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.","def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
"call the method self._cache.set with key, value, self.get_backend_timeout(timeout) as arguments.","self . _cache . set ( key , value , self . get_backend_timeout ( timeout ) )"
"define the method delete with self, key and version set to None as arguments.","def delete ( self , key , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
call the method self._cache.delete with argument key.,self . _cache . delete ( key )
"define the method get_many with self class instance, keys and version defaulting to None as arguments.","def get_many ( self , keys , version = None ) :"
"define the method get_many with 3 arguments, self class instance, keys and version set to None.","new_keys = [ self . make_key ( x , version = version ) for x in keys ]"
"call the method self._cache.get_multi with argument new_keys, substitute the result for ret.",ret = self . _cache . get_multi ( new_keys )
if ret is true.,if ret :
_ is an empty dictionary.,_ = { }
"zip together new_keys and keys, convert it to dictionary, assign it to m.","m = dict ( zip ( new_keys , keys ) )"
"for every k and v in return value of the ret.items function,","for k , v in ret . items ( ) :"
substitute v for value under the k-th element of m key of _ dictionary.,_ [ m [ k ] ] = v
substitute _ for ret.,ret = _
return ret.,return ret
define the method close with self and dictionary pairs of elements kwargs.,"def close ( self , ** kwargs ) :"
call the method self._cache.disconnect_all.,self . _cache . disconnect_all ( )
"define the method incr with self, key, delta defaulting to integer 1 and version defaulting to None as arguments.","def incr ( self , key , delta = 1 , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
"if delta is smaller than integer 0,",if delta < 0 :
"evaluate the method self._cache.decr with key and negative delta as arguments, return the result.","return self . _cache . decr ( key , - delta )"
"try,",try :
"call the method self._cache.incr with key and delta as arguments, substitute the result for val.","val = self . _cache . incr ( key , delta )"
"if self.LibraryValueNotFoundException exception is caught,",except self . LibraryValueNotFoundException :
val is None.,val = None
"if val is None,",if val is None :
"raise an ValueError exception with string ""Key '%s' not found"" as argument, substitute '%s' for key.","raise ValueError ( ""Key '%s' not found"" % key )"
return val.,return val
"define the method decr with self, key, delta defaulting to integer 1 and version defaulting to None as arguments.","def decr ( self , key , delta = 1 , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
if delta is smaller than integer 0.,if delta < 0 :
"evaluate the method self._cache.incr with key and negative delta as arguments, return the result.","return self . _cache . incr ( key , - delta )"
"try,",try :
"call the method self._cache.decr with key and delta as arguments, substitute the result for val.","val = self . _cache . decr ( key , delta )"
"if self.LibraryValueNotFoundException exception is caught,",except self . LibraryValueNotFoundException :
val is None.,val = None
"if val is None,",if val is None :
"raise an ValueError exception with string ""Key '%s' not found"" as argument, substitute '%s' for key.","raise ValueError ( ""Key '%s' not found"" % key )"
return val.,return val
"define the method set_many with self, data, timeout set to DEFAULT_TIMEOUT and version set to None as arguments.","def set_many ( self , data , timeout = DEFAULT_TIMEOUT , version = None ) :"
safe_data is an empty dictionary.,safe_data = { }
"for every key and value in data.items function return value,","for key , value in data . items ( ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
substitute value for value under the key key of safe_data dictionary.,safe_data [ key ] = value
"call the method self._cache.set_multi with safe_data, self.get_backend_timeout(timeout) as arguments.","self . _cache . set_multi ( safe_data , self . get_backend_timeout ( timeout ) )"
"define the function delete_many with self, keys and version set to None as arguments.","def delete_many ( self , keys , version = None ) :"
"l is lambda function with argument x, that calls the method self.make_key with x and version set to version as arguments.","l = lambda x : self . make_key ( x , version = version )"
call the method self_cache.delete_multi with argument list containing keys mapped through function l.,"self . _cache . delete_multi ( map ( l , keys ) )"
define the method clear with argument self.,def clear ( self ) :
call the method self._cache_flush_all.,self . _cache . flush_all ( )
derive the class MemcachedCache from the BaseMemcachedCache base class.,class MemcachedCache ( BaseMemcachedCache ) :
"define the method __init__ with argument self, server and params.","def __init__ ( self , server , params ) :"
import memcache.,import memcache
"call method __init__ from the base class of the class MemcachedCache with arguments: server, params,","super ( MemcachedCache , self ) . __init__ ( server , params , library = memcache , value_not_found_exception = ValueError )"
"library set to memcache and value_not_found_exception set to ValueError. property decorator,",@ property
define the method _cache with self class instance as an argument.,def _cache ( self ) :
"if attribute '_client' of the self object is None,","if getattr ( self , '_client' , None ) is None :"
"call the method self._lib.Client with self._servers and pickleProtocol set to pickle.HIGHEST_PROTOCOL as arguments, substitute the result for self._client.","self . _client = self . _lib . Client ( self . _servers , pickleProtocol = pickle . HIGHEST_PROTOCOL )"
return self._client.,return self . _client
derive the class PyLibMCCache from BaseMemcachedCache base class.,class PyLibMCCache ( BaseMemcachedCache ) :
"define the method __init__ with self, server and params as arguments.","def __init__ ( self , server , params ) :"
import pylibmc.,import pylibmc
"call method __init__ from the base class of the class PyLibMCCache with arguments: server, params,","super ( PyLibMCCache , self ) . __init__ ( server , params , library = pylibmc , value_not_found_exception = pylibmc . NotFound )"
"library set to pylibmc and value_not_found_exception set to pylibmc.NotFound. decorator cached_property,",@ cached_property
define the method _cache with argument self.,def _cache ( self ) :
call the method self._lib.Client with argument self._servers.,client = self . _lib . Client ( self . _servers )
"if self._options exists,",if self . _options :
substitute self._options for client.behaviors.,client . behaviors = self . _options
return client.,return client
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
import module hashlib.,import hashlib
from django.utils.encoding import force_bytes into default name space.,from django . utils . encoding import force_bytes
from django.utils.http import urlquote into default name space.,from django . utils . http import urlquote
TEMPLATE_FRAGMENT_KEY_TEMPLATE is a string 'template.cache.%s.%s'.,TEMPLATE_FRAGMENT_KEY_TEMPLATE = 'template.cache.%s.%s'
define the function make_template_fragment_key with fragment_name and vary_on defaulting to None as arguments.,"def make_template_fragment_key ( fragment_name , vary_on = None ) :"
"if vary_on is None,",if vary_on is None :
vary_on is an empty tuple.,vary_on = ( )
"call the function urlquote with argument var for every var in vary_on, join the results into a string separated by ':', substitute it for key.",key = ':' . join ( urlquote ( var ) for var in vary_on )
call the hashlib.md5 fuction with force_bytes(key) as argument.,args = hashlib . md5 ( force_bytes ( key ) )
"substitute '%s' in TEMPLATE_FRAGMENT_KEY_TEMPLATE string with fragment_name and args.hexdigest(), respectively, return the result.","return TEMPLATE_FRAGMENT_KEY_TEMPLATE % ( fragment_name , args . hexdigest ( ) )"
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
"from .messages import CheckMessage, Debug, Info, Warning, Error, Critical, DEBUG, INFO, WARNING, ERROR and CRITICAL into default name space.","from . messages import ( CheckMessage , Debug , Info , Warning , Error , Critical , DEBUG , INFO , WARNING , ERROR , CRITICAL )"
"from .registry import register, run_checks, tag_exists and Tags into default name space.","from . registry import register , run_checks , tag_exists , Tags"
import module django.core.checks.compatibility.django_1_6_0.,import django . core . checks . compatibility . django_1_6_0
import module django.core.checks.compatibility.django_1_7_0.,import django . core . checks . compatibility . django_1_7_0
import module django.core.checks.model_checks.,import django . core . checks . model_checks
"__all__ is a list containing next strings, 'CheckMessage', 'Debug', 'Info', 'Warning', 'Error', 'Critical',","__all__ = [ 'CheckMessage' , 'Debug' , 'Info' , 'Warning' , 'Error' , 'Critical' , 'DEBUG' , 'INFO' , 'WARNING' , 'ERROR' , 'CRITICAL' , 'register' , 'run_checks' , 'tag_exists' , 'Tags' , ]"
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
from django.apps import apps into default name space.,from django . apps import apps
"from .. import Warning, register and Tags into default name space.","from . . import Warning , register , Tags"
decorator register with argument Tags.compatibility.,@ register ( Tags . compatibility )
define the function check_1_6_compatibility with argument kwargs dictionary.,def check_1_6_compatibility ( ** kwargs ) :
errors is an empty list,errors = [ ]
"call the function _check_test_runner with dictionary kwargs as argument, use the result as an argument for the call to the function errors.extend.",errors . extend ( _check_test_runner ( ** kwargs ) )
"call the function _check_boolean_field_default_value with dictionary kwargs as argument, use the result as an argument for the call to the function errors.extend.",errors . extend ( _check_boolean_field_default_value ( ** kwargs ) )
return errors.,return errors
define the function _check_test_runner with app_config set to None and kwargs dictionary as arguments.,"def _check_test_runner ( app_configs = None , ** kwargs ) :"
from django.conf import settings into default name space.,from django . conf import settings
weight is an integer 0.,weight = 0
if call to the settings.is_overridden with string 'TEST_RUNNER' evaluates to boolean False.,if not settings . is_overridden ( 'TEST_RUNNER' ) :
"try,",try :
settings.SITE_ID.,settings . SITE_ID
increment weight by integer 2.,weight += 2
"if AttributeError exception is caught,",except AttributeError :
do nothing.,pass
"try,",try :
settings.BASE_DIR.,settings . BASE_DIR
"if AttributeError exception is caught,",except AttributeError :
increment weight by integer 2.,weight += 2
"call the function settings.is_overridden with argument string 'TEMPLATE_LOADERS', if it evaluates to boolean True,",if settings . is_overridden ( 'TEMPLATE_LOADERS' ) :
increment weight by integer 2.,weight += 2
"call the function settings.is_overridden with argument string 'MANAGERS', if it evaluates to boolean True,",if settings . is_overridden ( 'MANAGERS' ) :
increment weight by integer 2.,weight += 2
"call the function settings.is_overridden with argument string 'ADMINS', if it evaluates to boolean True,",if settings . is_overridden ( 'ADMINS' ) :
increment weight by integer 2.,weight += 1
"if string 'django.middleware.clickjacking.XFrameOptionsMiddleware' is not contained in settings.MIDDLEWARE_CLASSES set,",if 'django.middleware.clickjacking.XFrameOptionsMiddleware' not in set ( settings . MIDDLEWARE_CLASSES ) :
increment weight by integer 2.,weight += 1
"if weight is greater or equal to integer 6,",if weight >= 6 :
"call the Warning function with 3 arguments: hint tuple containing one string, Django 1.6 introduced a new default test runner.","return [ Warning ( ""Some project unittests may not execute as expected."" , hint = ( ""Django 1.6 introduced a new default test runner. It looks like "" ""this project was generated using Django 1.5 or earlier. You should "" ""ensure your tests are all running & behaving as expected. See "" ""https://docs.djangoproject.com/en/dev/releases/1.6/#new-test-runner "" ""for more information."" ) , obj = None , id = '1_6.W001' , ) ]"
"It looks like this project was generated using Django 1.5 or earlier. You should ensure your tests are all running & behaving as expected. See https://docs.djangoproject.com/en/dev/releases/1.6/#new-test-runner for more information."", obj set to None and id set to a string '1_6.W001', put the result into a list and return it. if not,",else :
return an empty list.,return [ ]
define the function _check_boolean_field_default_value with app_config set to None and kwargs dictionary as arguments.,"def _check_boolean_field_default_value ( app_configs = None , ** kwargs ) :"
from django.db import models into default name space.,from django . db import models
"append field to problem_fields list for every model in apps.get_models with argument kwargs dictionary, only if app_configs is None,","problem_fields = [ field for model in apps . get_models ( ** kwargs ) if app_configs is None or model . _meta . app_config in app_configs for field in model . _meta . local_fields if isinstance ( field , models . BooleanField ) and not field . has_default ( ) ]"
"or model._meta.app_config is contained in app_configs, for every field in model._meta.local_fields, #ANNOTATION only if field is an instance of models.BooleanField and field.has_default() evaluates to False. call the Warning function with 4 arguments: string ""BooleanField does not have a default value."",","return [ Warning ( ""BooleanField does not have a default value."" , hint = ( ""Django 1.6 changed the default value of BooleanField from False to None. "" ""See https://docs.djangoproject.com/en/1.6/ref/models/fields/#booleanfield "" ""for more information."" ) , obj = field , id = '1_6.W002' , ) for field in problem_fields ]"
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
"from .. import Warning, register and Tags into default name space.","from . . import Warning , register , Tags"
decorator register with argument Tags.compatibility.,@ register ( Tags . compatibility )
define the function check_1_7_compatibility with argument kwargs dictionary.,def check_1_7_compatibility ( ** kwargs ) :
errors is an empty list.,errors = [ ]
"call the function _check_middleware_classes with dictionary kwargs as argument, use the result as an argument for the call to the function errors.extend.",errors . extend ( _check_middleware_classes ( ** kwargs ) )
return errors.,return errors
define the function _check_middleware_classes with app_config set to None and kwargs dictionary as arguments.,"def _check_middleware_classes ( app_configs = None , ** kwargs ) :"
from django.conf import settings into default name space.,from django . conf import settings
"call the function settings.is_overridden with argument string 'MIDDLEWARE_CLASSES', if the result is boolean False,",if not settings . is_overridden ( 'MIDDLEWARE_CLASSES' ) :
"call the Warning function with 4 arguments: string ""MIDDLEWARE_CLASSES is not set."", hint tuple containing one string,","return [ Warning ( ""MIDDLEWARE_CLASSES is not set."" , hint = ( ""Django 1.7 changed the global defaults for the MIDDLEWARE_CLASSES. "" ""django.contrib.sessions.middleware.SessionMiddleware, "" ""django.contrib.auth.middleware.AuthenticationMiddleware, and "" ""django.contrib.messages.middleware.MessageMiddleware were removed from the defaults. "" ""If your project needs these middleware then you should configure this setting."" ) , obj = None , id = '1_7.W001' , ) ]"
"""Django 1.7 changed the global defaults for the MIDDLEWARE_CLASSES. django.contrib.sessions.middleware.SessionMiddleware, django.contrib.auth.middleware.AuthenticationMiddleware, and django.contrib.messages.middleware.MessageMiddleware were removed from the defaults. If your project needs these middleware then you should configure this setting."", obj set to None, and id set to a string '1_7.W001', put the result into a list and return it. if not,",else :
return an empty list.,return [ ]
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
from django.utils.encoding import python_2_unicode_compatible and force_st into default name space.,"from django . utils . encoding import python_2_unicode_compatible , force_str"
DEBUG is integer 10.,DEBUG = 10
INFO is integer 20.,INFO = 20
WARNING is integer 30.,WARNING = 30
ERROR is integer 40.,ERROR = 40
CRITICAL is integer 50.,CRITICAL = 50
decorator python_2_unicode_compatible.,@ python_2_unicode_compatible
derive class CheckMessage from object base class.,class CheckMessage ( object ) :
"define initialization method __init__ with self class instance, level, msg, hint defaulting to None, obj defaulting to None and if defaulting to None as arguments.","def __init__ ( self , level , msg , hint = None , obj = None , id = None ) :"
"if level is not an integer raise an error with message string ""The first argument should be level."".","assert isinstance ( level , int ) , ""The first argument should be level."""
substitute level for self.level.,self . level = level
substitute msg for self.msg.,self . msg = msg
substitute hint for self.hint.,self . hint = hint
substitute obj for self.obj.,self . obj = obj
substitute id for self.id.,self . id = id
define private method __eq__ with self class instance and other as arguments.,"def __eq__ ( self , other ) :"
"if for all attr in list of attributes 'level', 'msg', 'hint', 'obj' and 'id', self and other have the same attribute attr,","return all ( getattr ( self , attr ) == getattr ( other , attr ) for attr in [ 'level' , 'msg' , 'hint' , 'obj' , 'id' ] )"
"return boolean True, otherwise return boolean False. define private method __ne__ with self class instance and other as arguments.","def __ne__ ( self , other ) :"
"if self equals to other return boolean False, otherwise return True.",return not ( self == other )
define private method __str__ with argument self.,def __str__ ( self ) :
from django.db import models into default name space.,from django . db import models
"if self.obj is None,",if self . obj is None :
"obj is a string ""?"".","obj = ""?"""
"otherwise if self.object is an instance of the models.base.ModelBase class,","elif isinstance ( self . obj , models . base . ModelBase ) :"
substitute self.obj for model.,model = self . obj
substitute model._meta.app_label for app.,app = model . _meta . app_label
"convert app and model._meta.object_name to strings, join them with separating '.' character, substitute it for obj.","obj = '%s.%s' % ( app , model . _meta . object_name )"
"if not,",else :
"call the function force_str with argument self.obj, substitute the result for obj.",obj = force_str ( self . obj )
"if self.id exists, convert self.id to a string, surround it with round brackets, substitute id for it, otherwise id is an empty string.","id = ""(%s) "" % self . id if self . id else """""
"if self.hint exists, replace '%s' in a string ""\n\tHINT: %s"" with value of self.hint, substitute it for hint, otherwise hint is an empty string.","hint = ""\n\tHINT: %s"" % self . hint if self . hint else ''"
"replace all '%s' from string ""%s: %s%s%s"" with values of obj, id, self.msg and hint, respectively, return the result.","return ""%s: %s%s%s"" % ( obj , id , self . msg , hint )"
define private method __repr__ with argument self.,def __repr__ ( self ) :
"in the string ""<%s: level=%r, msg=%r, hint=%r, obj=%r, id=%r>"", replace '%s' with the name of the type of this class instance,","return ""<%s: level=%r, msg=%r, hint=%r, obj=%r, id=%r>"" % ( self . __class__ . __name__ , self . level , self . msg , self . hint , self . obj , self . id )"
"replace all the '%r' with self.level, self.msg, self.hint. self.obj and self.id, respectively, return the result. define the method is_serious with argument self.",def is_serious ( self ) :
"return boolean True if self.level is greater than or equals to ERROR, otherwise return boolean False.",return self . level >= ERROR
define the method is_silence with argument self.,def is_silenced ( self ) :
from django.conf import settings into default name space.,from django . conf import settings
"if self.id is contained in settings.SILENCED_SYSTEM_CHECKS return boolean True, False otherwise.",return self . id in settings . SILENCED_SYSTEM_CHECKS
derive the class Debug from base class CheckMessage.,class Debug ( CheckMessage ) :
"define initialization method __init__ with self class instance, unpacked list args, unpacked dictionary kwargs as arguments.","def __init__ ( self , * args , ** kwargs ) :"
"call the __init__ method with 3 arguments: DEBUG, unpacked list args and unpacked dictionary kwargs from the base class of Debug.","return super ( Debug , self ) . __init__ ( DEBUG , * args , ** kwargs )"
derive the class Info from base class CheckMessage.,class Info ( CheckMessage ) :
"define initialization method __init__ with self class instance, unpacked list args, unpacked dictionary kwargs as arguments.","def __init__ ( self , * args , ** kwargs ) :"
"call the __init__ method with 3 arguments: INFO, unpacked list args and unpacked dictionary kwargs from the base class of Info.","return super ( Info , self ) . __init__ ( INFO , * args , ** kwargs )"
derive the class Warning from base class CheckMessage.,class Warning ( CheckMessage ) :
"define initialization method __init__ with self class instance, unpacked list args, unpacked dictionary kwargs as arguments.","def __init__ ( self , * args , ** kwargs ) :"
"call the __init__ method with 3 arguments: WARNING, unpacked list args and unpacked dictionary kwargs from the base class of Warning.","return super ( Warning , self ) . __init__ ( WARNING , * args , ** kwargs )"
derive the class Error from base class CheckMessage.,class Error ( CheckMessage ) :
"define initialization method __init__ with self class instance, unpacked list args, unpacked dictionary kwargs as arguments.","def __init__ ( self , * args , ** kwargs ) :"
"call the __init__ method with 3 arguments: ERROR, unpacked list args and unpacked dictionary kwargs from the base class of Error.","return super ( Error , self ) . __init__ ( ERROR , * args , ** kwargs )"
derive the class Critical from base class CheckMessage.,class Critical ( CheckMessage ) :
"define initialization method __init__ with self class instance, unpacked list args, unpacked dictionary kwargs as arguments.","def __init__ ( self , * args , ** kwargs ) :"
"call the __init__ method with 3 arguments: CRITICAL, unpacked list args and unpacked dictionary kwargs from the base class of Critical.","return super ( Critical , self ) . __init__ ( CRITICAL , * args , ** kwargs )"
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
from itertools import chain into default name space.,from itertools import chain
import module types.,import types
from django.apps import apps into default name space.,from django . apps import apps
"from . import Error, Tags and register into default name space.","from . import Error , Tags , register"
decorator register with Tags.models as an argument.,@ register ( Tags . models )
define the function check_all_models with app_configs defaulting to None and unpacked dictionary kwargs as arguments.,"def check_all_models ( app_configs = None , ** kwargs ) :"
"call the model.check method with unpacked dictionary kwargs for every model in return value of function apps.get_models,",errors = [ model . check ( ** kwargs ) for model in apps . get_models ( ) if app_configs is None or model . _meta . app_config in app_configs ]
"only if app_configs is None ot model._meta.app_config is contained in app_configs, error is a list containing all the previous elements. chain all errors elements into a list, return it.",return list ( chain ( * errors ) )
decorator register with Tags.models and Tags.signals as arguments.,"@ register ( Tags . models , Tags . signals )"
"define the function check_model_signals with app_config defaulting to None and unpacked dictionary kwargs as arguments,","def check_model_signals ( app_configs = None , ** kwargs ) :"
from django.db import models into default name space.,from django . db import models
errors is an empty list.,errors = [ ]
"for name in attributes of models_signals object,",for name in dir ( models . signals ) :
"get models.signals name attribute, store it in obj.","obj = getattr ( models . signals , name )"
"if obj is instance of models.signals.ModelSignal class,","if isinstance ( obj , models . signals . ModelSignal ) :"
"for every reference and receivers in return value of the call of obj.unresolved_references.items method,","for reference , receivers in obj . unresolved_references . items ( ) :"
"for every receiver, _ and _ in receivers,","for receiver , _ , _ in receivers :"
"if receiver is an instance of types.FunctionType type,","if isinstance ( receiver , types . FunctionType ) :"
"description is a string ""The '%s' function"" replaced by value of receiver.__name__.","description = ""The '%s' function"" % receiver . __name__"
"if not,",else :
"description is a string ""An instance of the '%s' class"" with '%s' replaced by value of receiver.__class__.__name__.","description = ""An instance of the '%s' class"" % receiver . __class__ . __name__"
"call the Error function with 4 arguments, string ""%s was connected to the '%s' signal with a lazy reference to the '%s' sender,","errors . append ( Error ( ""%s was connected to the '%s' signal "" ""with a lazy reference to the '%s' sender, "" ""which has not been installed."" % ( description , name , '.' . join ( reference ) ) , obj = receiver . __module__ , hint = None , id = 'signals.E001' ) )"
"which has not been installed."" with all the '%s' replaced by values of description, name and reference joined into a string delimited by '.', respectively, obj set to receiver.__module__, hint set to None and id set to string 'signals.E001', append the result to errors. return errors.",return errors
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
from itertools import chain into default name space.,from itertools import chain
from django.utils.itercompat import is_iterable into default name space.,from django . utils . itercompat import is_iterable
derive the class Tags with base class object.,class Tags ( object ) :
admin is a string 'admin',admin = 'admin'
compatibility is a string 'compatibility'.,compatibility = 'compatibility'
models is a string 'models',models = 'models'
signal is a string 'signals',signals = 'signals'
derive the class CheckRegistry with object as base class.,class CheckRegistry ( object ) :
define initialization method __init__ with argument self.,def __init__ ( self ) :
self.registered_checks is an empty list.,self . registered_checks = [ ]
define the method register with self ans unpacked list tags as arguments.,"def register ( self , * tags ) :"
define the method inner with argument check.,def inner ( check ) :
replace tags for check.tags.,check . tags = tags
if check is not contained in self.registered_checks.,if check not in self . registered_checks :
call the method self.registered_checks.append with argument check.,self . registered_checks . append ( check )
return check.,return check
return inner.,return inner
"define the method run_checks with self class instance, app_configs defaulting to None, tags defaulting to None as argument.","def run_checks ( self , app_configs = None , tags = None ) :"
errors is an empty list.,errors = [ ]
if tags is not None.,if tags is not None :
"append check to checks list, for every check in self.register_checks, if check has an attribute 'tags' and check.tags and tags set intersection is a non empty set.","checks = [ check for check in self . registered_checks if hasattr ( check , 'tags' ) and set ( check . tags ) & set ( tags ) ]"
if not.,else :
substitute self.registered_checks for checks.,checks = self . registered_checks
"for every check in checks,",for check in checks :
"call the check function with argument app_config set to app_config, substitute the result for new_errors.",new_errors = check ( app_configs = app_configs )
"if new_errors is not an iterable object raise an error with error message ""The function %r did not return a list. All functions registered with the checks registry must return a list."", with '%s' replaced by value of check.","assert is_iterable ( new_errors ) , ( ""The function %r did not return a list. All functions registered "" ""with the checks registry must return a list."" % check )"
call the method errors.extend with argument new_errors.,errors . extend ( new_errors )
return errors.,return errors
define the method tag_exists with self class instance and tag as arguments.,"def tag_exists ( self , tag ) :"
"return boolean True if tag is contained in self.tags_available method return value, return False otherwise.",return tag in self . tags_available ( )
define the method tags_available with argument self.,def tags_available ( self ) :
"append check.tags into a list for every check in self.registered_checks if check has 'tags' attribute, put the elements into a set and return it.","return set ( chain ( * [ check . tags for check in self . registered_checks if hasattr ( check , 'tags' ) ] ) )"
"call the function CheckRegistry, substitute the result for registry.",registry = CheckRegistry ( )
substitute registry.register for register.,register = registry . register
substitute registry.run_checks for run_checks.,run_checks = registry . run_checks
substitute registry.tag_exists for tag_exists.,tag_exists = registry . tag_exists
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
from django.conf import settings into default name space.,from django . conf import settings
from django.middleware.csrf import get_token into default name space.,from django . middleware . csrf import get_token
from django.utils import six into default name space.,from django . utils import six
from django.utils.encoding import smart_text into default name space.,from django . utils . encoding import smart_text
from django.utils.functional import lazy into default name space.,from django . utils . functional import lazy
define the function csrf with an argument request.,def csrf ( request ) :
define the function _get_val.,def _get_val ( ) :
"call the function get_token with an argument request, substitute the result for token.",token = get_token ( request )
"if token is None,",if token is None :
return string 'NOTPROVIDED'.,return 'NOTPROVIDED'
"if not,",else :
"call the smart_text function with an argument token, return the result.",return smart_text ( token )
"call the function lazy with arguments _get_val and six.text_type, substitute the result for _get_val.","_get_val = lazy ( _get_val , six . text_type )"
return an dictionary containing 1 entry: return value of the function _get_val for 'csrf_token'.,return { 'csrf_token' : _get_val ( ) }
define the function debug with an argument request.,def debug ( request ) :
context_extras is an empty dictionary.,context_extras = { }
"if settings.DEBUG is true and value of the request.META dictionary under the 'REMOTE_ADDR' key is contained in settings.INTERNAL_IPS,",if settings . DEBUG and request . META . get ( 'REMOTE_ADDR' ) in settings . INTERNAL_IPS :
value under the 'debug' key of the context_extras dictionary is boolean True.,context_extras [ 'debug' ] = True
from django.db import connection into default name space.,from django . db import connection
substitute connection.queries for value under the 'debug' key of the context_extras dictionary.,context_extras [ 'sql_queries' ] = connection . queries
return context_extras.,return context_extras
define the function i18n with an argument request.,def i18n ( request ) :
from django.utils import translation into default name space.,from django . utils import translation
context_extras is an empty dictionary.,context_extras = { }
substitute settings.LANGUAGES for the value under the 'LANGUAGES' key of the context_extras dictionary.,context_extras [ 'LANGUAGES' ] = settings . LANGUAGES
"call the translation.get_language function, substitute the result for the value under the 'LANGUAGE_CODE' key of the context_extras dictionary.",context_extras [ 'LANGUAGE_CODE' ] = translation . get_language ( )
"call the translation.get_language_bidi function, substitute the result for the value under the 'LANGUAGE_BIDI' key of the context_extras dictionary.",context_extras [ 'LANGUAGE_BIDI' ] = translation . get_language_bidi ( )
return context_extras.,return context_extras
define the function tz with an argument request.,def tz ( request ) :
from django.utils import timezone into default name space.,from django . utils import timezone
return an dictionary containing 1 entry: return value of the function timezone.get_current_timezone_name for 'TIME_ZONE'.,return { 'TIME_ZONE' : timezone . get_current_timezone_name ( ) }
define the function static with an argument request.,def static ( request ) :
return an dictionary containing 1 entry: settings.STATIC_URL for 'STATIC_URL'.,return { 'STATIC_URL' : settings . STATIC_URL }
define the function media with an argument request.,def media ( request ) :
return an dictionary containing 1 entry: settings.MEDIA_URL for 'MEDIA_URL'.,return { 'MEDIA_URL' : settings . MEDIA_URL }
define the function request with an argument request.,def request ( request ) :
return an dictionary containing 1 entry: request for 'request'.,return { 'request' : request }
from functools import reduce into default name space.,from functools import reduce
import module operator.,import operator
from django.utils import six into default name space.,from django . utils import six
from django.utils.encoding import force_text into default name space.,from django . utils . encoding import force_text
derive the class DjangoRuntimeWarning from the RuntimeWarning base class.,class DjangoRuntimeWarning ( RuntimeWarning ) :
do nothing.,pass
derive the class AppRegistryNotReady from the Exception base class.,class AppRegistryNotReady ( Exception ) :
do nothing.,pass
derive the class ObjectDoesNotExist from the Exception base class.,class ObjectDoesNotExist ( Exception ) :
silent_variable_failure is an boolean True.,silent_variable_failure = True
derive the class MultipleObjectsReturned from the Exception base class.,class MultipleObjectsReturned ( Exception ) :
do nothing.,pass
derive the class SuspiciousOperation from the Exception base class.,class SuspiciousOperation ( Exception ) :
derive the class SuspiciousMultipartForm from the SuspiciousOperation base class.,class SuspiciousMultipartForm ( SuspiciousOperation ) :
do nothing.,pass
derive the class SuspiciousFileOperation from the SuspiciousOperation base class.,class SuspiciousFileOperation ( SuspiciousOperation ) :
do nothing.,pass
derive the class DisallowedHost from the SuspiciousOperation base class.,class DisallowedHost ( SuspiciousOperation ) :
do nothing.,pass
derive the class DisallowedRedirect from the SuspiciousOperation base class.,class DisallowedRedirect ( SuspiciousOperation ) :
do nothing.,pass
derive the class PermissionDenied from the Exception base class.,class PermissionDenied ( Exception ) :
do nothing.,pass
derive the class ViewDoesNotExist from the Exception base class.,class ViewDoesNotExist ( Exception ) :
do nothing.,pass
derive the class MiddlewareNotUsed from the Exception base class.,class MiddlewareNotUsed ( Exception ) :
do nothing.,pass
derive the class ImproperlyConfigured from the Exception base class.,class ImproperlyConfigured ( Exception ) :
do nothing.,pass
derive the class FieldError from the Exception base class.,class FieldError ( Exception ) :
do nothing.,pass
NON_FIELD_ERRORS is an string '__all__'.,NON_FIELD_ERRORS = '__all__'
derive the class ValidationError from the Exception base class.,class ValidationError ( Exception ) :
"define the method __init__ with 4 arguments: self, message, code set to None and params set to None.","def __init__ ( self , message , code = None , params = None ) :"
"call the __init__ method from the base class of the class ValidationError with arguments message, code and params.","super ( ValidationError , self ) . __init__ ( message , code , params )"
"if message is an instance of ValidationError class,","if isinstance ( message , ValidationError ) :"
"if message has an 'error_dict' attribute,","if hasattr ( message , 'error_dict' ) :"
substitute message.error_dict for message.,message = message . error_dict
"alternatively, if six.PY3 is true check if message does not have an attribute 'message', if six.PY3 is false, check if message doesnt have an attribute 'code', perform the following,","elif not hasattr ( message , 'message' if six . PY3 else 'code' ) :"
substitute message.error_list for message.,message = message . error_list
"if not,",else :
"substitute message.message, message.code, message.params for message, code and params, respectively.","message , code , params = message . message , message . code , message . params"
"if message is an instance of dict type,","if isinstance ( message , dict ) :"
self.error_dict is an empty dictionary.,self . error_dict = { }
"for every field, messages in return value of the message.items method,","for field , messages in message . items ( ) :"
"if messages is not an instance of the ValidationError class,","if not isinstance ( messages , ValidationError ) :"
messages is an instance of the ValidationError class created with an argument messages.,messages = ValidationError ( messages )
substitute messages.error_list for the value under the field key of the self.error_dict dictionary.,self . error_dict [ field ] = messages . error_list
otherwise if message is an instance of the list type.,"elif isinstance ( message , list ) :"
self.error_list is an empty list.,self . error_list = [ ]
"for every message is message,",for message in message :
"if message is not an instance of the ValidationError class,","if not isinstance ( message , ValidationError ) :"
message is an instance of the ValidationError class created with an argument message.,message = ValidationError ( message )
extend the self.error_list list with message.error_list.,self . error_list . extend ( message . error_list )
"if not,",else :
substitute message for self.message.,self . message = message
substitute code for self.code.,self . code = code
substitute params for self.params.,self . params = params
substitute list containing element self for self.error_list.,self . error_list = [ self ]
"property getter decorator,",@ property
define the method message_dict with an argument self.,def message_dict ( self ) :
get attribute 'error_dict' from the self object.,"getattr ( self , 'error_dict' )"
"convert object self to a dictionary, return it.",return dict ( self )
"property getter decorator,",@ property
define the messages with an argument self.,def messages ( self ) :
"if self has an 'error_dict' attribute,","if hasattr ( self , 'error_dict' ) :"
"call the operator.add on the values of the self object converted into a dictionary, until it is reduced to a single value, return it.","return reduce ( operator . add , dict ( self ) . values ( ) )"
convert self to a list and return it.,return list ( self )
define the method update_error_dict with arguments self and error_dict.,"def update_error_dict ( self , error_dict ) :"
"if self has an 'error_dict' attribute,","if hasattr ( self , 'error_dict' ) :"
"for every field, error_list in self.error_dict.items method return value,","for field , error_list in self . error_dict . items ( ) :"
call the method extend with an argument error_list on the return value of the method error_dict.setdefault called with 2 arguments: field and an empty list.,"error_dict . setdefault ( field , [ ] ) . extend ( error_list )"
"if not,",else :
call the method extend with an argument error_list on the return value of the method error_dict.setdefault called with 2 arguments: NON_FIELD_ERRORS and an empty list.,"error_dict . setdefault ( NON_FIELD_ERRORS , [ ] ) . extend ( self . error_list )"
return error_dict.,return error_dict
define the method __iter__ with an argument self.,def __iter__ ( self ) :
"if self has an 'error_dict' attribute,","if hasattr ( self , 'error_dict' ) :"
"for every field, errors in self.error_dict.items method return value,","for field , errors in self . error_dict . items ( ) :"
"yield field and ValidationError object converted to an list, created with an argument errors.","yield field , list ( ValidationError ( errors ) )"
"if not,",else :
"for every error in self.error_list,",for error in self . error_list :
substitute error.message for message.,message = error . message
"if error.params is true,",if error . params :
"divide message by error.params, substitute the residue of the division for message.",message %= error . params
"call the force_text with an argument message, yield the result.",yield force_text ( message )
define the method __str__ with an argument self.,def __str__ ( self ) :
"if self has an attribute 'error_dict',","if hasattr ( self , 'error_dict' ) :"
