nl,code
from threading import local into default name space.,from threading import local
import module warnings.,import warnings
from django.conf import settings into default name space.,from django . conf import settings
from django.core import signals into default name space.,from django . core import signals
"from django.core.cache.backends.base import InvalidCacheBackendError, CacheKeyWarning and BaseCache into default name space.","from django . core . cache . backends . base import ( InvalidCacheBackendError , CacheKeyWarning , BaseCache )"
from django.core.exceptions import ImproperlyConfigured into default name space.,from django . core . exceptions import ImproperlyConfigured
from django.utils.deprecation import RemovedInDjango19Warning into default name space.,from django . utils . deprecation import RemovedInDjango19Warning
from django.utils.module_loading import import_string into default name space.,from django . utils . module_loading import import_string
"__all__ is an list containing 6 elements: 'get_cache', 'cache', 'DEFAULT_CACHE_ALIAS', 'InvalidCacheBackendError',","__all__ = [ 'get_cache' , 'cache' , 'DEFAULT_CACHE_ALIAS' , 'InvalidCacheBackendError' , 'CacheKeyWarning' , 'BaseCache' , ]"
'CacheKeyWarning' and 'BaseCache' DEFAULT_CACHE_ALIAS is a string 'default'.,DEFAULT_CACHE_ALIAS = 'default'
"if DEFAULT_CACHE_ALIAS is not contained in settings.CACHES,",if DEFAULT_CACHE_ALIAS not in settings . CACHES :
"raise an exception ImproperlyConfigured with string ""You must define a '%s' cache"" as argument, with '%s' replaced with DEFAULT_CACHE_ALIAS converted into a string.","raise ImproperlyConfigured ( ""You must define a '%s' cache"" % DEFAULT_CACHE_ALIAS )"
define the function get_cache with backend and dictionary pair of elements kwargs as arguments.,"def get_cache ( backend , ** kwargs ) :"
"call the function warnings.warn with string ""'get_cache' is deprecated in favor of 'caches'."", RemovedInDjango19Warning,","warnings . warn ( ""'get_cache' is deprecated in favor of 'caches'."" , RemovedInDjango19Warning , stacklevel = 2 )"
"and stacklevel set to 2 as arguments. call the _create_cache with backend and dictionary kwargs as arguments, substitute the result for cache.","cache = _create_cache ( backend , ** kwargs )"
call the function signals.request_finished.connect with argument cache.close.,signals . request_finished . connect ( cache . close )
return cache.,return cache
define the function _create_cache with backend and dictionary pair of elements kwargs as arguments.,"def _create_cache ( backend , ** kwargs ) :"
"try,",try :
"try,",try :
substitute value under the backend key of settings.CACHES dictionary for conf.,conf = settings . CACHES [ backend ]
"if KeyError exception is caught,",except KeyError :
"try,",try :
call the function import_string with argument backend.,import_string ( backend )
"if ImportError, renamed to e, exception is caught,",except ImportError as e :
"raise and exception InvalidCacheBackendError with string ""Could not find backend '%s': %s"" as argument, replace '%s' with backend and e, respectively.","raise InvalidCacheBackendError ( ""Could not find backend '%s': %s"" % ( backend , e ) )"
"remove 'LOCATION' key from kwargs dictionary and put it into location, or use an empty string if key doesnt exists.","location = kwargs . pop ( 'LOCATION' , '' )"
substitute kwargs for params.,params = kwargs
"if not,",else :
"call the function conf.copy, substitute it for params.",params = conf . copy ( )
call the function params.update with argument kwargs.,params . update ( kwargs )
remove 'BACKEND' key from params dictionary and put it into backend.,backend = params . pop ( 'BACKEND' )
"remove 'LOCATION' key from kwargs dictionary and put it into location, or use an empty string if key doesnt exists.","location = params . pop ( 'LOCATION' , '' )"
"call the import_string with argument backend, substitute it for backend_cls.",backend_cls = import_string ( backend )
"if ImportError, renamed to e, is caught,",except ImportError as e :
"aise and exception InvalidCacheBackendError with string ""Could not find backend '%s': %s"" as argument, replace '%s' with backend and e, respectively.","raise InvalidCacheBackendError ( ""Could not find backend '%s': %s"" % ( backend , e ) )"
"evaluate the function backend_cls with location and params as arguments, return the result.","return backend_cls ( location , params )"
derive the class CacheHandler from the object base class.,class CacheHandler ( object ) :
define the __init__ method with argument self.,def __init__ ( self ) :
"call the function local, substitute the result for self._caches.",self . _caches = local ( )
define the __getitem__ method with self and alias arguments.,"def __getitem__ ( self , alias ) :"
"try,",try :
return value under the alias key of self._caches.caches dictionary.,return self . _caches . caches [ alias ]
"except if AttributeError is caught,",except AttributeError :
self._caches.caches is an empty dictionary.,self . _caches . caches = { }
"except if KeyError exception is caught,",except KeyError :
do nothing.,pass
"if alias is not contained in setting.CACHES,",if alias not in settings . CACHES :
"raise and exception InvalidCacheBackendError with string ""Could not find config for '%s' in settings.CACHES"" as argument, replace '%s' with alias.","raise InvalidCacheBackendError ( ""Could not find config for '%s' in settings.CACHES"" % alias )"
call the function _create_cache with argument alias.,cache = _create_cache ( alias )
substitute cache for value under the alias key of self._caches.caches dictionary.,self . _caches . caches [ alias ] = cache
reuturn cache.,return cache
define the method all with argument self.,def all ( self ) :
"get attribute 'caches' from the self._caches if exists, otherwise get an empty dictionary, call the values method on the return value, return it.","return getattr ( self . _caches , 'caches' , { } ) . values ( )"
"call the CacheHandler function, substitute the result for caches.",caches = CacheHandler ( )
derive the class DefaultCacheProxy from the base class object.,class DefaultCacheProxy ( object ) :
define the method __getattr__ with self and name as arguments.,"def __getattr__ ( self , name ) :"
"get attribute name from value under the DEFAULT_CACHE_ALIAS key of caches dictionary, return it.","return getattr ( caches [ DEFAULT_CACHE_ALIAS ] , name )"
"define the method __setattr__ with self, name and value as arguments.","def __setattr__ ( self , name , value ) :"
"set the attribute name from value under the DEFAULT_CACHE_ALIAS key of caches dictionary to value, return it.","return setattr ( caches [ DEFAULT_CACHE_ALIAS ] , name , value )"
define the method __delattr__ with self and name as arguments.,"def __delattr__ ( self , name ) :"
delete the attribute name from the cache dictionary under the DEFAULT_CACHE_ALIAS key.,"return delattr ( caches [ DEFAULT_CACHE_ALIAS ] , name )"
define the method __contains__ with self and key as arguments.,"def __contains__ ( self , key ) :"
"if key if contained in value under the DEFAULT_CACHE_ALIAS key of caches dictionary, return boolean True, otherwise return False.",return key in caches [ DEFAULT_CACHE_ALIAS ]
define the method __eq__ with self and other as arguments.,"def __eq__ ( self , other ) :"
"if value under the DEFAULT_CACHE_ALIAS key of caches dictionary equals to other, return boolean True, otherwise return False.",return caches [ DEFAULT_CACHE_ALIAS ] == other
define the method __ne__ with self and other as arguments.,"def __ne__ ( self , other ) :"
"if value under the DEFAULT_CACHE_ALIAS key of caches dictionary is not equal to other, return boolean True, otherwise return False.",return caches [ DEFAULT_CACHE_ALIAS ] != other
"call the DefaultCacheProxy function, substitute it for cache.",cache = DefaultCacheProxy ( )
define the function close_caches with dictionary pair of elements kwargs as argument.,def close_caches ( ** kwargs ) :
for every cache in return value of the function caches.all.,for cache in caches . all ( ) :
call the function cache.close.,cache . close ( )
call the function signals.request_finished.connect with argument close_caches.,signals . request_finished . connect ( close_caches )
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
import module time.,import time
import module warnings.,import warnings
from django.core.exceptions import ImproperlyConfigured and DjangoRuntimeWarning into default name space.,"from django . core . exceptions import ImproperlyConfigured , DjangoRuntimeWarning"
from django.utils.module_loading import import_string into default name space.,from django . utils . module_loading import import_string
derive class InvalidCacheBackendError from the ImproperlyConfigured base class.,class InvalidCacheBackendError ( ImproperlyConfigured ) :
do nothing.,pass
derive class CacheKeyWarning from the DjangoRuntimeWarning base class.,class CacheKeyWarning ( DjangoRuntimeWarning ) :
do nothing.,pass
DEFAULT_TIMEOUT is a instance of the class object.,DEFAULT_TIMEOUT = object ( )
MEMCACHE_MAX_KEY_LENGTH is integer 250.,MEMCACHE_MAX_KEY_LENGTH = 250
"define the function default_key_func with 3 arguments, key, key_prefix and version.","def default_key_func ( key , key_prefix , version ) :"
"convert key_prefix, version and key into strings, concatenate them respectively, with character ':' as delimiter, return the result.","return '%s:%s:%s' % ( key_prefix , version , key )"
define the function get_key_func with argument key_func.,def get_key_func ( key_func ) :
"if key_func is not of None type,",if key_func is not None :
"if key_function is callable object,",if callable ( key_func ) :
return key_func.,return key_func
"if not,",else :
"evaluate the function import_string with key_func as argument, return the result.",return import_string ( key_func )
return default_key_func.,return default_key_func
derive the class BaseCache from the object base class.,class BaseCache ( object ) :
define the initialization function __init__ with self class instance and params as arguments.,"def __init__ ( self , params ) :"
"call the params.get method with string 'TIMEOUT' and integer 300 as arguments, use the string 'timeout' and previous result as the arguments for the call to the params.get method, substitute the result for timeout.","timeout = params . get ( 'timeout' , params . get ( 'TIMEOUT' , 300 ) )"
"if timeout is not None,",if timeout is not None :
"try,",try :
convert timeout into an integer.,timeout = int ( timeout )
"if ValueError or TypeError exceptions occurred,","except ( ValueError , TypeError ) :"
timeout is integer 300.,timeout = 300
substitute timeout for self.default_timeout.,self . default_timeout = timeout
"call the params.get with string 'OPTIONS' and empty dictionary as arguments, substitute the result for options.","options = params . get ( 'OPTIONS' , { } )"
"call the options.get method with string 'MAX_ENTRIES' and integer 300 as arguments, use the string 'max_entries' and previous result as the arguments for the call to the params.get method, substitute the result for max_entries.","max_entries = params . get ( 'max_entries' , options . get ( 'MAX_ENTRIES' , 300 ) )"
"try,",try :
"convert max_entries into a string, substitute it for self._max_entries.",self . _max_entries = int ( max_entries )
"if ValueError or TypeError exceptions occurred,","except ( ValueError , TypeError ) :"
self._max_entries is integer 300.,self . _max_entries = 300
"call the options.get method with string 'CULL_FREQUENCY' and integer 3 as arguments, use the string 'cull_frequency' and previous result as the arguments for the call to the params.get method, substitute the result for cull_frequency.","cull_frequency = params . get ( 'cull_frequency' , options . get ( 'CULL_FREQUENCY' , 3 ) )"
"try,",try :
convert cull_frequency into an integer and substitute it for self._cull_frequency.,self . _cull_frequency = int ( cull_frequency )
"if ValueError or TypeError exceptions occurred,","except ( ValueError , TypeError ) :"
self._cull_frequency is integer 3.,self . _cull_frequency = 3
"call the params.get method with string 'KEY_PREFIX' and an empty string as arguments, substitute the result for self._key_prefix.","self . key_prefix = params . get ( 'KEY_PREFIX' , '' )"
"call the params.get method wit string 'VERSION' and integer 1 as arguments, substitute the result for self.version.","self . version = params . get ( 'VERSION' , 1 )"
"call the method params.get with 2 arguments, string 'KEY_FUNCTION' and None, use the result as the argument for the call to the function get_key_func, substitute the result for the self.key_func.","self . key_func = get_key_func ( params . get ( 'KEY_FUNCTION' , None ) )"
"define the method get_backend_timeout with self class instance and timeout set to DEFAULT_TIMEOUT as arguments,","def get_backend_timeout ( self , timeout = DEFAULT_TIMEOUT ) :"
"if timeout equals to DEFAULT_TIMEOUT,",if timeout == DEFAULT_TIMEOUT :
substitute self.default_timeout for timeout.,timeout = self . default_timeout
"else if timeout equals to integer 0,",elif timeout == 0 :
timeout is a integer -1.,timeout = - 1
"if timeouts is None return None, otherwise return the sum of function time.time return value and timeout.",return None if timeout is None else time . time ( ) + timeout
"define the function make_key with self class instance, key and version set to None as arguments.","def make_key ( self , key , version = None ) :"
"if version is None,",if version is None :
substitute self.version for version.,version = self . version
"call the method self.key_function with key, self.key_prefix and version as arguments, substitute the result for new_key.","new_key = self . key_func ( key , self . key_prefix , version )"
return new_key.,return new_key
"define the method add with 5 arguments, self, key, value, timeout defaulting to DEFAULT_TIMEOUT and version defaulting to None.","def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :"
docsring,""""""" Set a value in the cache if the key does not already exist. If timeout is given, that timeout will be used for the key; otherwise the default cache timeout will be used. Returns True if the value was stored, False otherwise. """""""
raise an exception of class NotImplementedError with string 'subclasses of BaseCache must provide an add() method' as argument.,raise NotImplementedError ( 'subclasses of BaseCache must provide an add() method' )
"define the method get with 4 arguments, self, key, default set to None and version set to None.","def get ( self , key , default = None , version = None ) :"
"raise an exception of class NotImplementedError, with string 'subclasses of BaseCache must provide a get() method' as argument.",raise NotImplementedError ( 'subclasses of BaseCache must provide a get() method' )
"define the method set with 5 arguments, self, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.","def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :"
"raise an exception of class NotImplementedError, with string 'subclasses of BaseCache must provide a set() method' as argument.",raise NotImplementedError ( 'subclasses of BaseCache must provide a set() method' )
"define delete method with self class instance, key and version set to None, as arguments.","def delete ( self , key , version = None ) :"
"raise an exception of class NotImplementedError, with string 'subclasses of BaseCache must provide a delete() method' as argument.",raise NotImplementedError ( 'subclasses of BaseCache must provide a delete() method' )
"define the get_many method with self class instance, keys and version set to None as arguments.","def get_many ( self , keys , version = None ) :"
d is an empty dictionary.,d = { }
"for every k in keys,",for k in keys :
"call the self.get method with k and version set to version as arguments, substitute the result for val.","val = self . get ( k , version = version )"
"if val is not None,",if val is not None :
substitute val for value under the k key of dictionary d.,d [ k ] = val
return d.,return d
"define method has_key with self class instance, key and version set to None as arguments.","def has_key ( self , key , version = None ) :"
"call the self.get method with key and version set to version as arguments, return it if it is not None.","return self . get ( key , version = version ) is not None"
"define the method incr with 4 arguments, self class instance, key, delta defaulting to integer 1 and version defaulting to None.","def incr ( self , key , delta = 1 , version = None ) :"
"call the method self.get with key and version set to version as arguments, substitute the result for value.","value = self . get ( key , version = version )"
"if value is None,",if value is None :
"raise an exception of class ValueError, with string ""Key '%s' not found"" as argument, where '%s' is substituted for key.","raise ValueError ( ""Key '%s' not found"" % key )"
"add value and delta together, substitute the result for new_value.",new_value = value + delta
"call the self.set method with key, new_value and version set to version as arguments.","self . set ( key , new_value , version = version )"
return new_value.,return new_value
"define the method decr with arguments self, key, delta defaulting to integer 1 and version defaulting to None.","def decr ( self , key , delta = 1 , version = None ) :"
"call the self.incr method with key, negative delta and version set to version as arguments.","return self . incr ( key , - delta , version = version )"
define the private method __contains__ with self class instance and key as arguments.,"def __contains__ ( self , key ) :"
"evaluate the self.has_key method with key as argument, return the result.",return self . has_key ( key )
"define the method set_many with arguments, self, data, timeout defaulting to DEFAULT_TIMEOUT and version set to None.","def set_many ( self , data , timeout = DEFAULT_TIMEOUT , version = None ) :"
"for every key and value in data.items method return value,","for key , value in data . items ( ) :"
"call the method self.set with arguments key, value, timeout set to timeout, version set to version.","self . set ( key , value , timeout = timeout , version = version )"
"define the method delete_many with arguments self, keys and version defaulting to None.","def delete_many ( self , keys , version = None ) :"
"for every key in keys,",for key in keys :
call the delete method with key and version set to version as arguments.,"self . delete ( key , version = version )"
"define the method clear with self class instance as the argument,",def clear ( self ) :
raise an exception NotImplementedError with string 'subclasses of BaseCache must provide a clear() method' as argument.,raise NotImplementedError ( 'subclasses of BaseCache must provide a clear() method' )
define the method validate_key with self class instance and key as arguments.,"def validate_key ( self , key ) :"
"if length of key is greater than MEMCACHE_MAX_KEY_LENGTH,",if len ( key ) > MEMCACHE_MAX_KEY_LENGTH :
"substitute '%s' in string 'Cache key will cause errors if used with memcached: %s (longer than %s)' with key,","warnings . warn ( 'Cache key will cause errors if used with memcached: ' '%s (longer than %s)' % ( key , MEMCACHE_MAX_KEY_LENGTH ) , CacheKeyWarning )"
"and MEMCACHE_MAX_KEY_LENGTH, call the function warnings.warn with previous string and CacheKeyWarning as arguments. for every char in key,",for char in key :
"if ascii value of char is smaller than integer 33 or is equal to integer 127,",if ord ( char ) < 33 or ord ( char ) == 127 :
"substitute '%r' in string 'Cache key contains characters that will cause errors if used with memcached: %r' with key,","warnings . warn ( 'Cache key contains characters that will cause ' 'errors if used with memcached: %r' % key , CacheKeyWarning )"
"call the function warnings.warn with previous string and CacheKeyWarning as arguments. define the method incr_version with 4 arguments, self, key, delta defaulting to integer 1 and version defaulting to None.","def incr_version ( self , key , delta = 1 , version = None ) :"
"if version is None,",if version is None :
substitute self.version for version.,version = self . version
"call the self.get method with arguments key and version set to version, substitute the result for value.","value = self . get ( key , version = version )"
"if value is None,",if value is None :
"raise an exception of the class ValueError with string ""Key '%s' not found"" as argument, '%s' is substituted for key.","raise ValueError ( ""Key '%s' not found"" % key )"
"call the method self.set with key, value, version incremented by delta, as arguments.","self . set ( key , value , version = version + delta )"
call the self.delete method with key and version set to version as arguments.,"self . delete ( key , version = version )"
"sum version and delta together, return the result.",return version + delta
"define the method decr_version with 4 arguments, self, key, delta defaulting to integer 1 and version defaulting to None.","def decr_version ( self , key , delta = 1 , version = None ) :"
"call the method self.incr_version with key, negative delta and version as arguments.","return self . incr_version ( key , - delta , version )"
"define the close method with 2 arguments, self and dictionary of argument pairs kwargs.","def close ( self , ** kwargs ) :"
docstirng,"""""""Close the cache connection"""""""
do nothing.,pass
import module base64.,import base64
from datetime import datetime into default name space.,from datetime import datetime
"try,",try :
"from django.utils.six.moves import cPickle as pickle, into default namespace.",from django . utils . six . moves import cPickle as pickle
"if ImportError exception occurred,",except ImportError :
import pickle.,import pickle
from django.conf import settings into default name space.,from django . conf import settings
from django.core.cache.backends.base import BaseCache and DEFAULT_TIMEOUT into default name space.,"from django . core . cache . backends . base import BaseCache , DEFAULT_TIMEOUT"
"from django.db import connections, transaction, router and DatabaseError into default name space.","from django . db import connections , transaction , router , DatabaseError"
from django.db.backends.utils import typecast_timestamp into default name space.,from django . db . backends . utils import typecast_timestamp
from django.utils import timezone and six into default name space.,"from django . utils import timezone , six"
from django.utils.encoding import force_bytes into default name space.,from django . utils . encoding import force_bytes
derive class Options from the base class object.,class Options ( object ) :
define the initialization method __init__ with self class instance and table as arguments.,"def __init__ ( self , table ) :"
substitute table for self.db_table.,self . db_table = table
self.app_label is a string 'django_cache'.,self . app_label = 'django_cache'
self.model_name is a string 'cacheentry'.,self . model_name = 'cacheentry'
self.verbose_name is a string 'cache entry'.,self . verbose_name = 'cache entry'
self.verbose_name_plural is a string 'cache entries'.,self . verbose_name_plural = 'cache entries'
self.object_name is a string 'CacheEntry'.,self . object_name = 'CacheEntry'
self.abstract is boolean False.,self . abstract = False
self.managed is boolean True.,self . managed = True
self.proxy is boolean False.,self . proxy = False
derive class BaseDatabaseCache from BaseCache base class.,class BaseDatabaseCache ( BaseCache ) :
"define the initialization method __init__ with self, table and params as arguments.","def __init__ ( self , table , params ) :"
call the BaseCache.__init__ method with self class instance and params as the arguments.,"BaseCache . __init__ ( self , params )"
substitute table for self._table.,self . _table = table
derive CacheEntry class from the object base class.,class CacheEntry ( object ) :
_meta is class Options class instance initialized with table argument.,_meta = Options ( table )
substitute CacheEntry for self.cache_model_class.,self . cache_model_class = CacheEntry
derive DatabaseCache from the BaseDatabaseCache base class.,class DatabaseCache ( BaseDatabaseCache ) :
"define the method get with 4 arguments, self class instance, key, default set to None and version set to None.","def get ( self , key , default = None , version = None ) :"
"call the method self.make_key Whit key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
"call the method router.db_for_read with self.cache_model_class as argument, substitute the result for db.",db = router . db_for_read ( self . cache_model_class )
"call the ops.quote_name method with argument self._table on the value under the db key of connections dictionary, substitute the result for table.",table = connections [ db ] . ops . quote_name ( self . _table )
"call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,",with connections [ db ] . cursor ( ) as cursor :
"call the method cursor.execute with string ""SELECT cache_key, value, expires FROM %s WHERE cache_key = %%s"" as argument,","cursor . execute ( ""SELECT cache_key, value, expires FROM %s "" ""WHERE cache_key = %%s"" % table , [ key ] )"
"substitute the '%s' with table and list containing key, respectively. call the cursor.fetchone method, substitute the result for row.",row = cursor . fetchone ( )
"if row is None,",if row is None :
return default.,return default
"call the timezone.now function, substitute the result for now.",now = timezone . now ( )
substitute third element of row list for expires.,expires = row [ 2 ]
"if features.needs_datetime_string_cast field of the object represented stored under the db key of connections dictionary is true,","if connections [ db ] . features . needs_datetime_string_cast and not isinstance ( expires , datetime ) :"
"and expires is not an instance of datetime. convert expires to a string, use it as argument for the call to the function typecast_timestamp, substitute the result for expires.",expires = typecast_timestamp ( str ( expires ) )
"if expires is lesser than now,",if expires < now :
"call the method router.db_for_write with argument self.cache_model_class, substitute the result for db.",db = router . db_for_write ( self . cache_model_class )
"call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,",with connections [ db ] . cursor ( ) as cursor :
"call the method cursor.execute with string ""DELETE FROM %s WHERE cache_key = %%s"" as argument,","cursor . execute ( ""DELETE FROM %s "" ""WHERE cache_key = %%s"" % table , [ key ] )"
"substitute the '%s' with table and list containing key, respectively. return default.",return default
"call the method ops.process_clob with second element of row as argument, on the object under the db key of connections dictionary, substitute the result for value.",value = connections [ db ] . ops . process_clob ( row [ 1 ] )
"call the function force_bytes with argument value, use the result as an argument for the call to the method base64.b64decode,",return pickle . loads ( base64 . b64decode ( force_bytes ( value ) ) )
"use the result as the argument for the function call to the pickle.loads, return the result. define the method set with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.","def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with key as argument.,self . validate_key ( key )
"call the method self._base_set with string 'set', key, value and timeout as arguments.","self . _base_set ( 'set' , key , value , timeout )"
"define the method add with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.","def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with key as argument.,self . validate_key ( key )
"call the method self._base_set with string 'add', key, value and timeout as arguments, return the result.","return self . _base_set ( 'add' , key , value , timeout )"
"define the protected method _base_set with 4 arguments, self class instance, key, value and timeout set to DEFAULT_TIMEOUT.","def _base_set ( self , mode , key , value , timeout = DEFAULT_TIMEOUT ) :"
"call the method self.get_backend_timeout with argument timeout, substitute the result for timeout.",timeout = self . get_backend_timeout ( timeout )
"call the method router.db_for_write with argument self.cache_model_class, substitute the result for db.",db = router . db_for_write ( self . cache_model_class )
"call the ops.quote_name method with argument self._table on the object under the db key of connections dictionary, substitute the result for table.",table = connections [ db ] . ops . quote_name ( self . _table )
"call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,",with connections [ db ] . cursor ( ) as cursor :
"call the method cursor.execute with string ""SELECT COUNT(*) FROM %s"" as argument, substitute the '%s' with table.","cursor . execute ( ""SELECT COUNT(*) FROM %s"" % table )"
"fetch one record from the database cursor points at, substitute the first element of return value for num.",num = cursor . fetchone ( ) [ 0 ]
"call the timezone.now function, substitute the result for now.",now = timezone . now ( )
"call the function now.replace with microseconds set to integer 0, substitute the result for now.",now = now . replace ( microsecond = 0 )
"if timeout is None,",if timeout is None :
substitute the datetime.max for exp.,exp = datetime . max
"otherwise is settings.USE_TI is true,",elif settings . USE_TZ :
"call the function datetime.utcfromtimestamp with argument timeout, substitute it for exp.",exp = datetime . utcfromtimestamp ( timeout )
"if not,",else :
"call the function datetime.fromtimestamp with argument timeout, substitute it for exp.",exp = datetime . fromtimestamp ( timeout )
"call the exp.replace with microsecond set to integer 0, substitute the result for exp.",exp = exp . replace ( microsecond = 0 )
"if num is greater than self._max_entries,",if num > self . _max_entries :
"call the method self._cull with db, cursor and now as arguments.","self . _cull ( db , cursor , now )"
"call the method pickle.dumps with value and pickle.HIGHEST_PROTOCOL as arguments, substitute it for pickled.","pickled = pickle . dumps ( value , pickle . HIGHEST_PROTOCOL )"
"call the method base64.b64encode with argument pickled, substitute the result for b64encoded.",b64encoded = base64 . b64encode ( pickled )
"if six.PY3 is true,",if six . PY3 :
"call the method b64encoded.decode with string 'latin1' as argument, substitute the result for b64encoded.",b64encoded = b64encoded . decode ( 'latin1' )
"try,",try :
"with return value of the function transaction.atomic with using set to db as arguments, perform the following,",with transaction . atomic ( using = db ) :
"call the method cursor.execute with string ""SELECT cache_key, expires FROM %s WHERE cache_key = %%s"" as argument,","cursor . execute ( ""SELECT cache_key, expires FROM %s "" ""WHERE cache_key = %%s"" % table , [ key ] )"
"substitute the '%s' with table and list containing key, respectively. fetch one entry from the database that cursor points at, substitute it for the result.",result = cursor . fetchone ( )
"if result is true,",if result :
substitute the second element of result for current_expires.,current_expires = result [ 1 ]
if features.needs_datetime_string_cast field of object under the db key of connections dictionary is true and current_expires is not an instance of datetime object.,"if ( connections [ db ] . features . needs_datetime_string_cast and not isinstance ( current_expires , datetime ) ) :"
"convert current_expires to a string, use it as the argument for the call to the function typecast_timestamp, substitute the result for current_expires.",current_expires = typecast_timestamp ( str ( current_expires ) )
"on the object under the db key of connections dictionary call the method ops.value_to_db_datetime with argument exp, substitute the result for the exp.",exp = connections [ db ] . ops . value_to_db_datetime ( exp )
"if mode equals to string 'add' and current_expires is lesser than now, or mode equals to string 'set', and result is true,",if result and ( mode == 'set' or ( mode == 'add' and current_expires < now ) ) :
"call the method cursor.execute with string ""UPDATE %s SET value = %%s, expires = %%s WHERE cache_key = %%s"" as argument,","cursor . execute ( ""UPDATE %s SET value = %%s, expires = %%s "" ""WHERE cache_key = %%s"" % table , [ b64encoded , exp , key ] )"
"substitute the '%s' with table and 3 elements of a list: b64encoded, exp and key, respectively. if not,",else :
"call the method cursor.execute with string ""INSERT INTO %s (cache_key, value, expires) VALUES (%%s, %%s, %%s)"",","cursor . execute ( ""INSERT INTO %s (cache_key, value, expires) "" ""VALUES (%%s, %%s, %%s)"" % table , [ key , b64encoded , exp ] )"
"substitute the '%s' with table and 3 elements of a list: b64encoded, exp and key, respectively. if DatabaseError exception is caught,",except DatabaseError :
return boolean False.,return False
"if not,",else :
return boolean True.,return True
"define the method delete with self class instance, key and version set to None as arguments.","def delete ( self , key , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
"call the method router.db_for_write with argument self.cache_model_class, substitute the result for db.",db = router . db_for_write ( self . cache_model_class )
"call the ops.quote_name method with argument self._table on the object under the db key of connections dictionary, substitute the result for table.",table = connections [ db ] . ops . quote_name ( self . _table )
"call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,",with connections [ db ] . cursor ( ) as cursor :
"call the method cursor.execute with string ""DELETE FROM %s WHERE cache_key = %%s"" as argument,","cursor . execute ( ""DELETE FROM %s WHERE cache_key = %%s"" % table , [ key ] )"
"substitute the '%s' with table and list containing key, respectively. define the method has_key with self class instance, key and version defaulting to None as arguments.","def has_key ( self , key , version = None ) :"
"call the self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
call the self.validate_key method with argument key.,self . validate_key ( key )
"call the method router.db_for_write with argument self.cache_model_class, substitute the result for db.",db = router . db_for_read ( self . cache_model_class )
"call the ops.quote_name method with argument self._table on the object under the db key of connections dictionary, substitute the result for table.",table = connections [ db ] . ops . quote_name ( self . _table )
"if settings.USE_TZ is true,",if settings . USE_TZ :
"call the function datetime.utcnow, substitute the result for now.",now = datetime . utcnow ( )
"if not,",else :
"call the function datetime.now, substitute the result to now.",now = datetime . now ( )
"call the method now.replace with the argument microsecond set to integer 0, substitute the result for now.",now = now . replace ( microsecond = 0 )
"call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,",with connections [ db ] . cursor ( ) as cursor :
"call the method cursor.execute with string ""SELECT cache_key FROM %s WHERE cache_key = %%s and expires > %%s"" as argument,","cursor . execute ( ""SELECT cache_key FROM %s "" ""WHERE cache_key = %%s and expires > %%s"" % table , [ key , connections [ db ] . ops . value_to_db_datetime ( now ) ] )"
"substitute the '%s' with table and list containing return value of the method call ops.value_to_db_datetime with argument now on the object under the db key of connections dictionary, respectively. if exists return next entry from the database that cursor points at.",return cursor . fetchone ( ) is not None
"define the protected method _cull with self class instance, db, cursor and now as arguments.","def _cull ( self , db , cursor , now ) :"
if self._cull_frequency equals to integer 0.,if self . _cull_frequency == 0 :
call the self.clear method.,self . clear ( )
"if not,",else :
"call the method now.replace with argument tzinfo set to None, substitute it for now.",now = now . replace ( tzinfo = None )
"call the ops.quote_name method with argument self._table on the object under the db key of connections dictionary, substitute the result for table.",table = connections [ db ] . ops . quote_name ( self . _table )
"call the method cursor.execute with string ""DELETE FROM %s WHERE expires < %%s"" as argument,","cursor . execute ( ""DELETE FROM %s WHERE expires < %%s"" % table , [ connections [ db ] . ops . value_to_db_datetime ( now ) ] )"
"substitute the '%s' with table and list containing return value of the method call ops.value_to_db_datetime with argument now on the object under the db key of connections dictionary, respectively. call the method cursor.execute with string ""SELECT COUNT(*) FROM %s"" as argument, substitute the '%s' with table.","cursor . execute ( ""SELECT COUNT(*) FROM %s"" % table )"
"fetch next entry for the database that cursor points into, substitute first element of it for num.",num = cursor . fetchone ( ) [ 0 ]
"if num is greater than self._max_entries,",if num > self . _max_entries :
"divide num by self._cull_frequency, floor the result and substitute it for cull_num.",cull_num = num // self . _cull_frequency
"evaluate the method connections[db].ops.cache_key_culling_sql, evaluate the result by table modulus, call the method cursor.execute,","cursor . execute ( connections [ db ] . ops . cache_key_culling_sql ( ) % table , [ cull_num ] )"
"with previous result and list containing cull_num, respectively as arguments. call the method cursor.execute with string ""DELETE FROM %s WHERE cache_key < %%s"" as argument,","cursor . execute ( ""DELETE FROM %s "" ""WHERE cache_key < %%s"" % table , [ cursor . fetchone ( ) [ 0 ] ] )"
"substitute the '%s' with table and list containing first element of cursor.fetchone method, respectively. define the method clear with argument self.",def clear ( self ) :
"call the method router.db_for_write with argument self.cache_model_class, substitute the result for db.",db = router . db_for_write ( self . cache_model_class )
"call the ops.quote_name method with argument self._table on the object under the db key of connections dictionary, substitute the result for table.",table = connections [ db ] . ops . quote_name ( self . _table )
"call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,",with connections [ db ] . cursor ( ) as cursor :
"call the method cursor.execute with string ""DELETE FROM %s"" as argument, substitute the '%s' with table.",cursor . execute ( 'DELETE FROM %s' % table )
derive the class CacheClass from the DatabaseCache base class.,class CacheClass ( DatabaseCache ) :
do nothing.,pass
from django.core.cache.backends.base import BaseCache and DEFAULT_TIMEOUT into default name space.,"from django . core . cache . backends . base import BaseCache , DEFAULT_TIMEOUT"
derive the class DummyCache from the base class BaseCache.,class DummyCache ( BaseCache ) :
"define initialization method __init__ with 4 arguments: self, host, list of arguments args and dictionary of arguments kwargs.","def __init__ ( self , host , * args , ** kwargs ) :"
"call the BaseCache initialization method __init__ with 3 arguments self, list of arguments args and dictionary of arguments kwargs.","BaseCache . __init__ ( self , * args , ** kwargs )"
"define the method add with 5 arguments: self, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.","def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute it for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
return boolean True.,return True
"define the method get with 4 arguments: self, key, default set to None and version set to None.","def get ( self , key , default = None , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute it for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
return default.,return default
"define the method set with 5 arguments: self, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.","def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute it for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
"define the method delete with 3 arguments: self, key, and version set to None.","def delete ( self , key , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute it for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
"define the method get_many with 3 arguments: self, keys, and version set to None.","def get_many ( self , keys , version = None ) :"
return an empty dictionary.,return { }
"define the method has_key with 3 arguments: self, key, and version set to None.","def has_key ( self , key , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute it for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
return boolean False.,return False
"define the method set_many with 4 arguments: self, data, timeout set to DEFAULT_TIMEOUT and version set to None.","def set_many ( self , data , timeout = DEFAULT_TIMEOUT , version = None ) :"
do nothing,pass
"define the method delete_many with 3 arguments: self, keys, and version set to None.","def delete_many ( self , keys , version = None ) :"
do nothing.,pass
define the method clear with argument self.,def clear ( self ) :
do nothing.,pass
derive the class CacheClass from the DummyCache base class.,class CacheClass ( DummyCache ) :
do nothing.,pass
import module errno.,import errno
import module glob.,import glob
import module hashlib.,import hashlib
import module io.,import io
import module os.,import os
import module random.,import random
import module tempfile.,import tempfile
import module time.,import time
import module zlib.,import zlib
from django.core.cache.backends.base import BaseCache and DEFAULT_TIMEOUT into default name space.,"from django . core . cache . backends . base import BaseCache , DEFAULT_TIMEOUT"
from django.core.files.move import file_move_safe into default name space.,from django . core . files . move import file_move_safe
from django.utils.encoding import force_bytes into default name space.,from django . utils . encoding import force_bytes
"try,",try :
from django.utils.six.moves import cPickle as pickle into default name space.,from django . utils . six . moves import cPickle as pickle
"if ImportError exception is caught,",except ImportError :
import pickle.,import pickle
derive the class FileBasedCache from BaseCache base class.,class FileBasedCache ( BaseCache ) :
cache_suffix is a string '.djcache'.,cache_suffix = '.djcache'
"define the initialization method __init__ with arguments: self class instance, dir and params.","def __init__ ( self , dir , params ) :"
call method __init__ with argument params from the base class of the FileBaseCache.,"super ( FileBasedCache , self ) . __init__ ( params )"
"get absolute directory path of dir, substitute it for self._dir.",self . _dir = os . path . abspath ( dir )
call the self._createdir method.,self . _createdir ( )
"define the method add with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.","def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :"
"evaluate method self.has_key with key and version as arguments, if the result is true,","if self . has_key ( key , version ) :"
return boolean False.,return False
"call the method self.set with key, value, timeout and version as arguments.","self . set ( key , value , timeout , version )"
return boolean True.,return True
"define the method get with 5 arguments, self class instance, key, default set to None and version set to None.","def get ( self , key , default = None , version = None ) :"
"call the function self._key_to_file with key and version as arguments, substitute it for fname.","fname = self . _key_to_file ( key , version )"
"if fname file path exists,",if os . path . exists ( fname ) :
"try,",try :
"with return value of the function io.open with fname and string 'rb' as arguments, named as f,","with io . open ( fname , 'rb' ) as f :"
"evaluate self._is_expired method with f as argument, if the result is false,",if not self . _is_expired ( f ) :
"call f.read function, use the result as the argument for zlib.decompress function call, call the pickle.loads function with the previous result as argument, return the result.",return pickle . loads ( zlib . decompress ( f . read ( ) ) )
"if IOError, renamed to e, exception is caught,",except IOError as e :
"if e.errno equals to errno.ENOENT,",if e . errno == errno . ENOENT :
do nothing.,pass
return default.,return default
"define the method set with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.","def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :"
call the self._createdir method.,self . _createdir ( )
"call the function self._key_to_file with key and version as arguments, substitute it for fname.","fname = self . _key_to_file ( key , version )"
call the method self._cull.,self . _cull ( )
"call the method tempfile.mkstemp with dir set to self._dir, substitute result for fd and tmp_path, respectively.","fd , tmp_path = tempfile . mkstemp ( dir = self . _dir )"
renamed is boolean False.,renamed = False
"try,",try :
"with return value of the function io.open with fname and string 'rb' as arguments, named as f,","with io . open ( fd , 'wb' ) as f :"
"call the method self.get_backend_timeout with argument timeout, substitute it for expiry.",expiry = self . get_backend_timeout ( timeout )
"call the function pickle.dumps with expiry and integer -1 as arguments, use the result as the argument for the call to f.write function.","f . write ( pickle . dumps ( expiry , - 1 ) )"
"call the function pickle.dumps with argument value, use the result and integer -1 as arguments for the call to the function zlib.compress, use the result as an argument for the call to the f.write method.","f . write ( zlib . compress ( pickle . dumps ( value ) , - 1 ) )"
"call the function file_move_safe with tmp_path, fname, allow_overwrite set to boolean True as arguments.","file_move_safe ( tmp_path , fname , allow_overwrite = True )"
renamed is boolean True.,renamed = True
"finally perform,",finally :
"if renamed is boolean False,",if not renamed :
remove file tmp_path.,os . remove ( tmp_path )
"define the method delete with self class instance, key and version defaulting to None as arguments.","def delete ( self , key , version = None ) :"
"call the function self._key_to_file with key and version as arguments, use the result as an argument for the call to the self._delete method.","self . _delete ( self . _key_to_file ( key , version ) )"
define the method _delete with self and fname as arguments.,"def _delete ( self , fname ) :"
"if fname doesnt start with self._dir and fname file path doesnt exists,",if not fname . startswith ( self . _dir ) or not os . path . exists ( fname ) :
return nothing.,return
"try,",try :
call the function os.remove with argument fname.,os . remove ( fname )
"if exception OSError, renamed to e, is caught,",except OSError as e :
"if e.errno does not equals to errno.ENOENT,",if e . errno != errno . ENOENT :
raise an exception.,raise
"define the method has_key with self class instance, key and version defaulting to None as arguments.","def has_key ( self , key , version = None ) :"
"call the function self._key_to_file with key and version as arguments, substitute it for fname.","fname = self . _key_to_file ( key , version )"
"if fname file path exists,",if os . path . exists ( fname ) :
"with call to the io.open function with fname and string 'rb' as arguments, renamed to f,","with io . open ( fname , 'rb' ) as f :"
"call the method self._is_expired with argument f, invert the boolean result and return it.",return not self . _is_expired ( f )
return boolean False.,return False
define the method _cull with argument self.,def _cull ( self ) :
"call the self._list_cache_files method, substitute the result for filelist.",filelist = self . _list_cache_files ( )
num_entries is length of filelist.,num_entries = len ( filelist )
"if num_entries is lesser than self._max_entries,",if num_entries < self . _max_entries :
return nothing.,return
if self._cull_frequency equals to integer 0.,if self . _cull_frequency == 0 :
evaluate self.clear method and return the result.,return self . clear ( )
"divide num_entries by self._cull_frequency, convert the result to an integer, call the random.sample function with filelist and previous result as arguments, substitute the result for filelist.","filelist = random . sample ( filelist , int ( num_entries / self . _cull_frequency ) )"
"for every fname in filelist,",for fname in filelist :
call self._delete method with argument fname.,self . _delete ( fname )
define the method _createdir with argument self.,def _createdir ( self ) :
"if self._dir path doesnt exists,",if not os . path . exists ( self . _dir ) :
"try,",try :
call os.makedirs function with self._dir and hexadecimal 0o700 as arguments.,"os . makedirs ( self . _dir , 0o700 )"
"if OSError, renamed to e, exception is caught,",except OSError as e :
"if e.errno is not equal to errno.EEXIST,",if e . errno != errno . EEXIST :
"raise an EnvironmentError exception with string ""Cache directory '%s' does not exist and could not be created"" as argument,","raise EnvironmentError ( ""Cache directory '%s' does not exist "" ""and could not be created'"" % self . _dir )"
"substitute '%s' with self._dir converted to a string. define the method key_to_file with self class instance, key and version defaulting to None as arguments.","def _key_to_file ( self , key , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
"join into a string: md5 hash sum of force_bytes(key) and self.cache_suffix, compose root file path out of self._dir and previous result, return it.","return os . path . join ( self . _dir , '' . join ( [ hashlib . md5 ( force_bytes ( key ) ) . hexdigest ( ) , self . cache_suffix ] ) )"
define the method clear with argument self.,def clear ( self ) :
"if self._dir file path does not exists,",if not os . path . exists ( self . _dir ) :
return nothing.,return
"if fname is contained in self._list_cache_files method return value,",for fname in self . _list_cache_files ( ) :
call the self._delete method with argument fname.,self . _delete ( fname )
define the method _is_expired with self and f as arguments.,"def _is_expired ( self , f ) :"
"call the function pickle.load with argument f, substitute the result for exp.",exp = pickle . load ( f )
"if exp is not None and exp is lesser than return value of the function time.time,",if exp is not None and exp < time . time ( ) :
call close method on a file stream.,f . close ( )
call the self._delete method with argument f.name.,self . _delete ( f . name )
return boolean True.,return True
return boolean False.,return False
define the method _list_cache_files with argument self.,def _list_cache_files ( self ) :
"if self._dir file path does not exists,",if not os . path . exists ( self . _dir ) :
return an empty list.,return [ ]
"for every fname in return value of the glob.glob1 function called with 2 arguments: self._dir and ,","filelist = [ os . path . join ( self . _dir , fname ) for fname in glob . glob1 ( self . _dir , '*%s' % self . cache_suffix ) ]"
"self.cache_suffix converted to a string, appended to the character '*', call os.path.join with self._dir and fname as arguments, filelist is a list containing all the previous results. return filelist.",return filelist
derive the class CacheClass from the base class FileBasedCache.,class CacheClass ( FileBasedCache ) :
do nothing.,pass
import module time.,import time
"try,",try :
from django.utils.six.moves import cPickle as pickle into default name space.,from django . utils . six . moves import cPickle as pickle
"if ImportError exception is caught,",except ImportError :
import pickle.,import pickle
from django.core.cache.backends.base import BaseCache and DEFAULT_TIMEOUT into default name space.,"from django . core . cache . backends . base import BaseCache , DEFAULT_TIMEOUT"
from django.utils.synch import RWLock into default name space.,from django . utils . synch import RWLock
__caches is an empty dictionary.,_caches = { }
__expire_info is an empty dictionary.,_expire_info = { }
__locks is an empty dictionary.,_locks = { }
derive the class LocMemCache from the base class BaseCache.,class LocMemCache ( BaseCache ) :
"define the initialization method __init__ with 3 arguments: self, name and params.","def __init__ ( self , name , params ) :"
call the __init__ method with self and params arguments from the base class BaseCache.,"BaseCache . __init__ ( self , params )"
"call the _caches.setdefault method with name and empty dictionary as arguments, substitute the result for self_cache.","self . _cache = _caches . setdefault ( name , { } )"
"call the _expire_info.setdefault method with name and empty dictionary as arguments, substitute the result for self_expire_info.","self . _expire_info = _expire_info . setdefault ( name , { } )"
"call the _lock.setdefault method with name and RWLock() as arguments, substitute the result for self_lock.","self . _lock = _locks . setdefault ( name , RWLock ( ) )"
"define the method add with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.","def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
call the pickle.dumps function with value and pickle.HIGHEST_PROTOCOL as arguments.,"pickled = pickle . dumps ( value , pickle . HIGHEST_PROTOCOL )"
"call the self._lock.writer method, with the result perform the following,",with self . _lock . writer ( ) :
"evaluate self._has_expired with argument key, if the result is True,",if self . _has_expired ( key ) :
"call the method self._set with key, pickled and timeout as arguments.","self . _set ( key , pickled , timeout )"
return boolean True.,return True
return boolean False.,return False
"define the method get with 4 arguments, self class instance, key, default set to None and version set to None.","def get ( self , key , default = None , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
substitute None for pickled.,pickled = None
"call the self._lock.reader method, with the result perform the following,",with self . _lock . reader ( ) :
"evaluate the method self._has_expired with argument key, if it as False,",if not self . _has_expired ( key ) :
substitute value under the key key of self._cache dictionary for pickled.,pickled = self . _cache [ key ]
if pickled is not None.,if pickled is not None :
"try,",try :
"evaluate pickle.loads with argument pickled, return the result.",return pickle . loads ( pickled )
"if pickle.PickleError exception is caught,",except pickle . PickleError :
return default.,return default
"call the self._lock.writer method, with the result perform the following,",with self . _lock . writer ( ) :
"try,",try :
delete the value under key key of self._cache dictionary.,del self . _cache [ key ]
delete the value under key key of self._expire_info.,del self . _expire_info [ key ]
"if KeyError exception is caught,",except KeyError :
do nothing.,pass
return default.,return default
"define the method _set with 4 arguments, self class instance, key, value and timeout set to DEFAULT_TIMEOUT.","def _set ( self , key , value , timeout = DEFAULT_TIMEOUT ) :"
"if length of self._cache is greater or equal to self._max_entries,",if len ( self . _cache ) >= self . _max_entries :
call the self._cull method.,self . _cull ( )
substitute value for the value under the key key of self._cache dictionary.,self . _cache [ key ] = value
"call the self.get_backend_timeout with argument timeout, substitute it for the value under the key key of self._expire_info dictionary.",self . _expire_info [ key ] = self . get_backend_timeout ( timeout )
"define the method get with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.","def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
"call the function pickle.dumps with value and pickle.HIGHEST_PROTOCOL as the arguments, substitute the result for pickled.","pickled = pickle . dumps ( value , pickle . HIGHEST_PROTOCOL )"
"call the self._lock.writer method, with the result perform the following,",with self . _lock . writer ( ) :
"call the method self._set with key, pickled and timeout as arguments.","self . _set ( key , pickled , timeout )"
"define the method incr with self class instance, key, delta set to integer 1 and version set to None, as arguments.","def incr ( self , key , delta = 1 , version = None ) :"
"call the self.get method with key and version set to version as arguments, substitute the result for value.","value = self . get ( key , version = version )"
"if value is None,",if value is None :
"raise an ValueError exception with string ""Key '%s' not found"" as argument, substitute '%s' with key converted into a string.","raise ValueError ( ""Key '%s' not found"" % key )"
new_value is a sum of value and delta.,new_value = value + delta
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
"call the function pickle.dumps with value and pickle.HIGHEST_PROTOCOL as the arguments, substitute the result for pickled.","pickled = pickle . dumps ( new_value , pickle . HIGHEST_PROTOCOL )"
"call the self._lock.writer method, with the result perform the following,",with self . _lock . writer ( ) :
substitute pickled for value under the key key of self._cache dictionary.,self . _cache [ key ] = pickled
return new_value.,return new_value
"define the method has_key with self class instance, key and version defaulting to None as arguments.","def has_key ( self , key , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
"call the self._lock.reader method, with the result perform the following,",with self . _lock . reader ( ) :
"if call to the _has_expired method with argument key evaluates to boolean False,",if not self . _has_expired ( key ) :
return boolean True.,return True
"call the self._lock.writer method, with the result perform the following,",with self . _lock . writer ( ) :
"try,",try :
delete the value under the key key of self._cache dictionary.,del self . _cache [ key ]
delete the value under the key key of self._expire_info dictionary.,del self . _expire_info [ key ]
"if KeyError exception is caught,",except KeyError :
do nothing.,pass
return boolean False.,return False
define the method _has_expired with self and key as arguments.,"def _has_expired ( self , key ) :"
"call the method self._expire_info.get with key and integer -1 as arguments, substitute the result for exp.","exp = self . _expire_info . get ( key , - 1 )"
"if exp is None or exp is greater than the return value of the call to the function time.time,",if exp is None or exp > time . time ( ) :
return boolean False.,return False
return boolean True.,return True
define the method _cull with argument self.,def _cull ( self ) :
if self._cull_frequency equals to integer 0.,if self . _cull_frequency == 0 :
call self.clear method.,self . clear ( )
"if not,",else :
"for every i and k in enumerated values of self._cache, if i is divisible by self._cull_frequency, append k to doomed list.","doomed = [ k for ( i , k ) in enumerate ( self . _cache ) if i % self . _cull_frequency == 0 ]"
"for every k in doomed,",for k in doomed :
call the method self._delete with argument k.,self . _delete ( k )
define the method _delete with arguments self and key.,"def _delete ( self , key ) :"
"try,",try :
delete the value under the key key of self._cache dictionary.,del self . _cache [ key ]
"if KeyError exception is caught,",except KeyError :
do nothing.,pass
"try,",try :
delete the value under the key key of the self._expire_info dictionary.,del self . _expire_info [ key ]
"if KeyError exception is caught,",except KeyError :
do nothing.,pass
"define the method delete with self class instance, key and version defaulting to None as arguments.","def delete ( self , key , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
call the method self.validate_key with argument key.,self . validate_key ( key )
"call the self._lock.writer method, with the result perform the following,",with self . _lock . writer ( ) :
call the method self._delete with argument key.,self . _delete ( key )
define the method clear with argument self.,def clear ( self ) :
call the method self._cache.clear.,self . _cache . clear ( )
call the method self._expire_info.clear.,self . _expire_info . clear ( )
derive the class CacheClass from the base class LocMemCache.,class CacheClass ( LocMemCache ) :
do nothing.,pass
import module time.,import time
import module pickle.,import pickle
from django.core.cache.backends.base import BaseCache and DEFAULT_TIMEOUT into default name space.,"from django . core . cache . backends . base import BaseCache , DEFAULT_TIMEOUT"
from django.utils import six into default name space.,from django . utils import six
from django.utils.deprecation import RenameMethodsBase and RemovedInDjango19Warning into default name space.,"from django . utils . deprecation import RenameMethodsBase , RemovedInDjango19Warning"
from django.utils.encoding import force_str into default name space.,from django . utils . encoding import force_str
from django.utils.functional import cached_property into default name space.,from django . utils . functional import cached_property
derive the class BaseMemcachedCacheMethods from RenameMethodsBase the base class.,class BaseMemcachedCacheMethods ( RenameMethodsBase ) :
"renamed methods is a tuple containing 3 elements: '_get_memcache_timeout', 'get_backend_timeout' and RemovedInDjango19Warning.","renamed_methods = ( ( '_get_memcache_timeout' , 'get_backend_timeout' , RemovedInDjango19Warning ) , )"
derive the class BaseMemcachedCache from base class BaseMemcachedCacheMethods and BaseCache.,"class BaseMemcachedCache ( six . with_metaclass ( BaseMemcachedCacheMethods , BaseCache ) ) :"
"define the method __init__ with, self, server, params, library, value_not_found_exception as arguments.","def __init__ ( self , server , params , library , value_not_found_exception ) :"
call the initialization method with argument params for the base class of the BaseMemcachedCache class.,"super ( BaseMemcachedCache , self ) . __init__ ( params )"
"if server is an instance of six.string_types,","if isinstance ( server , six . string_types ) :"
"split server with ';' as delimiter, substitute the result for self._servers.",self . _servers = server . split ( ';' )
"if not,",else :
substitute server for self._servers.,self . _servers = server
substitute value_not_found_exception for self.LibraryValueNotFoundException.,self . LibraryValueNotFoundException = value_not_found_exception
substitute library for self._lib.,self . _lib = library
"call the params.get function with string 'OPTIONS' and None as arguments, substitute the result for self._options.","self . _options = params . get ( 'OPTIONS' , None )"
"property decorator,",@ property
define the method _cache with argument self.,def _cache ( self ) :
"if self object has an attribute '_client',","if getattr ( self , '_client' , None ) is None :"
"call the self._lib.Client with argument self._servers, substitute the result for self._client.",self . _client = self . _lib . Client ( self . _servers )
return self._client.,return self . _client
define the method get_backend_timeout with self and timeout set to DEFAULT_TIMEOUT as arguments.,"def get_backend_timeout ( self , timeout = DEFAULT_TIMEOUT ) :"
"if timeout equals to DEFAULT_TIMEOUT,",if timeout == DEFAULT_TIMEOUT :
substitute self.default_timeout for timeout.,timeout = self . default_timeout
"if timeout is None,",if timeout is None :
return integer 0.,return 0
"else if timeout converted into an integer equals to integer 0,",elif int ( timeout ) == 0 :
timeout is a integer -1.,timeout = - 1
"if timeout is greater than integer 2592000,",if timeout > 2592000 :
"convert return value of the function time.time to an integer, increment timeout by it.",timeout += int ( time . time ( ) )
"convert timeout into an integer, return it.",return int ( timeout )
"define the method make_key with self class instance, key and version defaulting to None as arguments.","def make_key ( self , key , version = None ) :"
"call the method make_key with arguments key and version from the base class of the class BaseMemcachedCache, use it as an argument for the call to the function force_str, return the result.","return force_str ( super ( BaseMemcachedCache , self ) . make_key ( key , version ) )"
"define the method add with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.","def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
"call the method self._cache.add with key, value, self.get_backend_timeout(timeout) as arguments.","return self . _cache . add ( key , value , self . get_backend_timeout ( timeout ) )"
"define the method get with 5 arguments, self class instance, key, default set to None and version set to None.","def get ( self , key , default = None , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
"call the self._cache.get method with argument key, substitute the result for val.",val = self . _cache . get ( key )
"if val is None,",if val is None :
return default.,return default
return val.,return val
"define the method set with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.","def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
"call the method self._cache.set with key, value, self.get_backend_timeout(timeout) as arguments.","self . _cache . set ( key , value , self . get_backend_timeout ( timeout ) )"
"define the method delete with self, key and version set to None as arguments.","def delete ( self , key , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
call the method self._cache.delete with argument key.,self . _cache . delete ( key )
"define the method get_many with self class instance, keys and version defaulting to None as arguments.","def get_many ( self , keys , version = None ) :"
"define the method get_many with 3 arguments, self class instance, keys and version set to None.","new_keys = [ self . make_key ( x , version = version ) for x in keys ]"
"call the method self._cache.get_multi with argument new_keys, substitute the result for ret.",ret = self . _cache . get_multi ( new_keys )
if ret is true.,if ret :
_ is an empty dictionary.,_ = { }
"zip together new_keys and keys, convert it to dictionary, assign it to m.","m = dict ( zip ( new_keys , keys ) )"
"for every k and v in return value of the ret.items function,","for k , v in ret . items ( ) :"
substitute v for value under the k-th element of m key of _ dictionary.,_ [ m [ k ] ] = v
substitute _ for ret.,ret = _
return ret.,return ret
define the method close with self and dictionary pairs of elements kwargs.,"def close ( self , ** kwargs ) :"
call the method self._cache.disconnect_all.,self . _cache . disconnect_all ( )
"define the method incr with self, key, delta defaulting to integer 1 and version defaulting to None as arguments.","def incr ( self , key , delta = 1 , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
"if delta is smaller than integer 0,",if delta < 0 :
"evaluate the method self._cache.decr with key and negative delta as arguments, return the result.","return self . _cache . decr ( key , - delta )"
"try,",try :
"call the method self._cache.incr with key and delta as arguments, substitute the result for val.","val = self . _cache . incr ( key , delta )"
"if self.LibraryValueNotFoundException exception is caught,",except self . LibraryValueNotFoundException :
val is None.,val = None
"if val is None,",if val is None :
"raise an ValueError exception with string ""Key '%s' not found"" as argument, substitute '%s' for key.","raise ValueError ( ""Key '%s' not found"" % key )"
return val.,return val
"define the method decr with self, key, delta defaulting to integer 1 and version defaulting to None as arguments.","def decr ( self , key , delta = 1 , version = None ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
if delta is smaller than integer 0.,if delta < 0 :
"evaluate the method self._cache.incr with key and negative delta as arguments, return the result.","return self . _cache . incr ( key , - delta )"
"try,",try :
"call the method self._cache.decr with key and delta as arguments, substitute the result for val.","val = self . _cache . decr ( key , delta )"
"if self.LibraryValueNotFoundException exception is caught,",except self . LibraryValueNotFoundException :
val is None.,val = None
"if val is None,",if val is None :
"raise an ValueError exception with string ""Key '%s' not found"" as argument, substitute '%s' for key.","raise ValueError ( ""Key '%s' not found"" % key )"
return val.,return val
"define the method set_many with self, data, timeout set to DEFAULT_TIMEOUT and version set to None as arguments.","def set_many ( self , data , timeout = DEFAULT_TIMEOUT , version = None ) :"
safe_data is an empty dictionary.,safe_data = { }
"for every key and value in data.items function return value,","for key , value in data . items ( ) :"
"call the method self.make_key with key and version set to version as arguments, substitute the result for key.","key = self . make_key ( key , version = version )"
substitute value for value under the key key of safe_data dictionary.,safe_data [ key ] = value
"call the method self._cache.set_multi with safe_data, self.get_backend_timeout(timeout) as arguments.","self . _cache . set_multi ( safe_data , self . get_backend_timeout ( timeout ) )"
"define the function delete_many with self, keys and version set to None as arguments.","def delete_many ( self , keys , version = None ) :"
"l is lambda function with argument x, that calls the method self.make_key with x and version set to version as arguments.","l = lambda x : self . make_key ( x , version = version )"
call the method self_cache.delete_multi with argument list containing keys mapped through function l.,"self . _cache . delete_multi ( map ( l , keys ) )"
define the method clear with argument self.,def clear ( self ) :
call the method self._cache_flush_all.,self . _cache . flush_all ( )
derive the class MemcachedCache from the BaseMemcachedCache base class.,class MemcachedCache ( BaseMemcachedCache ) :
"define the method __init__ with argument self, server and params.","def __init__ ( self , server , params ) :"
import memcache.,import memcache
"call method __init__ from the base class of the class MemcachedCache with arguments: server, params,","super ( MemcachedCache , self ) . __init__ ( server , params , library = memcache , value_not_found_exception = ValueError )"
"library set to memcache and value_not_found_exception set to ValueError. property decorator,",@ property
define the method _cache with self class instance as an argument.,def _cache ( self ) :
"if attribute '_client' of the self object is None,","if getattr ( self , '_client' , None ) is None :"
"call the method self._lib.Client with self._servers and pickleProtocol set to pickle.HIGHEST_PROTOCOL as arguments, substitute the result for self._client.","self . _client = self . _lib . Client ( self . _servers , pickleProtocol = pickle . HIGHEST_PROTOCOL )"
return self._client.,return self . _client
derive the class PyLibMCCache from BaseMemcachedCache base class.,class PyLibMCCache ( BaseMemcachedCache ) :
"define the method __init__ with self, server and params as arguments.","def __init__ ( self , server , params ) :"
import pylibmc.,import pylibmc
"call method __init__ from the base class of the class PyLibMCCache with arguments: server, params,","super ( PyLibMCCache , self ) . __init__ ( server , params , library = pylibmc , value_not_found_exception = pylibmc . NotFound )"
"library set to pylibmc and value_not_found_exception set to pylibmc.NotFound. decorator cached_property,",@ cached_property
define the method _cache with argument self.,def _cache ( self ) :
call the method self._lib.Client with argument self._servers.,client = self . _lib . Client ( self . _servers )
"if self._options exists,",if self . _options :
substitute self._options for client.behaviors.,client . behaviors = self . _options
return client.,return client
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
import module hashlib.,import hashlib
from django.utils.encoding import force_bytes into default name space.,from django . utils . encoding import force_bytes
from django.utils.http import urlquote into default name space.,from django . utils . http import urlquote
TEMPLATE_FRAGMENT_KEY_TEMPLATE is a string 'template.cache.%s.%s'.,TEMPLATE_FRAGMENT_KEY_TEMPLATE = 'template.cache.%s.%s'
define the function make_template_fragment_key with fragment_name and vary_on defaulting to None as arguments.,"def make_template_fragment_key ( fragment_name , vary_on = None ) :"
"if vary_on is None,",if vary_on is None :
vary_on is an empty tuple.,vary_on = ( )
"call the function urlquote with argument var for every var in vary_on, join the results into a string separated by ':', substitute it for key.",key = ':' . join ( urlquote ( var ) for var in vary_on )
call the hashlib.md5 fuction with force_bytes(key) as argument.,args = hashlib . md5 ( force_bytes ( key ) )
"substitute '%s' in TEMPLATE_FRAGMENT_KEY_TEMPLATE string with fragment_name and args.hexdigest(), respectively, return the result.","return TEMPLATE_FRAGMENT_KEY_TEMPLATE % ( fragment_name , args . hexdigest ( ) )"
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
"from .messages import CheckMessage, Debug, Info, Warning, Error, Critical, DEBUG, INFO, WARNING, ERROR and CRITICAL into default name space.","from . messages import ( CheckMessage , Debug , Info , Warning , Error , Critical , DEBUG , INFO , WARNING , ERROR , CRITICAL )"
"from .registry import register, run_checks, tag_exists and Tags into default name space.","from . registry import register , run_checks , tag_exists , Tags"
import module django.core.checks.compatibility.django_1_6_0.,import django . core . checks . compatibility . django_1_6_0
import module django.core.checks.compatibility.django_1_7_0.,import django . core . checks . compatibility . django_1_7_0
import module django.core.checks.model_checks.,import django . core . checks . model_checks
"__all__ is a list containing next strings, 'CheckMessage', 'Debug', 'Info', 'Warning', 'Error', 'Critical',","__all__ = [ 'CheckMessage' , 'Debug' , 'Info' , 'Warning' , 'Error' , 'Critical' , 'DEBUG' , 'INFO' , 'WARNING' , 'ERROR' , 'CRITICAL' , 'register' , 'run_checks' , 'tag_exists' , 'Tags' , ]"
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
from django.apps import apps into default name space.,from django . apps import apps
"from .. import Warning, register and Tags into default name space.","from . . import Warning , register , Tags"
decorator register with argument Tags.compatibility.,@ register ( Tags . compatibility )
define the function check_1_6_compatibility with argument kwargs dictionary.,def check_1_6_compatibility ( ** kwargs ) :
errors is an empty list,errors = [ ]
"call the function _check_test_runner with dictionary kwargs as argument, use the result as an argument for the call to the function errors.extend.",errors . extend ( _check_test_runner ( ** kwargs ) )
"call the function _check_boolean_field_default_value with dictionary kwargs as argument, use the result as an argument for the call to the function errors.extend.",errors . extend ( _check_boolean_field_default_value ( ** kwargs ) )
return errors.,return errors
define the function _check_test_runner with app_config set to None and kwargs dictionary as arguments.,"def _check_test_runner ( app_configs = None , ** kwargs ) :"
from django.conf import settings into default name space.,from django . conf import settings
weight is an integer 0.,weight = 0
if call to the settings.is_overridden with string 'TEST_RUNNER' evaluates to boolean False.,if not settings . is_overridden ( 'TEST_RUNNER' ) :
"try,",try :
settings.SITE_ID.,settings . SITE_ID
increment weight by integer 2.,weight += 2
"if AttributeError exception is caught,",except AttributeError :
do nothing.,pass
"try,",try :
settings.BASE_DIR.,settings . BASE_DIR
"if AttributeError exception is caught,",except AttributeError :
increment weight by integer 2.,weight += 2
"call the function settings.is_overridden with argument string 'TEMPLATE_LOADERS', if it evaluates to boolean True,",if settings . is_overridden ( 'TEMPLATE_LOADERS' ) :
increment weight by integer 2.,weight += 2
"call the function settings.is_overridden with argument string 'MANAGERS', if it evaluates to boolean True,",if settings . is_overridden ( 'MANAGERS' ) :
increment weight by integer 2.,weight += 2
"call the function settings.is_overridden with argument string 'ADMINS', if it evaluates to boolean True,",if settings . is_overridden ( 'ADMINS' ) :
increment weight by integer 2.,weight += 1
"if string 'django.middleware.clickjacking.XFrameOptionsMiddleware' is not contained in settings.MIDDLEWARE_CLASSES set,",if 'django.middleware.clickjacking.XFrameOptionsMiddleware' not in set ( settings . MIDDLEWARE_CLASSES ) :
increment weight by integer 2.,weight += 1
"if weight is greater or equal to integer 6,",if weight >= 6 :
"call the Warning function with 3 arguments: hint tuple containing one string, Django 1.6 introduced a new default test runner.","return [ Warning ( ""Some project unittests may not execute as expected."" , hint = ( ""Django 1.6 introduced a new default test runner. It looks like "" ""this project was generated using Django 1.5 or earlier. You should "" ""ensure your tests are all running & behaving as expected. See "" ""https://docs.djangoproject.com/en/dev/releases/1.6/#new-test-runner "" ""for more information."" ) , obj = None , id = '1_6.W001' , ) ]"
"It looks like this project was generated using Django 1.5 or earlier. You should ensure your tests are all running & behaving as expected. See https://docs.djangoproject.com/en/dev/releases/1.6/#new-test-runner for more information."", obj set to None and id set to a string '1_6.W001', put the result into a list and return it. if not,",else :
return an empty list.,return [ ]
define the function _check_boolean_field_default_value with app_config set to None and kwargs dictionary as arguments.,"def _check_boolean_field_default_value ( app_configs = None , ** kwargs ) :"
from django.db import models into default name space.,from django . db import models
"append field to problem_fields list for every model in apps.get_models with argument kwargs dictionary, only if app_configs is None,","problem_fields = [ field for model in apps . get_models ( ** kwargs ) if app_configs is None or model . _meta . app_config in app_configs for field in model . _meta . local_fields if isinstance ( field , models . BooleanField ) and not field . has_default ( ) ]"
"or model._meta.app_config is contained in app_configs, for every field in model._meta.local_fields, #ANNOTATION only if field is an instance of models.BooleanField and field.has_default() evaluates to False. call the Warning function with 4 arguments: string ""BooleanField does not have a default value."",","return [ Warning ( ""BooleanField does not have a default value."" , hint = ( ""Django 1.6 changed the default value of BooleanField from False to None. "" ""See https://docs.djangoproject.com/en/1.6/ref/models/fields/#booleanfield "" ""for more information."" ) , obj = field , id = '1_6.W002' , ) for field in problem_fields ]"
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
"from .. import Warning, register and Tags into default name space.","from . . import Warning , register , Tags"
decorator register with argument Tags.compatibility.,@ register ( Tags . compatibility )
define the function check_1_7_compatibility with argument kwargs dictionary.,def check_1_7_compatibility ( ** kwargs ) :
errors is an empty list.,errors = [ ]
"call the function _check_middleware_classes with dictionary kwargs as argument, use the result as an argument for the call to the function errors.extend.",errors . extend ( _check_middleware_classes ( ** kwargs ) )
return errors.,return errors
define the function _check_middleware_classes with app_config set to None and kwargs dictionary as arguments.,"def _check_middleware_classes ( app_configs = None , ** kwargs ) :"
from django.conf import settings into default name space.,from django . conf import settings
"call the function settings.is_overridden with argument string 'MIDDLEWARE_CLASSES', if the result is boolean False,",if not settings . is_overridden ( 'MIDDLEWARE_CLASSES' ) :
"call the Warning function with 4 arguments: string ""MIDDLEWARE_CLASSES is not set."", hint tuple containing one string,","return [ Warning ( ""MIDDLEWARE_CLASSES is not set."" , hint = ( ""Django 1.7 changed the global defaults for the MIDDLEWARE_CLASSES. "" ""django.contrib.sessions.middleware.SessionMiddleware, "" ""django.contrib.auth.middleware.AuthenticationMiddleware, and "" ""django.contrib.messages.middleware.MessageMiddleware were removed from the defaults. "" ""If your project needs these middleware then you should configure this setting."" ) , obj = None , id = '1_7.W001' , ) ]"
"""Django 1.7 changed the global defaults for the MIDDLEWARE_CLASSES. django.contrib.sessions.middleware.SessionMiddleware, django.contrib.auth.middleware.AuthenticationMiddleware, and django.contrib.messages.middleware.MessageMiddleware were removed from the defaults. If your project needs these middleware then you should configure this setting."", obj set to None, and id set to a string '1_7.W001', put the result into a list and return it. if not,",else :
return an empty list.,return [ ]
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
from django.utils.encoding import python_2_unicode_compatible and force_st into default name space.,"from django . utils . encoding import python_2_unicode_compatible , force_str"
DEBUG is integer 10.,DEBUG = 10
INFO is integer 20.,INFO = 20
WARNING is integer 30.,WARNING = 30
ERROR is integer 40.,ERROR = 40
CRITICAL is integer 50.,CRITICAL = 50
decorator python_2_unicode_compatible.,@ python_2_unicode_compatible
derive class CheckMessage from object base class.,class CheckMessage ( object ) :
"define initialization method __init__ with self class instance, level, msg, hint defaulting to None, obj defaulting to None and if defaulting to None as arguments.","def __init__ ( self , level , msg , hint = None , obj = None , id = None ) :"
"if level is not an integer raise an error with message string ""The first argument should be level."".","assert isinstance ( level , int ) , ""The first argument should be level."""
substitute level for self.level.,self . level = level
substitute msg for self.msg.,self . msg = msg
substitute hint for self.hint.,self . hint = hint
substitute obj for self.obj.,self . obj = obj
substitute id for self.id.,self . id = id
define private method __eq__ with self class instance and other as arguments.,"def __eq__ ( self , other ) :"
"if for all attr in list of attributes 'level', 'msg', 'hint', 'obj' and 'id', self and other have the same attribute attr,","return all ( getattr ( self , attr ) == getattr ( other , attr ) for attr in [ 'level' , 'msg' , 'hint' , 'obj' , 'id' ] )"
"return boolean True, otherwise return boolean False. define private method __ne__ with self class instance and other as arguments.","def __ne__ ( self , other ) :"
"if self equals to other return boolean False, otherwise return True.",return not ( self == other )
define private method __str__ with argument self.,def __str__ ( self ) :
from django.db import models into default name space.,from django . db import models
"if self.obj is None,",if self . obj is None :
"obj is a string ""?"".","obj = ""?"""
"otherwise if self.object is an instance of the models.base.ModelBase class,","elif isinstance ( self . obj , models . base . ModelBase ) :"
substitute self.obj for model.,model = self . obj
substitute model._meta.app_label for app.,app = model . _meta . app_label
"convert app and model._meta.object_name to strings, join them with separating '.' character, substitute it for obj.","obj = '%s.%s' % ( app , model . _meta . object_name )"
"if not,",else :
"call the function force_str with argument self.obj, substitute the result for obj.",obj = force_str ( self . obj )
"if self.id exists, convert self.id to a string, surround it with round brackets, substitute id for it, otherwise id is an empty string.","id = ""(%s) "" % self . id if self . id else """""
"if self.hint exists, replace '%s' in a string ""\n\tHINT: %s"" with value of self.hint, substitute it for hint, otherwise hint is an empty string.","hint = ""\n\tHINT: %s"" % self . hint if self . hint else ''"
"replace all '%s' from string ""%s: %s%s%s"" with values of obj, id, self.msg and hint, respectively, return the result.","return ""%s: %s%s%s"" % ( obj , id , self . msg , hint )"
define private method __repr__ with argument self.,def __repr__ ( self ) :
"in the string ""<%s: level=%r, msg=%r, hint=%r, obj=%r, id=%r>"", replace '%s' with the name of the type of this class instance,","return ""<%s: level=%r, msg=%r, hint=%r, obj=%r, id=%r>"" % ( self . __class__ . __name__ , self . level , self . msg , self . hint , self . obj , self . id )"
"replace all the '%r' with self.level, self.msg, self.hint. self.obj and self.id, respectively, return the result. define the method is_serious with argument self.",def is_serious ( self ) :
"return boolean True if self.level is greater than or equals to ERROR, otherwise return boolean False.",return self . level >= ERROR
define the method is_silence with argument self.,def is_silenced ( self ) :
from django.conf import settings into default name space.,from django . conf import settings
"if self.id is contained in settings.SILENCED_SYSTEM_CHECKS return boolean True, False otherwise.",return self . id in settings . SILENCED_SYSTEM_CHECKS
derive the class Debug from base class CheckMessage.,class Debug ( CheckMessage ) :
"define initialization method __init__ with self class instance, unpacked list args, unpacked dictionary kwargs as arguments.","def __init__ ( self , * args , ** kwargs ) :"
"call the __init__ method with 3 arguments: DEBUG, unpacked list args and unpacked dictionary kwargs from the base class of Debug.","return super ( Debug , self ) . __init__ ( DEBUG , * args , ** kwargs )"
derive the class Info from base class CheckMessage.,class Info ( CheckMessage ) :
"define initialization method __init__ with self class instance, unpacked list args, unpacked dictionary kwargs as arguments.","def __init__ ( self , * args , ** kwargs ) :"
"call the __init__ method with 3 arguments: INFO, unpacked list args and unpacked dictionary kwargs from the base class of Info.","return super ( Info , self ) . __init__ ( INFO , * args , ** kwargs )"
derive the class Warning from base class CheckMessage.,class Warning ( CheckMessage ) :
"define initialization method __init__ with self class instance, unpacked list args, unpacked dictionary kwargs as arguments.","def __init__ ( self , * args , ** kwargs ) :"
"call the __init__ method with 3 arguments: WARNING, unpacked list args and unpacked dictionary kwargs from the base class of Warning.","return super ( Warning , self ) . __init__ ( WARNING , * args , ** kwargs )"
derive the class Error from base class CheckMessage.,class Error ( CheckMessage ) :
"define initialization method __init__ with self class instance, unpacked list args, unpacked dictionary kwargs as arguments.","def __init__ ( self , * args , ** kwargs ) :"
"call the __init__ method with 3 arguments: ERROR, unpacked list args and unpacked dictionary kwargs from the base class of Error.","return super ( Error , self ) . __init__ ( ERROR , * args , ** kwargs )"
derive the class Critical from base class CheckMessage.,class Critical ( CheckMessage ) :
"define initialization method __init__ with self class instance, unpacked list args, unpacked dictionary kwargs as arguments.","def __init__ ( self , * args , ** kwargs ) :"
"call the __init__ method with 3 arguments: CRITICAL, unpacked list args and unpacked dictionary kwargs from the base class of Critical.","return super ( Critical , self ) . __init__ ( CRITICAL , * args , ** kwargs )"
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
from itertools import chain into default name space.,from itertools import chain
import module types.,import types
from django.apps import apps into default name space.,from django . apps import apps
"from . import Error, Tags and register into default name space.","from . import Error , Tags , register"
decorator register with Tags.models as an argument.,@ register ( Tags . models )
define the function check_all_models with app_configs defaulting to None and unpacked dictionary kwargs as arguments.,"def check_all_models ( app_configs = None , ** kwargs ) :"
"call the model.check method with unpacked dictionary kwargs for every model in return value of function apps.get_models,",errors = [ model . check ( ** kwargs ) for model in apps . get_models ( ) if app_configs is None or model . _meta . app_config in app_configs ]
"only if app_configs is None ot model._meta.app_config is contained in app_configs, error is a list containing all the previous elements. chain all errors elements into a list, return it.",return list ( chain ( * errors ) )
decorator register with Tags.models and Tags.signals as arguments.,"@ register ( Tags . models , Tags . signals )"
"define the function check_model_signals with app_config defaulting to None and unpacked dictionary kwargs as arguments,","def check_model_signals ( app_configs = None , ** kwargs ) :"
from django.db import models into default name space.,from django . db import models
errors is an empty list.,errors = [ ]
"for name in attributes of models_signals object,",for name in dir ( models . signals ) :
"get models.signals name attribute, store it in obj.","obj = getattr ( models . signals , name )"
"if obj is instance of models.signals.ModelSignal class,","if isinstance ( obj , models . signals . ModelSignal ) :"
"for every reference and receivers in return value of the call of obj.unresolved_references.items method,","for reference , receivers in obj . unresolved_references . items ( ) :"
"for every receiver, _ and _ in receivers,","for receiver , _ , _ in receivers :"
"if receiver is an instance of types.FunctionType type,","if isinstance ( receiver , types . FunctionType ) :"
"description is a string ""The '%s' function"" replaced by value of receiver.__name__.","description = ""The '%s' function"" % receiver . __name__"
"if not,",else :
"description is a string ""An instance of the '%s' class"" with '%s' replaced by value of receiver.__class__.__name__.","description = ""An instance of the '%s' class"" % receiver . __class__ . __name__"
"call the Error function with 4 arguments, string ""%s was connected to the '%s' signal with a lazy reference to the '%s' sender,","errors . append ( Error ( ""%s was connected to the '%s' signal "" ""with a lazy reference to the '%s' sender, "" ""which has not been installed."" % ( description , name , '.' . join ( reference ) ) , obj = receiver . __module__ , hint = None , id = 'signals.E001' ) )"
"which has not been installed."" with all the '%s' replaced by values of description, name and reference joined into a string delimited by '.', respectively, obj set to receiver.__module__, hint set to None and id set to string 'signals.E001', append the result to errors. return errors.",return errors
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
from itertools import chain into default name space.,from itertools import chain
from django.utils.itercompat import is_iterable into default name space.,from django . utils . itercompat import is_iterable
derive the class Tags with base class object.,class Tags ( object ) :
admin is a string 'admin',admin = 'admin'
compatibility is a string 'compatibility'.,compatibility = 'compatibility'
models is a string 'models',models = 'models'
signal is a string 'signals',signals = 'signals'
derive the class CheckRegistry with object as base class.,class CheckRegistry ( object ) :
define initialization method __init__ with argument self.,def __init__ ( self ) :
self.registered_checks is an empty list.,self . registered_checks = [ ]
define the method register with self ans unpacked list tags as arguments.,"def register ( self , * tags ) :"
define the method inner with argument check.,def inner ( check ) :
replace tags for check.tags.,check . tags = tags
if check is not contained in self.registered_checks.,if check not in self . registered_checks :
call the method self.registered_checks.append with argument check.,self . registered_checks . append ( check )
return check.,return check
return inner.,return inner
"define the method run_checks with self class instance, app_configs defaulting to None, tags defaulting to None as argument.","def run_checks ( self , app_configs = None , tags = None ) :"
errors is an empty list.,errors = [ ]
if tags is not None.,if tags is not None :
"append check to checks list, for every check in self.register_checks, if check has an attribute 'tags' and check.tags and tags set intersection is a non empty set.","checks = [ check for check in self . registered_checks if hasattr ( check , 'tags' ) and set ( check . tags ) & set ( tags ) ]"
if not.,else :
substitute self.registered_checks for checks.,checks = self . registered_checks
"for every check in checks,",for check in checks :
"call the check function with argument app_config set to app_config, substitute the result for new_errors.",new_errors = check ( app_configs = app_configs )
"if new_errors is not an iterable object raise an error with error message ""The function %r did not return a list. All functions registered with the checks registry must return a list."", with '%s' replaced by value of check.","assert is_iterable ( new_errors ) , ( ""The function %r did not return a list. All functions registered "" ""with the checks registry must return a list."" % check )"
call the method errors.extend with argument new_errors.,errors . extend ( new_errors )
return errors.,return errors
define the method tag_exists with self class instance and tag as arguments.,"def tag_exists ( self , tag ) :"
"return boolean True if tag is contained in self.tags_available method return value, return False otherwise.",return tag in self . tags_available ( )
define the method tags_available with argument self.,def tags_available ( self ) :
"append check.tags into a list for every check in self.registered_checks if check has 'tags' attribute, put the elements into a set and return it.","return set ( chain ( * [ check . tags for check in self . registered_checks if hasattr ( check , 'tags' ) ] ) )"
"call the function CheckRegistry, substitute the result for registry.",registry = CheckRegistry ( )
substitute registry.register for register.,register = registry . register
substitute registry.run_checks for run_checks.,run_checks = registry . run_checks
substitute registry.tag_exists for tag_exists.,tag_exists = registry . tag_exists
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
from django.conf import settings into default name space.,from django . conf import settings
from django.middleware.csrf import get_token into default name space.,from django . middleware . csrf import get_token
from django.utils import six into default name space.,from django . utils import six
from django.utils.encoding import smart_text into default name space.,from django . utils . encoding import smart_text
from django.utils.functional import lazy into default name space.,from django . utils . functional import lazy
define the function csrf with an argument request.,def csrf ( request ) :
define the function _get_val.,def _get_val ( ) :
"call the function get_token with an argument request, substitute the result for token.",token = get_token ( request )
"if token is None,",if token is None :
return string 'NOTPROVIDED'.,return 'NOTPROVIDED'
"if not,",else :
"call the smart_text function with an argument token, return the result.",return smart_text ( token )
"call the function lazy with arguments _get_val and six.text_type, substitute the result for _get_val.","_get_val = lazy ( _get_val , six . text_type )"
return an dictionary containing 1 entry: return value of the function _get_val for 'csrf_token'.,return { 'csrf_token' : _get_val ( ) }
define the function debug with an argument request.,def debug ( request ) :
context_extras is an empty dictionary.,context_extras = { }
"if settings.DEBUG is true and value of the request.META dictionary under the 'REMOTE_ADDR' key is contained in settings.INTERNAL_IPS,",if settings . DEBUG and request . META . get ( 'REMOTE_ADDR' ) in settings . INTERNAL_IPS :
value under the 'debug' key of the context_extras dictionary is boolean True.,context_extras [ 'debug' ] = True
from django.db import connection into default name space.,from django . db import connection
substitute connection.queries for value under the 'debug' key of the context_extras dictionary.,context_extras [ 'sql_queries' ] = connection . queries
return context_extras.,return context_extras
define the function i18n with an argument request.,def i18n ( request ) :
from django.utils import translation into default name space.,from django . utils import translation
context_extras is an empty dictionary.,context_extras = { }
substitute settings.LANGUAGES for the value under the 'LANGUAGES' key of the context_extras dictionary.,context_extras [ 'LANGUAGES' ] = settings . LANGUAGES
"call the translation.get_language function, substitute the result for the value under the 'LANGUAGE_CODE' key of the context_extras dictionary.",context_extras [ 'LANGUAGE_CODE' ] = translation . get_language ( )
"call the translation.get_language_bidi function, substitute the result for the value under the 'LANGUAGE_BIDI' key of the context_extras dictionary.",context_extras [ 'LANGUAGE_BIDI' ] = translation . get_language_bidi ( )
return context_extras.,return context_extras
define the function tz with an argument request.,def tz ( request ) :
from django.utils import timezone into default name space.,from django . utils import timezone
return an dictionary containing 1 entry: return value of the function timezone.get_current_timezone_name for 'TIME_ZONE'.,return { 'TIME_ZONE' : timezone . get_current_timezone_name ( ) }
define the function static with an argument request.,def static ( request ) :
return an dictionary containing 1 entry: settings.STATIC_URL for 'STATIC_URL'.,return { 'STATIC_URL' : settings . STATIC_URL }
define the function media with an argument request.,def media ( request ) :
return an dictionary containing 1 entry: settings.MEDIA_URL for 'MEDIA_URL'.,return { 'MEDIA_URL' : settings . MEDIA_URL }
define the function request with an argument request.,def request ( request ) :
return an dictionary containing 1 entry: request for 'request'.,return { 'request' : request }
from functools import reduce into default name space.,from functools import reduce
import module operator.,import operator
from django.utils import six into default name space.,from django . utils import six
from django.utils.encoding import force_text into default name space.,from django . utils . encoding import force_text
derive the class DjangoRuntimeWarning from the RuntimeWarning base class.,class DjangoRuntimeWarning ( RuntimeWarning ) :
do nothing.,pass
derive the class AppRegistryNotReady from the Exception base class.,class AppRegistryNotReady ( Exception ) :
do nothing.,pass
derive the class ObjectDoesNotExist from the Exception base class.,class ObjectDoesNotExist ( Exception ) :
silent_variable_failure is an boolean True.,silent_variable_failure = True
derive the class MultipleObjectsReturned from the Exception base class.,class MultipleObjectsReturned ( Exception ) :
do nothing.,pass
derive the class SuspiciousOperation from the Exception base class.,class SuspiciousOperation ( Exception ) :
derive the class SuspiciousMultipartForm from the SuspiciousOperation base class.,class SuspiciousMultipartForm ( SuspiciousOperation ) :
do nothing.,pass
derive the class SuspiciousFileOperation from the SuspiciousOperation base class.,class SuspiciousFileOperation ( SuspiciousOperation ) :
do nothing.,pass
derive the class DisallowedHost from the SuspiciousOperation base class.,class DisallowedHost ( SuspiciousOperation ) :
do nothing.,pass
derive the class DisallowedRedirect from the SuspiciousOperation base class.,class DisallowedRedirect ( SuspiciousOperation ) :
do nothing.,pass
derive the class PermissionDenied from the Exception base class.,class PermissionDenied ( Exception ) :
do nothing.,pass
derive the class ViewDoesNotExist from the Exception base class.,class ViewDoesNotExist ( Exception ) :
do nothing.,pass
derive the class MiddlewareNotUsed from the Exception base class.,class MiddlewareNotUsed ( Exception ) :
do nothing.,pass
derive the class ImproperlyConfigured from the Exception base class.,class ImproperlyConfigured ( Exception ) :
do nothing.,pass
derive the class FieldError from the Exception base class.,class FieldError ( Exception ) :
do nothing.,pass
NON_FIELD_ERRORS is an string '__all__'.,NON_FIELD_ERRORS = '__all__'
derive the class ValidationError from the Exception base class.,class ValidationError ( Exception ) :
"define the method __init__ with 4 arguments: self, message, code set to None and params set to None.","def __init__ ( self , message , code = None , params = None ) :"
"call the __init__ method from the base class of the class ValidationError with arguments message, code and params.","super ( ValidationError , self ) . __init__ ( message , code , params )"
"if message is an instance of ValidationError class,","if isinstance ( message , ValidationError ) :"
"if message has an 'error_dict' attribute,","if hasattr ( message , 'error_dict' ) :"
substitute message.error_dict for message.,message = message . error_dict
"alternatively, if six.PY3 is true check if message does not have an attribute 'message', if six.PY3 is false, check if message doesnt have an attribute 'code', perform the following,","elif not hasattr ( message , 'message' if six . PY3 else 'code' ) :"
substitute message.error_list for message.,message = message . error_list
"if not,",else :
"substitute message.message, message.code, message.params for message, code and params, respectively.","message , code , params = message . message , message . code , message . params"
"if message is an instance of dict type,","if isinstance ( message , dict ) :"
self.error_dict is an empty dictionary.,self . error_dict = { }
"for every field, messages in return value of the message.items method,","for field , messages in message . items ( ) :"
"if messages is not an instance of the ValidationError class,","if not isinstance ( messages , ValidationError ) :"
messages is an instance of the ValidationError class created with an argument messages.,messages = ValidationError ( messages )
substitute messages.error_list for the value under the field key of the self.error_dict dictionary.,self . error_dict [ field ] = messages . error_list
otherwise if message is an instance of the list type.,"elif isinstance ( message , list ) :"
self.error_list is an empty list.,self . error_list = [ ]
"for every message is message,",for message in message :
"if message is not an instance of the ValidationError class,","if not isinstance ( message , ValidationError ) :"
message is an instance of the ValidationError class created with an argument message.,message = ValidationError ( message )
extend the self.error_list list with message.error_list.,self . error_list . extend ( message . error_list )
"if not,",else :
substitute message for self.message.,self . message = message
substitute code for self.code.,self . code = code
substitute params for self.params.,self . params = params
substitute list containing element self for self.error_list.,self . error_list = [ self ]
"property getter decorator,",@ property
define the method message_dict with an argument self.,def message_dict ( self ) :
get attribute 'error_dict' from the self object.,"getattr ( self , 'error_dict' )"
"convert object self to a dictionary, return it.",return dict ( self )
"property getter decorator,",@ property
define the messages with an argument self.,def messages ( self ) :
"if self has an 'error_dict' attribute,","if hasattr ( self , 'error_dict' ) :"
"call the operator.add on the values of the self object converted into a dictionary, until it is reduced to a single value, return it.","return reduce ( operator . add , dict ( self ) . values ( ) )"
convert self to a list and return it.,return list ( self )
define the method update_error_dict with arguments self and error_dict.,"def update_error_dict ( self , error_dict ) :"
"if self has an 'error_dict' attribute,","if hasattr ( self , 'error_dict' ) :"
"for every field, error_list in self.error_dict.items method return value,","for field , error_list in self . error_dict . items ( ) :"
call the method extend with an argument error_list on the return value of the method error_dict.setdefault called with 2 arguments: field and an empty list.,"error_dict . setdefault ( field , [ ] ) . extend ( error_list )"
"if not,",else :
call the method extend with an argument error_list on the return value of the method error_dict.setdefault called with 2 arguments: NON_FIELD_ERRORS and an empty list.,"error_dict . setdefault ( NON_FIELD_ERRORS , [ ] ) . extend ( self . error_list )"
return error_dict.,return error_dict
define the method __iter__ with an argument self.,def __iter__ ( self ) :
"if self has an 'error_dict' attribute,","if hasattr ( self , 'error_dict' ) :"
"for every field, errors in self.error_dict.items method return value,","for field , errors in self . error_dict . items ( ) :"
"yield field and ValidationError object converted to an list, created with an argument errors.","yield field , list ( ValidationError ( errors ) )"
"if not,",else :
"for every error in self.error_list,",for error in self . error_list :
substitute error.message for message.,message = error . message
"if error.params is true,",if error . params :
"divide message by error.params, substitute the residue of the division for message.",message %= error . params
"call the force_text with an argument message, yield the result.",yield force_text ( message )
define the method __str__ with an argument self.,def __str__ ( self ) :
"if self has an attribute 'error_dict',","if hasattr ( self , 'error_dict' ) :"
return the printable representation of the self object converted to a dictionary.,return repr ( dict ( self ) )
return the printable representation of the self object converted to a list.,return repr ( list ( self ) )
define the method __repr__ with an argument self.,def __repr__ ( self ) :
"return the string 'ValidationError(%s)', replace '%s' with self.",return 'ValidationError(%s)' % self
from django.core.files.base import File into default name space.,from django . core . files . base import File
__all__ is an list containing a string 'File'.,__all__ = [ 'File' ]
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
import module os.,import os
"from io import BytesIO, StringIO and UnsupportedOperation into default name space.","from io import BytesIO , StringIO , UnsupportedOperation"
from django.utils.encoding import smart_text into default name space.,from django . utils . encoding import smart_text
from django.core.files.utils import FileProxyMixin into default name space.,from django . core . files . utils import FileProxyMixin
from django.utils import six into default name space.,from django . utils import six
from django.utils.encoding import force_bytes and python_2_unicode_compatible into default name space.,"from django . utils . encoding import force_bytes , python_2_unicode_compatible"
"decorator python_2_unicode_compatible,",@ python_2_unicode_compatible
derive the class File from the FileProxyMixin base class.,class File ( FileProxyMixin ) :
"bring integer 2 to the power of 10, multiply it by 64, substitute the result for DEFAULT_CHUNK_SIZE.",DEFAULT_CHUNK_SIZE = 64 * 2 ** 10
"define the method __init__ with self class instance, file, and name defaulting to None as arguments.","def __init__ ( self , file , name = None ) :"
substitute file for self.file.,self . file = file
"if name is None,",if name is None :
"get 'name' attribute from the file object, if it doesnt exists use None, substitute it for name.","name = getattr ( file , 'name' , None )"
substitute name for self.name.,self . name = name
"if file object has an attribute 'mode',","if hasattr ( file , 'mode' ) :"
substitute file.mode for self.mode.,self . mode = file . mode
define the method __str__ with argument self.,def __str__ ( self ) :
"evaluate the function smart_text with argument self.name, if exists, or an empty string, if not, return the result.",return smart_text ( self . name or '' )
define the method __repr__ with argument self.,def __repr__ ( self ) :
"substitute '%s' in string '<%s: %s>' with self.__class__.__name__ and self, if exists, or string 'None' if it doesnt, return it.","return ""<%s: %s>"" % ( self . __class__ . __name__ , self or ""None"" )"
define the method __bool__ with argument self.,def __bool__ ( self ) :
"convert self.name into an boolean, return it.",return bool ( self . name )
define the method __nonzero__ with argument self.,def __nonzero__ ( self ) :
"call the __bool__ method with argument self, on the return value of the type function with argument self, return the result.",return type ( self ) . __bool__ ( self )
define the method __len__ with argument self.,def __len__ ( self ) :
return self.size.,return self . size
define the method _get_size_from_underlying_file with argument self.,def _get_size_from_underlying_file ( self ) :
"if self.file has an attribute 'size',","if hasattr ( self . file , 'size' ) :"
return self.file.size.,return self . file . size
"if self.file has an attribute 'name',","if hasattr ( self . file , 'name' ) :"
"try,",try :
"call the os.path.getsize function with argument self.file.name, return the result.",return os . path . getsize ( self . file . name )
if OSError or TypeError errors occurred.,"except ( OSError , TypeError ) :"
do nothing.,pass
"if self.file has an attribute 'tell' and an attribute 'seek',","if hasattr ( self . file , 'tell' ) and hasattr ( self . file , 'seek' ) :"
"get the position of the self.file file pointer, substitute it for pos.",pos = self . file . tell ( )
position the file self.file pointer at the end.,"self . file . seek ( 0 , os . SEEK_END )"
"get the position of the file self.file pointer, substitute it for size.",size = self . file . tell ( )
position file self.file pointer at the pos position.,self . file . seek ( pos )
return size.,return size
"raise an AttributeError exception with string ""Unable to determine the file's size."" as argument.","raise AttributeError ( ""Unable to determine the file's size."" )"
define the method _get_size with argument self.,def _get_size ( self ) :
if self has an attribute '_size'.,"if hasattr ( self , '_size' ) :"
return self._size.,return self . _size
"call the method self._get_size_from_underlying_file, substitute the result for self._size.",self . _size = self . _get_size_from_underlying_file ( )
return self._size.,return self . _size
define the method _set_size with arguments self and size.,"def _set_size ( self , size ) :"
substitute size for self._size.,self . _size = size
size is a property object with _get_size as getter method and _set_size as setter method.,"size = property ( _get_size , _set_size )"
define the method _get_closed with argument self.,def _get_closed ( self ) :
"if self.file is false or self.file.closed is true, return boolean true, otherwise return boolean false.",return not self . file or self . file . closed
closed is a property object with _get_closed as a getter method.,closed = property ( _get_closed )
define the method chunks with arguments self and chunk_size defaulting to None.,"def chunks ( self , chunk_size = None ) :"
"if chunk_size is false,",if not chunk_size :
substitute the self.DEFAULT_CHUNK_SIZE for chunk_size.,chunk_size = self . DEFAULT_CHUNK_SIZE
"try,",try :
position the file pointer at the beginning of self file.,self . seek ( 0 )
if AttributeError or UnsupportedOperation exception occurred.,"except ( AttributeError , UnsupportedOperation ) :"
do nothing.,pass
"endless loop,",while True :
"call the self.read method with argument chunk_size, substitute the result for data.",data = self . read ( chunk_size )
"if data is false,",if not data :
break from the smallest enclosing loop.,break
yield one element of data iterable.,yield data
define the method __multiple_chunks__ with arguments self and chunk_size defaulting to None.,"def multiple_chunks ( self , chunk_size = None ) :"
"if chunk_size is false,",if not chunk_size :
substitute self.DEFAULT_CHUNK_SIZE for chunk_size.,chunk_size = self . DEFAULT_CHUNK_SIZE
"if self.size is greater than chunk_size, return boolean True, otherwise return boolean False.",return self . size > chunk_size
define the method __iter__ with argument self.,def __iter__ ( self ) :
buffer_ is None.,buffer_ = None
"for every chunk in return value of the method self.chunks,",for chunk in self . chunks ( ) :
"evaluate the function BytesIO with argument chunk, substitute it for chunk_buffer.",chunk_buffer = BytesIO ( chunk )
"for every line in chunk_buffer,",for line in chunk_buffer :
"if buffer_ is true,",if buffer_ :
increment line by buffer_.,line = buffer_ + line
buffer_ is None.,buffer_ = None
"if last element of line is newline or carriage return character,","if line [ - 1 : ] in ( b'\n' , b'\r' ) :"
yield one element of line iterable.,yield line
"if not,",else :
substitute line for buffer_.,buffer_ = line
"if buffer_ is not None,",if buffer_ is not None :
yield one element from the buffer_ iterable.,yield buffer_
define the method __enter__ with argument self.,def __enter__ ( self ) :
return self.,return self
"define the method __exit__ with self, exc_type, exc_value and tb as arguments.","def __exit__ ( self , exc_type , exc_value , tb ) :"
close the file self.,self . close ( )
define the method open with arguments self and mode defaulting to None.,"def open ( self , mode = None ) :"
"if file self is not closed,",if not self . closed :
position the file pointer at the beginning of self file.,self . seek ( 0 )
"otherwise if self.name exists and self.name file path exists,",elif self . name and os . path . exists ( self . name ) :
"open the file self.name in mode or self.mode mode, whichever exists, assign the file handler to self.file.","self . file = open ( self . name , mode or self . mode )"
"if not,",else :
"raise an ValueError exception with string ""The file cannot be reopened."" as an argument.","raise ValueError ( ""The file cannot be reopened."" )"
define the method close with argument self.,def close ( self ) :
call the method self.file.close.,self . file . close ( )
"decorator python_2_unicode_compatible,",@ python_2_unicode_compatible
derive the class ContentFile from File base class.,class ContentFile ( File ) :
"define the method __init__ with arguments self, content and name defaulting to None.","def __init__ ( self , content , name = None ) :"
"if six.PY3 is boolean True,",if six . PY3 :
"substitute StringIO for stream_class if content is an instance of six.text_type, otherwise substitute BytesIO for stream_class.","stream_class = StringIO if isinstance ( content , six . text_type ) else BytesIO"
"if not,",else :
substitute BytesIO for stream_class.,stream_class = BytesIO
"call the function force_bytes with argument content, substitute it for content.",content = force_bytes ( content )
"call the __init__ method with stream_class(content) and name set to name arguments, from the base class of the ContentFile class.","super ( ContentFile , self ) . __init__ ( stream_class ( content ) , name = name )"
substitute length of content for self.size.,self . size = len ( content )
define the method __str__ with argument self.,def __str__ ( self ) :
return a string 'Raw content'.,return 'Raw content'
define the method __bool__ with argument self.,def __bool__ ( self ) :
return boolean True.,return True
define the method __nonzero__ with argument self.,def __nonzero__ ( self ) :
"evaluate the method type(self).__bool__ with argument self, return the result.",return type ( self ) . __bool__ ( self )
define the method open with arguments self and mode set to None.,"def open ( self , mode = None ) :"
call the self.seek method with argument integer 0.,self . seek ( 0 )
define the method close with argument self.,def close ( self ) :
do nothing.,pass
import module zlib.,import zlib
from django.core.files import File into default name space.,from django . core . files import File
derive class ImageFile from the base class File.,class ImageFile ( File ) :
define method _get_width with self class instance as the argument.,def _get_width ( self ) :
return the first element of the return value of the call to the self._det_image_dimensions method.,return self . _get_image_dimensions ( ) [ 0 ]
"get property attribute _get_width, and substitute it for width.",width = property ( _get_width )
define method _get_height with self class instance as the argument.,def _get_height ( self ) :
return the second element of the return value of the call to the self._det_image_dimensions method.,return self . _get_image_dimensions ( ) [ 1 ]
"get property attribute _get_height, and substitute it for width.",height = property ( _get_height )
define the method _get_image_dimensions with self class instance as the argument.,def _get_image_dimensions ( self ) :
if self does not have an attribute named '_dimensions_cache'.,"if not hasattr ( self , '_dimensions_cache' ) :"
substitute self.closed for close.,close = self . closed
call the method self.open(),self . open ( )
"evaluate the method get_image_dimensions with self class instance and close set to close as the arguments, substitute the result for self._dimensions_cache.","self . _dimensions_cache = get_image_dimensions ( self , close = close )"
return self._dimensions_cache.,return self . _dimensions_cache
define the function get_image_dimension with file_or_path and close set to boolean False as the arguments.,"def get_image_dimensions ( file_or_path , close = False ) :"
from PIL module import ImageFile as PillowImageFile.,from PIL import ImageFile as PillowImageFile
"p is image parser object, set by calling the PillowImageFile.Parser method.",p = PillowImageFile . Parser ( )
"if file_or_path has an attribute 'read',","if hasattr ( file_or_path , 'read' ) :"
substitute file_or_path for file.,file = file_or_path
"get the position in bytes from the start of the file, store it in file_pos.",file_pos = file . tell ( )
set the file position pointer at the beginning.,file . seek ( 0 )
"if not,",else :
"open file named file_or_path for reading, store the file object handle in file.","file = open ( file_or_path , 'rb' )"
close is boolean True.,close = True
"try,",try :
chunk_size is an integer 1024.,chunk_size = 1024
"endless while loop,",while 1 :
read chunk_size bytes from file and store it in data.,data = file . read ( chunk_size )
if data is empty.,if not data :
break from the endless loop.,break
"try,",try :
feed data to the parser p.,p . feed ( data )
"if zlib.error as e exception is raised,",except zlib . error as e :
"if e.args list first element starts with string ""Error -5"",","if e . args [ 0 ] . startswith ( ""Error -5"" ) :"
do nothig.,pass
"if not,",else :
raise an exception.,raise
"if p.image is not empty,",if p . image :
return size of the image that was fed to the parser p.,return p . image . size
double the chunk size.,chunk_size *= 2
return None.,return None
"execute regardless of the exception being raised,",finally :
"if close is True,",if close :
close file file.,file . close ( )
"if not,",else :
set the file position pointer at file_pos.,file . seek ( file_pos )
import module os.,import os
"__all__ is a tuple containing strings: 'LOCK_EX', 'LOCK_SH', 'LOCK_NB', 'lock' and 'unlock'.","__all__ = ( 'LOCK_EX' , 'LOCK_SH' , 'LOCK_NB' , 'lock' , 'unlock' )"
define the _fd function with argument f.,def _fd ( f ) :
"return result of the f.fileno method if f has an 'fileno' attribute, otherwise return f.","return f . fileno ( ) if hasattr ( f , 'fileno' ) else f"
"if os.name equals to 'nt',",if os . name == 'nt' :
import msvcrt.,import msvcrt
"from ctypes import sizeof, c_ulong, c_void_p, c_int64, Structure, Union, POINTER, windll and byref into default name space.","from ctypes import ( sizeof , c_ulong , c_void_p , c_int64 , Structure , Union , POINTER , windll , byref )"
"from ctypes.wintypes import BOOL, DWORD and HANDLE into default name space.","from ctypes . wintypes import BOOL , DWORD , HANDLE"
LOCK_SH is a integer 0.,LOCK_SH = 0
LOCK_NB is a hexadecimal 1.,LOCK_NB = 0x1
LOCK_EX is a hexadecimal 2.,LOCK_EX = 0x2
"if size of c_ulong does not equals to size of c_void_p,",if sizeof ( c_ulong ) != sizeof ( c_void_p ) :
substitute c_int64 for ULONG_PTR.,ULONG_PTR = c_int64
"if not,",else :
substitute c_ulong for ULONG_PTR.,ULONG_PTR = c_ulong
substitute c_void_p for PVOID.,PVOID = c_void_p
derive the class _OFFSET from the Structure base class.,class _OFFSET ( Structure ) :
"_fields_ is a list containing 2 tuples: first tuple contains: string 'Offset' and DWORD, second contains: string 'OffsetHigh' and DWORD.","_fields_ = [ ( 'Offset' , DWORD ) , ( 'OffsetHigh' , DWORD ) ]"
derive the class _OFFSET_UNION from the Union base class.,class _OFFSET_UNION ( Union ) :
_anonymous_ is a list containing one string: '_offset'.,_anonymous_ = [ '_offset' ]
"_fields_ is a list containing 2 tuples: first tuple contains: string '_offset' and _OFFSET, second contains: string 'Pointer' and PVOID.","_fields_ = [ ( '_offset' , _OFFSET ) , ( 'Pointer' , PVOID ) ]"
derive the class OVERLAPPED from the Structure base class.,class OVERLAPPED ( Structure ) :
_anonymous_ is a list containing one string: '_offset_union'.,_anonymous_ = [ '_offset_union' ]
"_fields_ is a list containing 4 tuples: first tuple contains: string 'Internal' and ULONG_PTR,","_fields_ = [ ( 'Internal' , ULONG_PTR ) , ( 'InternalHigh' , ULONG_PTR ) , ( '_offset_union' , _OFFSET_UNION ) , ( 'hEvent' , HANDLE ) ]"
"second contains: string 'InternalHigh and ULONG_PTR, third: '_offset_union' and _OFFSET_UNION, forth 'hEvent' and HANDLE. call the function POINTER with argument OVERLAPPED, substitute the result for LPOVERLAPPED.",LPOVERLAPPED = POINTER ( OVERLAPPED )
substitute windll.kernel32.LockFileEx for LockFileEx.,LockFileEx = windll . kernel32 . LockFileEx
substitute BOOL for LockFileEx.restype.,LockFileEx . restype = BOOL
"LockFileEx.argtypes is a list containing 6 elements: HANDLE, DWORD, DWORD, DWORD, DWORD and LPOVERLAPPED.","LockFileEx . argtypes = [ HANDLE , DWORD , DWORD , DWORD , DWORD , LPOVERLAPPED ]"
substitute windll.kernel32.UnlockFileEx for UnlockFileEx.,UnlockFileEx = windll . kernel32 . UnlockFileEx
substitute BOOL for UnlockFileEx.restype.,UnlockFileEx . restype = BOOL
"UnlockFileEx.argtypes is a list containing 5 elements: HANDLE, DWORD, DWORD, DWORD and LPOVERLAPPED.","UnlockFileEx . argtypes = [ HANDLE , DWORD , DWORD , DWORD , LPOVERLAPPED ]"
define the function lock with arguments f and flags.,"def lock ( f , flags ) :"
"call the function msvcrt.get_osfhandle with return value of the _fd(f) function as argument, substitute the result for hfile.",hfile = msvcrt . get_osfhandle ( _fd ( f ) )
"call the OVERLAPPED function, substitute the result for overlapped.",overlapped = OVERLAPPED ( )
"call the LockFileEx function with 6 arguments: hfile, flags, integer 0, integer 0, hexadecimal value FFFF0000, return value of the byref function called with argument overlapped, substitute the result for ret.","ret = LockFileEx ( hfile , flags , 0 , 0 , 0xFFFF0000 , byref ( overlapped ) )"
"convert ret to a boolean, return it.",return bool ( ret )
define the function unlock with argument f.,def unlock ( f ) :
"call the function msvcrt.get_osfhandle with return value of the _fd(f) function as argument, substitute the result for hfile.",hfile = msvcrt . get_osfhandle ( _fd ( f ) )
"call the OVERLAPPED function, substitute the result for overlapped.",overlapped = OVERLAPPED ( )
"call the LockFileEx function with 5 arguments: hfile, integer 0, integer 0, hexadecimal value FFFF0000, return value of the byref function called with argument overlapped, substitute the result for ret.","ret = UnlockFileEx ( hfile , 0 , 0 , 0xFFFF0000 , byref ( overlapped ) )"
"convert ret to a boolean, return it.",return bool ( ret )
"if not,",else :
"try,",try :
import fcntl.,import fcntl
substitute fcntl.LOCK_SH for LOCK_SH.,LOCK_SH = fcntl . LOCK_SH
substitute fcntl.LOCK_NB for LOCK_NB.,LOCK_NB = fcntl . LOCK_NB
substitute fcntl.LOCK_EX for LOCK_EX.,LOCK_EX = fcntl . LOCK_EX
"if ImportError or AttributeError exception occurred,","except ( ImportError , AttributeError ) :"
"LOCK_EX, LOCK_SH and LOCK_NB are all equal to integer 0.",LOCK_EX = LOCK_SH = LOCK_NB = 0
define the function lock with arguments f and flags.,"def lock ( f , flags ) :"
return boolean False.,return False
define the function unlock with argument f.,def unlock ( f ) :
return boolean True.,return True
"if not,",else :
define the function lock with arguments f and flags.,"def lock ( f , flags ) :"
"call the function fcntl.flock with return value of the _fd(f) function and flags as arguments, substitute the result for ret.","ret = fcntl . flock ( _fd ( f ) , flags )"
"if ret equals to integer 0, return boolean True, otherwise return boolean False.",return ( ret == 0 )
define the function unlock with argument f.,def unlock ( f ) :
"all the function fcntl.flock with return value of the _fd(f) function and fcntl.LOCK_UN as arguments, substitute the result for ret.","ret = fcntl . flock ( _fd ( f ) , fcntl . LOCK_UN )"
"if ret equals to integer 0, return boolean True, otherwise return boolean False.",return ( ret == 0 )
import module os.,import os
from django.core.files import locks into default name space.,from django . core . files import locks
"try,",try :
from shutil import copystat into default name space.,from shutil import copystat
"if ImportError exception occurred,",except ImportError :
import stat.,import stat
define the function copystat with arguments src and dst.,"def copystat ( src , dst ) :"
"call the os.stat function with argument src, substitute the result for st.",st = os . stat ( src )
"call the function stat.S_IMODE with argument st.st_mode, substitute the result for mode.",mode = stat . S_IMODE ( st . st_mode )
"if os has an attribute 'utime',","if hasattr ( os , 'utime' ) :"
call the os.utime function with arguments dst and tuple containing 2 elements: st.st_atime and st.st_mtime.,"os . utime ( dst , ( st . st_atime , st . st_mtime ) )"
"if os has an attribute 'chmod',","if hasattr ( os , 'chmod' ) :"
call the function os.chmod with arguments dst and mode.,"os . chmod ( dst , mode )"
__all__ is a list containing a string 'file_move_safe'.,__all__ = [ 'file_move_safe' ]
define the function _samefile with arguments src and dst.,"def _samefile ( src , dst ) :"
"if os.path has an attribute 'samefile',","if hasattr ( os . path , 'samefile' ) :"
"try,",try :
"call the os.path.samefile with arguments src and dst, return the result.","return os . path . samefile ( src , dst )"
"if exception OSError occurred,",except OSError :
return boolean False.,return False
"if file path of src and dst files are the same, return boolean True, otherwise return boolean False.",return ( os . path . normcase ( os . path . abspath ( src ) ) == os . path . normcase ( os . path . abspath ( dst ) ) )
"define the function file_move_safe with 4 arguments: old_file_name, new_file_name, chunk_size set to multiple of integers 1024 and 64,","def file_move_safe ( old_file_name , new_file_name , chunk_size = 1024 * 64 , allow_overwrite = False ) :"
"if call to the function _samefile with old_file_name and new_file_name evaluates to boolean True,","if _samefile ( old_file_name , new_file_name ) :"
return nothing.,return
"try,",try :
"if allow_overwrite is boolean False and call to the os.access function with arguments new_file_name and os.F_OK evaluates to boolean True,","if not allow_overwrite and os . access ( new_file_name , os . F_OK ) :"
"raise an IOError exception with string ""Destination file %s exists and allow_overwrite is False"" as argument, where '%s' is replaced by new_file_name.","raise IOError ( ""Destination file %s exists and allow_overwrite is False"" % new_file_name )"
call the os.rename function with arguments old_file_name and new_file_name.,"os . rename ( old_file_name , new_file_name )"
return nothing.,return
"if OSError exception is caught,",except OSError :
do nothing.,pass
"open file old_file_name in read bytes mode, with file descriptor as f,","with open ( old_file_name , 'rb' ) as old_file :"
"evaluate the binary expression with 4 operands: os.O_WRONLY, binary or os.O_CREATE, binary or 'O_BINARY' attribute of object os,","fd = os . open ( new_file_name , ( os . O_WRONLY | os . O_CREAT | getattr ( os , 'O_BINARY' , 0 ) | ( os . O_EXCL if not allow_overwrite else 0 ) ) )"
"binary or os.O_EXCL if allow_overwrite is boolean False, use the previous as the mode to open new_file_name file, assign the file descriptor to fd. try,",try :
call the function locks.lock with arguments fd and locks.LOCK_EX.,"locks . lock ( fd , locks . LOCK_EX )"
current_chunk is None.,current_chunk = None
"as long as current_chunk is not an empty string,",while current_chunk != b'' :
"read chunk_size bytes from the old_file file, substitute the result for current_chunk.",current_chunk = old_file . read ( chunk_size )
write current_chunk to file fd.,"os . write ( fd , current_chunk )"
"finally perform,",finally :
call the function locks.unlock with fd as argument.,locks . unlock ( fd )
close the file fd.,os . close ( fd )
call the function copystat with old_file_name and new_file_name as arguments.,"copystat ( old_file_name , new_file_name )"
"tr,",try :
remove the old_file_name file.,os . remove ( old_file_name )
"if OSError, renamed to e, is caught,",except OSError as e :
"if attribute 'winerror' of object e is not equal to integer 32 and if 'errno' attribute is not equal to integer 13,","if getattr ( e , 'winerror' , 0 ) != 32 and getattr ( e , 'errno' , 0 ) != 13 :"
raise an exception.,raise
import module os.,import os
import module errno.,import errno
import module itertools.,import itertools
from datetime import datetime into default name space.,from datetime import datetime
from django.conf import settings into default name space.,from django . conf import settings
from django.core.exceptions import SuspiciousFileOperation into default name space.,from django . core . exceptions import SuspiciousFileOperation
from django.core.files import locks and File into default name space.,"from django . core . files import locks , File"
from django.core.files.move import file_move_safe into default name space.,from django . core . files . move import file_move_safe
from django.utils.encoding import force_text and filepath_to_uri into default name space.,"from django . utils . encoding import force_text , filepath_to_uri"
from django.utils.functional import LazyObject into default name space.,from django . utils . functional import LazyObject
from django.utils.module_loading import import_string into default name space.,from django . utils . module_loading import import_string
from django.utils.six.moves.urllib.parse import urljoin into default name space.,from django . utils . six . moves . urllib . parse import urljoin
from django.utils.text import get_valid_filename into default name space.,from django . utils . text import get_valid_filename
from django.utils._os import safe_join and abspathu into default name space.,"from django . utils . _os import safe_join , abspathu"
from django.utils.deconstruct import deconstructible into default name space.,from django . utils . deconstruct import deconstructible
"__all__ is a tuple containing strings: 'Storage', 'FileSystemStorage', 'DefaultStorage' and 'default_storage'.","__all__ = ( 'Storage' , 'FileSystemStorage' , 'DefaultStorage' , 'default_storage' )"
derive the class Storage from the object base class.,class Storage ( object ) :
"define the method open with arguments self, name and mode defaulting to string 'rb'.","def open ( self , name , mode = 'rb' ) :"
"call the self._open method with name and mode arguments, return the result.","return self . _open ( name , mode )"
"define the method save with arguments self, name and content.","def save ( self , name , content ) :"
"if name is None,",if name is None :
substitute content.name for name.,name = content . name
"if content has an 'chunks' attribute,","if not hasattr ( content , 'chunks' ) :"
content is a File object instance created with content argument.,content = File ( content )
"call the method self.get_available_name with argument name, substitute it for name.",name = self . get_available_name ( name )
"call the method self._save with arguments name and content, substitute it for name.","name = self . _save ( name , content )"
"replace all the strings '\\' with '/' in the string name, use it as an argument for the call to the force_text function, return the result.","return force_text ( name . replace ( '\\' , '/' ) )"
define the method det_valid_name with arguments self and name.,"def get_valid_name ( self , name ) :"
"call the get_valid_filename with argument name, return the result.",return get_valid_filename ( name )
define the method get_available_name with arguments self and name.,"def get_available_name ( self , name ) :"
"call the os.path.split with argument name, assign the result to the dir_name and file_name respectively.","dir_name , file_name = os . path . split ( name )"
"call the os.path.splitext with argument file_name, assign the result to the file_root and file_ext respectively.","file_root , file_ext = os . path . splitext ( file_name )"
"call the itertools.count function with argument integer 1, substitute the result for count.",count = itertools . count ( 1 )
"as long as self.exists function with argument name evaluates to boolean True,",while self . exists ( name ) :
"substitute '%s' in string ""%s_%s%s"" with: file_root, next(count) and file_ext, join the dir_name and previous string into a valid file path, substitute it for name.","name = os . path . join ( dir_name , ""%s_%s%s"" % ( file_root , next ( count ) , file_ext ) )"
return name.,return name
define the method path with arguments self and name.,"def path ( self , name ) :"
"raise an NotImplementedError exception with argument string ""This backend doesn't support absolute paths."".","raise NotImplementedError ( ""This backend doesn't support absolute paths."" )"
define the method delete with arguments self and name.,"def delete ( self , name ) :"
raise an NotImplementedError exception with argument string 'subclasses of Storage must provide a delete() method'.,raise NotImplementedError ( 'subclasses of Storage must provide a delete() method' )
define the method exists with arguments self and name.,"def exists ( self , name ) :"
raise an NotImplementedError exception with argument string 'subclasses of Storage must provide an exists() method'.,raise NotImplementedError ( 'subclasses of Storage must provide an exists() method' )
define the method listdir with arguments self and path.,"def listdir ( self , path ) :"
raise an NotImplementedError exception with argument string 'subclasses of Storage must provide a listdir() method'.,raise NotImplementedError ( 'subclasses of Storage must provide a listdir() method' )
define the method size with arguments self and name.,"def size ( self , name ) :"
raise an NotImplementedError exception with argument string 'subclasses of Storage must provide a size() method'.,raise NotImplementedError ( 'subclasses of Storage must provide a size() method' )
define the method url with arguments self and name.,"def url ( self , name ) :"
raise an NotImplementedError exception with argument string 'subclasses of Storage must provide a url() method'.,raise NotImplementedError ( 'subclasses of Storage must provide a url() method' )
define the method accessed_time with arguments self and name.,"def accessed_time ( self , name ) :"
raise an NotImplementedError exception with argument string 'subclasses of Storage must provide an accessed_time() method'.,raise NotImplementedError ( 'subclasses of Storage must provide an accessed_time() method' )
define the method created_time with arguments self and name.,"def created_time ( self , name ) :"
raise an NotImplementedError exception with argument string 'subclasses of Storage must provide a created_time() method'.,raise NotImplementedError ( 'subclasses of Storage must provide a created_time() method' )
define the method modified_time with arguments self and name.,"def modified_time ( self , name ) :"
raise an NotImplementedError exception with argument string 'subclasses of Storage must provide a modified_time() method'.,raise NotImplementedError ( 'subclasses of Storage must provide a modified_time() method' )
"decorator deconstructible,",@ deconstructible
derive the class FileSystemStorage from the Storage base class.,class FileSystemStorage ( Storage ) :
"define the method __init__ with 5 arguments: self, location set to None, base_url set to None, file_permissions_mode set to None,","def __init__ ( self , location = None , base_url = None , file_permissions_mode = None , directory_permissions_mode = None ) :"
"and directory_permissions_mode set to None. if location is None,",if location is None :
substitute the settings.MEDIA_ROOT for location.,location = settings . MEDIA_ROOT
substitute the location for self.base_location.,self . base_location = location
substitute the return value of the function abspathu with self.base_location as argument for self.location.,self . location = abspathu ( self . base_location )
"if base_url is None,",if base_url is None :
substitute settings.MEDIA_URL for base_url.,base_url = settings . MEDIA_URL
"otherwise if base_url does not ends with '/' character,",elif not base_url . endswith ( '/' ) :
append character '/' to the base_url.,base_url += '/'
substitute base_url for self.base_url.,self . base_url = base_url
"self.file_permissions_mode is a tuple containing: file_permissions_mode if file_permissions_mode is not None,",self . file_permissions_mode = ( file_permissions_mode if file_permissions_mode is not None else settings . FILE_UPLOAD_PERMISSIONS )
"or settings.FILE_UPLOAD_PERMISSIONS if it is. self.directory_permissions_mode is a tuple containing: directory_permissions_mode if directory_permissions_mode is not None,",self . directory_permissions_mode = ( directory_permissions_mode if directory_permissions_mode is not None else settings . FILE_UPLOAD_DIRECTORY_PERMISSIONS )
"or settings.FILE_UPLOAD_DIRECTORY_PERMISSIONS if it is. define the method _open with arguments self, name and mode defaulting to string 'rb'.","def _open ( self , name , mode = 'rb' ) :"
"call the function self.path with argument name, use it and mode as arguments for the call to the function open, use it as an argument for creatinon of a File object instance, return it.","return File ( open ( self . path ( name ) , mode ) )"
"define the method _save with arguments self, name and content.","def _save ( self , name , content ) :"
substitute result of the self.path function with argument name for full_path.,full_path = self . path ( name )
"call the function os.path.dirname with argument full_path, substitute the result for directory.",directory = os . path . dirname ( full_path )
"if call to the function os.path.exists with argument directory evaluates to boolean False,",if not os . path . exists ( directory ) :
"try,",try :
"if self.directory_permissions_mode is not None,",if self . directory_permissions_mode is not None :
"call the os.umask function with argument integer 0, substitute the result for old_umask.",old_umask = os . umask ( 0 )
"try,",try :
call the os.makedirs function with directory and self.directory_permissions_mode as arguments.,"os . makedirs ( directory , self . directory_permissions_mode )"
"finally perform,",finally :
call the os.umask function with argument old_umask.,os . umask ( old_umask )
"if not,",else :
call the function os.makedirs with argument directory.,os . makedirs ( directory )
"if exception OSError, renamed to e, occurred,",except OSError as e :
"if e.errno is not equal to errno.EEXIST,",if e . errno != errno . EEXIST :
raise an exception.,raise
"if directory is not an directory,",if not os . path . isdir ( directory ) :
"raise an IOError exception with argument string ""%s exists and is not a directory."", where '%s' is replaced by directory.","raise IOError ( ""%s exists and is not a directory."" % directory )"
"endless loop,",while True :
"try,",try :
"if content has an attribute 'temporary_file_path',","if hasattr ( content , 'temporary_file_path' ) :"
call the function file_move_safe with content.temporary_file_path function result and full_path.,"file_move_safe ( content . temporary_file_path ( ) , full_path )"
"if not,",else :
"evaluate binary expression with 4 operands: os.O_WRONLY, binary or os.O_CREAT, binary or os.O_EXCL,","flags = ( os . O_WRONLY | os . O_CREAT | os . O_EXCL | getattr ( os , 'O_BINARY' , 0 ) )"
"binary or 'O_BINARY' attribute of the os object, or integer 0 if it doesnt exists. call the os.open function with full_path, flags and octal number 0o666 as arguments, substitute the result for fd.","fd = os . open ( full_path , flags , 0o666 )"
_file is None.,_file = None
"try,",try :
call the function locks.lock with fd and locks.LOCK_EX as arguments.,"locks . lock ( fd , locks . LOCK_EX )"
"for every chunk in content.chunks function return value,",for chunk in content . chunks ( ) :
"if _file is None,",if _file is None :
"mode is a string 'wb' is chunk is instance of the type bytes, otherwise mode is a string 'wt'.","mode = 'wb' if isinstance ( chunk , bytes ) else 'wt'"
"call the function os.fdopen with arguments fd and mode, substitute it for _file.","_file = os . fdopen ( fd , mode )"
write the chunk to the file _file.,_file . write ( chunk )
"finally perform,",finally :
call the function locks.unlock with argument fd.,locks . unlock ( fd )
"if _file is not None,",if _file is not None :
close the _file file.,_file . close ( )
"if not,",else :
close fd file.,os . close ( fd )
"if OSError, renamed to e, is caught,",except OSError as e :
"if e.errno equals to errno.EEXIST,",if e . errno == errno . EEXIST :
"call the method self.get_available_name with argument name, substitute the result for name.",name = self . get_available_name ( name )
"call the method self.path with argument name, substitute the result for full_path.",full_path = self . path ( name )
"if not,",else :
raise an exception.,raise
"if not,",else :
break from the smallest enclosing loop.,break
"if self.file_permissions_mode is not None,",if self . file_permissions_mode is not None :
call the function os.chmod with arguments full_path and self.file_permissions_mode.,"os . chmod ( full_path , self . file_permissions_mode )"
return name.,return name
define the method delete with arguments self and name.,"def delete ( self , name ) :"
"if name is boolean False raise an assert error with message string ""The name argument is not allowed to be empty."".","assert name , ""The name argument is not allowed to be empty."""
"call the self.path with argument name, substitute it for name.",name = self . path ( name )
"if os.path.exists function with argument name, evaluates to boolean True,",if os . path . exists ( name ) :
"try,",try :
call the os.remove function with argument name.,os . remove ( name )
"if OSError, renamed to e, is caught,",except OSError as e :
"if e.errno equals to errno.EEXIST,",if e . errno != errno . ENOENT :
raise an exception.,raise
define the method exists with arguments self and name.,"def exists ( self , name ) :"
"call the self.path function with argument name, use the result as the argument for the call to the os.path.exists function, return the result.",return os . path . exists ( self . path ( name ) )
define the method listdir with arguments self and path.,"def listdir ( self , path ) :"
"call the self.path function with argument path, substitute it for path.",path = self . path ( path )
"directories, files are empty lists.","directories , files = [ ] , [ ]"
"for every entry in os.listdir function return value called with the argument path,",for entry in os . listdir ( path ) :
"join path and entry into a file path, if it exists,","if os . path . isdir ( os . path . join ( path , entry ) ) :"
append entry to the directories list.,directories . append ( entry )
"if not,",else :
append entry to files list.,files . append ( entry )
return directories and files.,"return directories , files"
define the method path with arguments self and name.,"def path ( self , name ) :"
"try,",try :
"call the safe_join function with arguments self.location and name, substitute it for path.","path = safe_join ( self . location , name )"
"if ValueError exception is caught,",except ValueError :
"raise an SuspiciousFileOperation exception with string ""Attempted access to '%s' denied."" as argument, replace '%s' with name.","raise SuspiciousFileOperation ( ""Attempted access to '%s' denied."" % name )"
"call the os.path.normpath with argument path, return the result.",return os . path . normpath ( path )
define the method size with arguments self and name.,"def size ( self , name ) :"
"call the self.path with argument name, use the result as an argument for the call to the os.path.getsize function, return the result.",return os . path . getsize ( self . path ( name ) )
define the method url with arguments self and name.,"def url ( self , name ) :"
"if self.base_url is None,",if self . base_url is None :
"raise an ValueError with string ""This file is not accessible via a URL."" as argument.","raise ValueError ( ""This file is not accessible via a URL."" )"
"call the urljoin function with arguments: self.base_url and result of the call to the function filepath_to_uri with argument name, return the result.","return urljoin ( self . base_url , filepath_to_uri ( name ) )"
define the method accessed_time with arguments self and name.,"def accessed_time ( self , name ) :"
"call the function self.path with argument name, use the result as an argument for the call to the function os.path.getatime,",return datetime . fromtimestamp ( os . path . getatime ( self . path ( name ) ) )
"use the result as an argument for the call to the function datetime.fromtimestamp, return the result. define the method created_time with arguments self and name.","def created_time ( self , name ) :"
"call the function self.path with argument name, use the result as an argument for the call to the function os.path.getctime,",return datetime . fromtimestamp ( os . path . getctime ( self . path ( name ) ) )
"use the result as an argument for the call to the function datetime.fromtimestamp, return the result. define the method modified_time with arguments self and name.","def modified_time ( self , name ) :"
"call the function self.path with argument name, use the result as an argument for the call to the function os.path.getmtime,",return datetime . fromtimestamp ( os . path . getmtime ( self . path ( name ) ) )
"use the result as an argument for the call to the function datetime.fromtimestamp, return the result. define the function get_storage_class with argument import_path=None defaulting to None.",def get_storage_class ( import_path = None ) :
"call the import_string with argument: import_path if exists or settings.DEFAULT_FILE_STORAGE, if not, return the result.",return import_string ( import_path or settings . DEFAULT_FILE_STORAGE )
derive the class DefaultStorage from the LazyObject base class.,class DefaultStorage ( LazyObject ) :
define the _setup method with argument self.,def _setup ( self ) :
"call the function that is the return value of get_storage_class method, substitute the result for self._wrapped.",self . _wrapped = get_storage_class ( ) ( )
"call the DefaultStorage method, substitute the result for default_storage.",default_storage = DefaultStorage ( )
import module os.,import os
import module tempfile.,import tempfile
from django.core.files.utils import FileProxyMixin into default name space.,from django . core . files . utils import FileProxyMixin
"__all__ is a tuple, containing strings 'NamedTemporaryFile' and 'gettempdir'.","__all__ = ( 'NamedTemporaryFile' , 'gettempdir' , )"
"if module os field name equals to string 'nt',",if os . name == 'nt' :
derive class TemporaryFile from the base class FileProxyMixin.,class TemporaryFile ( FileProxyMixin ) :
"define method __init__ with self class instance, mode string 'w+b', bufsize set to integer -1, suffix and prefix set to empty strig,","def __init__ ( self , mode = 'w+b' , bufsize = - 1 , suffix = '' , prefix = '' , dir = None ) :"
"dir set to None as the arguments. call the method tmpfile.mkstemp with suffix set to suffix, prefix set to prefix and dir set to dir, store the result in the fd and name, respective.","fd , name = tempfile . mkstemp ( suffix = suffix , prefix = prefix , dir = dir )"
substitute name for self.name.,self . name = name
"call the os.fdopen function with fd, mode and bufsize as the arguments, assign the file handle object to self.file.","self . file = os . fdopen ( fd , mode , bufsize )"
substitute False for self.close_called.,self . close_called = False
substitute os.unlink for unlink.,unlink = os . unlink
define the method close with self class instance as the argument.,def close ( self ) :
"if self.close_called is False,",if not self . close_called :
substitute True for self.close_called.,self . close_called = True
"try,",try :
close the file object.,self . file . close ( )
"if OSError or IOError exceptions were raised,","except ( OSError , IOError ) :"
do nothing.,pass
"try,",try :
call the method unlink on self with self.name as the argument.,self . unlink ( self . name )
"if OSError exception was raised,",except ( OSError ) :
do nothing.,pass
"property decorator, to be called by property built-in function.",@ property
define the method closed with self as the argument.,def closed ( self ) :
return self.file.closed.,return self . file . closed
define __del__ method with self as the argument.,def __del__ ( self ) :
call the method close on self.,self . close ( )
define __enter__ method with self as the argument.,def __enter__ ( self ) :
call the file.__enter__ method on self.,self . file . __enter__ ( )
return self.,return self
"define method __exit__ with self, exc, value and tb as the arguments.","def __exit__ ( self , exc , value , tb ) :"
"call the file.__exit__ method on self with exc, value and tb as the arguments.","self . file . __exit__ ( exc , value , tb )"
substitute TemporaryFile for NamedTemporaryFile.,NamedTemporaryFile = TemporaryFile
"if not,",else :
substitute tempfile.NamedTemporaryFile for NamedTemporaryFile.,NamedTemporaryFile = tempfile . NamedTemporaryFile
substitute tempfile.gettempdir for gettempdir.,gettempdir = tempfile . gettempdir
import module errno.,import errno
import module os.,import os
from io import BytesIO into default name space.,from io import BytesIO
from django.conf import settings into default name space.,from django . conf import settings
from django.core.files.base import File into default name space.,from django . core . files . base import File
from django.core.files import temp as tempfile into default name space.,from django . core . files import temp as tempfile
from django.utils.encoding import force_str into default name space.,from django . utils . encoding import force_str
"__all__ is a tuple containing strings: 'UploadedFile', 'TemporaryUploadedFile', 'InMemoryUploadedFile' and 'SimpleUploadedFile'.","__all__ = ( 'UploadedFile' , 'TemporaryUploadedFile' , 'InMemoryUploadedFile' , 'SimpleUploadedFile' )"
derive the UploadedFile class from the File base class.,class UploadedFile ( File ) :
"bring integer 2 to the power of 10, multiply it by integer 64, substitute the result for DEFAULT_CHUNK_SIZE.",DEFAULT_CHUNK_SIZE = 64 * 2 ** 10
"define the method __init__ with 7 arguments: self, file set to None, name set to None, content_type set to None, size set to None, charset set to None and content_type_extra set to None.","def __init__ ( self , file = None , name = None , content_type = None , size = None , charset = None , content_type_extra = None ) :"
"call the __init__ method with arguments file and name, from the base class of the UploadedFile class.","super ( UploadedFile , self ) . __init__ ( file , name )"
substitute size for self.size.,self . size = size
substitute content_type for self.content_type.,self . content_type = content_type
substitute charset for self.charset.,self . charset = charset
substitute content_type_extra for self.content_type_extra.,self . content_type_extra = content_type_extra
define the method __repr__ with argument self.,def __repr__ ( self ) :
"substitute '%s' from string ""<%s: %s (%s)>"" with self.__class__.__name__, self.name and self.content_type, respectively, use it as an argument for the call to the function force_str, return the result.","return force_str ( ""<%s: %s (%s)>"" % ( self . __class__ . __name__ , self . name , self . content_type ) )"
define the method _get_name with argument self.,def _get_name ( self ) :
return self._name.,return self . _name
define the method _set_name with arguments self and name.,"def _set_name ( self , name ) :"
"if name is not None,",if name is not None :
"call the function os.path.basename with argument name, substitute the result for name.",name = os . path . basename ( name )
"if length of name is greater than integer 255,",if len ( name ) > 255 :
"call the os.path.splitex with argument name, assign the result to name and ext, respectively.","name , ext = os . path . splitext ( name )"
substitute the first 255 elements of ext for ext.,ext = ext [ : 255 ]
"subtract length of the ext from the integer 255, take first elements of the name list up to the previous result index,",name = name [ : 255 - len ( ext ) ] + ext
"append ext to the end of it, substitute the resulting list for name. substitute name for self._name.",self . _name = name
name is a property object with _get_name as a getter method and _set_name as a setter method.,"name = property ( _get_name , _set_name )"
derive the TemporaryUploadedFile class from the UploadedFile base class.,class TemporaryUploadedFile ( UploadedFile ) :
"define the __init__ method with 6 arguments: self, name, content_type, size, charset and content_type_extra set to None.","def __init__ ( self , name , content_type , size , charset , content_type_extra = None ) :"
"if settings.FILE_UPLOAD_TEMP_DIR is true,",if settings . FILE_UPLOAD_TEMP_DIR :
call the method tempfile.NamedTemporaryFile with arguments: suffix set to string '.upload' and dir set to settings.FILE_UPLOAD_TEMP_DIR.,"file = tempfile . NamedTemporaryFile ( suffix = '.upload' , dir = settings . FILE_UPLOAD_TEMP_DIR )"
"if not,",else :
call the method tempfile.NamedTemporaryFile with argument suffix set to string '.upload'.,file = tempfile . NamedTemporaryFile ( suffix = '.upload' )
"call the method __init__ from the base class of the TemporaryUploadedFile class with arguments: file, name, content_type, size, charset and content_type_extra.","super ( TemporaryUploadedFile , self ) . __init__ ( file , name , content_type , size , charset , content_type_extra )"
define the method temporary_file_path with argument self.,def temporary_file_path ( self ) :
return self.file.name.,return self . file . name
define the method close with argument self.,def close ( self ) :
"try,",try :
"call the self.file.close method, return the result.",return self . file . close ( )
"if OSError, renamed to e, exception is caught,",except OSError as e :
"if e.errno is not equal to errno.ENOENT,",if e . errno != errno . ENOENT :
raise an exception.,raise
derive the InMemoryUploadedFile class from the UploadedFile base class.,class InMemoryUploadedFile ( UploadedFile ) :
"define the method __init__ with 8 arguments: self, file, field_name, name, content_type, size, charset and content_type_extra set to None.","def __init__ ( self , file , field_name , name , content_type , size , charset , content_type_extra = None ) :"
"call the method __init__ from the base class of the InMemoryUploadedFile base class, with 6 arguments: file, name, content_type,","super ( InMemoryUploadedFile , self ) . __init__ ( file , name , content_type , size , charset , content_type_extra )"
"size, charset, content_type_extra. substitute field_name for self.field_name.",self . field_name = field_name
define the method open with arguments self and mode set to None.,"def open ( self , mode = None ) :"
set the file pointer at the beginning of the self.file file.,self . file . seek ( 0 )
define the method chunks with arguments self ad chunk_size set to None.,"def chunks ( self , chunk_size = None ) :"
set the file pointer at the beginning of the self.file file.,self . file . seek ( 0 )
read the whole self file and yield it as a generator return value.,yield self . read ( )
define the method multiple_chunks with arguments self and hunk_size set to None.,"def multiple_chunks ( self , chunk_size = None ) :"
return boolean False.,return False
derive the SimpleUploadedFile class from the InMemoryUploadedFile base class.,class SimpleUploadedFile ( InMemoryUploadedFile ) :
"define the method __init__ with 4 arguments: self, name, content and content_type defaulting to a string 'text/plain'.","def __init__ ( self , name , content , content_type = 'text/plain' ) :"
"if content is empty, substitute it for an empty string.",content = content or b''
"call the __init__ method from the base class of the SimpleUploadedFile class with 7 arguments: BytesIO(content), None, name,","super ( SimpleUploadedFile , self ) . __init__ ( BytesIO ( content ) , None , name , content_type , len ( content ) , None , None )"
"content_type, length of content, None and None. decorator classmethod.",@ classmethod
define the method from_dict with argument cls and file_dict.,"def from_dict ( cls , file_dict ) :"
"call the method cls with 3 arguments: value under the 'filename' key of file_dict, value under the 'content' key of file_dict,","return cls ( file_dict [ 'filename' ] , file_dict [ 'content' ] , file_dict . get ( 'content-type' , 'text/plain' ) )"
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
from io import BytesIO into default name space.,from io import BytesIO
from django.conf import settings into default name space.,from django . conf import settings
from django.core.files.uploadedfile import TemporaryUploadedFile and InMemoryUploadedFile into default name space.,"from django . core . files . uploadedfile import TemporaryUploadedFile , InMemoryUploadedFile"
from django.utils.encoding import python_2_unicode_compatible into default name space.,from django . utils . encoding import python_2_unicode_compatible
from django.utils.module_loading import import_string into default name space.,from django . utils . module_loading import import_string
"__all__ is a string containing strings: 'UploadFileException', 'StopUpload', 'SkipFile', 'FileUploadHandler',","__all__ = [ 'UploadFileException' , 'StopUpload' , 'SkipFile' , 'FileUploadHandler' , 'TemporaryFileUploadHandler' , 'MemoryFileUploadHandler' , 'load_handler' , 'StopFutureHandlers' ]"
"'TemporaryFileUploadHandler', 'MemoryFileUploadHandler', 'load_handler' and 'StopFutureHandlers'. derive the class UploadFileException from the Exception base class.",class UploadFileException ( Exception ) :
do nothing.,pass
"decorator python_2_unicode_compatible,",@ python_2_unicode_compatible
derive the class StopUpload from the UploadFileException base class.,class StopUpload ( UploadFileException ) :
define the method __init__ with arguments self and connection_reset defaulting to boolean False.,"def __init__ ( self , connection_reset = False ) :"
substitute connection_reset for self.connection_reset.,self . connection_reset = connection_reset
define the method __str__ with argument self.,def __str__ ( self ) :
"if self.connection_reset is true,",if self . connection_reset :
return string 'StopUpload: Halt current upload.'.,return 'StopUpload: Halt current upload.'
"if not,",else :
"return string 'StopUpload: Consume request data, then halt.'.","return 'StopUpload: Consume request data, then halt.'"
derive the class SkipFile from the UploadFileException base class.,class SkipFile ( UploadFileException ) :
do nothing.,pass
derive the class StopFutureHandlers from the UploadFileException base class.,class StopFutureHandlers ( UploadFileException ) :
do nothing.,pass
derive the class FileUploadHandler from the object base class.,class FileUploadHandler ( object ) :
"bring integer 2 to the power of 10, multiply it by integer 64, substitute the result for chunk_size.",chunk_size = 64 * 2 ** 10
define the method __init__ with arguments self and request defaulting to None.,"def __init__ ( self , request = None ) :"
self.file_name is None.,self . file_name = None
self.content_type is None.,self . content_type = None
self.content_length is None.,self . content_length = None
self.charset is None.,self . charset = None
self.content_type_extra is None.,self . content_type_extra = None
self.request is None.,self . request = request
"define the method handle_raw_input with arguments: self, input_data, META, content_length, boundary and encoding set to None.","def handle_raw_input ( self , input_data , META , content_length , boundary , encoding = None ) :"
do nothing.,pass
"define the method new_file with arguments: self, field_name, file_name, content_type, content_length, charset set to None,","def new_file ( self , field_name , file_name , content_type , content_length , charset = None , content_type_extra = None ) :"
substitute field_name for self.field_name.,self . field_name = field_name
substitute file_name for self.file_name.,self . file_name = file_name
substitute content_type for self.content_type.,self . content_type = content_type
substitute content_length for self.content_length.,self . content_length = content_length
substitute charset for self.charset.,self . charset = charset
substitute content_type_extra for self.content_type_extra.,self . content_type_extra = content_type_extra
"define the method receive_data_chunk with arguments: self, raw_data and start.","def receive_data_chunk ( self , raw_data , start ) :"
raise an NotImplementedError with argument string 'subclasses of FileUploadHandler must provide a receive_data_chunk() method'.,raise NotImplementedError ( 'subclasses of FileUploadHandler must provide a receive_data_chunk() method' )
define the method file_complete with arguments: self and file_size.,"def file_complete ( self , file_size ) :"
raise an NotImplementedError with argument string 'subclasses of FileUploadHandler must provide a file_complete() method'.,raise NotImplementedError ( 'subclasses of FileUploadHandler must provide a file_complete() method' )
define the method upload_complete with argument self.,def upload_complete ( self ) :
do nothing.,pass
derive the class TemporaryFileUploadHandler from the FileUploadHandler base class.,class TemporaryFileUploadHandler ( FileUploadHandler ) :
"define the method __init__ with arguments self, argument list args and dictionary of arguments kwargs.","def __init__ ( self , * args , ** kwargs ) :"
"call the __init__ method from the base class of the TemporaryFileUploadHandler class with arguments: unpacked list args,","super ( TemporaryFileUploadHandler , self ) . __init__ ( * args , ** kwargs )"
"and unpacked dictionary kwargs. define the method new_file with arguments: self, file_name, unpacked list args and unpacked dictionary kwargs.","def new_file ( self , file_name , * args , ** kwargs ) :"
"call the method new_file from the base class of the TemporaryFileUploadHandler class with arguments: file_name, unpacked list args and unpacked dictionary kwargs.","super ( TemporaryFileUploadHandler , self ) . new_file ( file_name , * args , ** kwargs )"
"self.file is a instance of a class TemporaryUploadedFile initialized with arguments: self.file_name, self.content_type, integer 0,","self . file = TemporaryUploadedFile ( self . file_name , self . content_type , 0 , self . charset , self . content_type_extra )"
"self.charset and self.content_type_extra. define the method receive_data_chunk with arguments: self, raw_data and start.","def receive_data_chunk ( self , raw_data , start ) :"
call the method self.file.write with argument raw_data.,self . file . write ( raw_data )
define the method file_complete with arguments self and file_size.,"def file_complete ( self , file_size ) :"
position the file pointer at the start of the self.file file.,self . file . seek ( 0 )
substitute file_size for self.file.size.,self . file . size = file_size
return self.file.,return self . file
derive the class MemoryFileUploadHandler from the FileUploadHandler base class.,class MemoryFileUploadHandler ( FileUploadHandler ) :
"define the method handle_raw_input with arguments: self, input_data, META, content_length, boundary and encoding set to None.","def handle_raw_input ( self , input_data , META , content_length , boundary , encoding = None ) :"
"if content_length is greater than settings.FILE_UPLOAD_MAX_MEMORY_SIZE,",if content_length > settings . FILE_UPLOAD_MAX_MEMORY_SIZE :
self.activated is boolean False.,self . activated = False
"if not,",else :
self.activated is boolean True.,self . activated = True
"define the method new_file with arguments: self, unpacked list args and unpacked dictionary kwargs.","def new_file ( self , * args , ** kwargs ) :"
call the new_file method form the base class from the MemoryFileUploadHandler class with arguments: unpacked list args and unpacked list kwargs.,"super ( MemoryFileUploadHandler , self ) . new_file ( * args , ** kwargs )"
"if self.activated is boolean True,",if self . activated :
"call the function BytesIO, substitute the result for self.file.",self . file = BytesIO ( )
raise an exception StopFutureHandlers.,raise StopFutureHandlers ( )
"define the function receive_data_chunk with arguments self, raw_data and start.","def receive_data_chunk ( self , raw_data , start ) :"
"if self.activated is boolean True,",if self . activated :
write raw_data to self.file file.,self . file . write ( raw_data )
"if not,",else :
return raw_data.,return raw_data
define the function file_complete with arguments self and file_size.,"def file_complete ( self , file_size ) :"
"if self.activated is boolean False,",if not self . activated :
return nothing.,return
set file pointer at the beginning of the self.file file.,self . file . seek ( 0 )
"initialize the object of a InMemoryUploadedFile class with arguments: file set to self.file, field_name set to self.field_name,","return InMemoryUploadedFile ( file = self . file , field_name = self . field_name , name = self . file_name , content_type = self . content_type , size = file_size , charset = self . charset , content_type_extra = self . content_type_extra )"
"name set to self.file_name, content_type set to self.content_type, size set to file_size, charset set to self.charset, and content_type_extra set to self.content_type_extra, return it. define the function load_handler with arguments: path, unpacked list args and unpacked dictionary kwargs.","def load_handler ( path , * args , ** kwargs ) :"
"call the import_string with arguments path, call the return function with arguments: unpacked list args and unpacked dictionary kwargs, return the result.","return import_string ( path ) ( * args , ** kwargs )"
"derive class FileProxyMixin from the base class object, making it a new-style class.",class FileProxyMixin ( object ) :
"define lambda function that returns self.file.encoding field, use it as an argument for property function, put the result in encoding.",encoding = property ( lambda self : self . file . encoding )
"define lambda function that returns self.file.fileno field, use it as an argument for property function, put the result in fileno.",fileno = property ( lambda self : self . file . fileno )
"define lambda function that returns self.file.flush field, use it as an argument for property function, put the result in flush.",flush = property ( lambda self : self . file . flush )
"define lambda function that returns self.file.isatty field, use it as an argument for property function, put the result in isatty.",isatty = property ( lambda self : self . file . isatty )
"define lambda function that returns self.file.newlines field, use it as an argument for property function, put the result in newlines.",newlines = property ( lambda self : self . file . newlines )
"define lambda function that returns self.file.read field, use it as an argument for property function, put the result in read.",read = property ( lambda self : self . file . read )
"define lambda function that returns self.file.readinto field, use it as an argument for property function, put the result in readinto.",readinto = property ( lambda self : self . file . readinto )
"define lambda function that returns self.file.readline field, use it as an argument for property function, put the result in readline.",readline = property ( lambda self : self . file . readline )
"define lambda function that returns self.file.readlines field, use it as an argument for property function, put the result in readlines.",readlines = property ( lambda self : self . file . readlines )
"define lambda function that returns self.file.seek field, use it as an argument for property function, put the result in seek.",seek = property ( lambda self : self . file . seek )
"define lambda function that returns self.file.softspace field, use it as an argument for property function, put the result in softspace.",softspace = property ( lambda self : self . file . softspace )
"define lambda function that returns self.file.tell field, use it as an argument for property function, put the result in tell.",tell = property ( lambda self : self . file . tell )
"define lambda function that returns self.file.truncate field, use it as an argument for property function, put the result in truncate.",truncate = property ( lambda self : self . file . truncate )
"define lambda function that returns self.file.write field, use it as an argument for property function, put the result in write.",write = property ( lambda self : self . file . write )
"define lambda function that returns self.file.writelines field, use it as an argument for property function, put the result in writelines.",writelines = property ( lambda self : self . file . writelines )
"define lambda function that returns self.file.xreadlines field, use it as an argument for property function, put the result in xreadlines.",xreadlines = property ( lambda self : self . file . xreadlines )
define iterator method __iter__ with self as the argument.,def __iter__ ( self ) :
return iterator object based on the self.file collection object.,return iter ( self . file )
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
import module logging.,import logging
import module sys.,import sys
import module types.,import types
from django import http into default name space.,from django import http
from django.conf import settings into default name space.,from django . conf import settings
from django.core import urlresolvers into default name space.,from django . core import urlresolvers
from django.core import signals into default name space.,from django . core import signals
"from django.core.exceptions import MiddlewareNotUsed, PermissionDenied and SuspiciousOperation into default name space.","from django . core . exceptions import MiddlewareNotUsed , PermissionDenied , SuspiciousOperation"
from django.db import connections and transaction into default name space.,"from django . db import connections , transaction"
from django.utils.encoding import force_text into default name space.,from django . utils . encoding import force_text
from django.utils.module_loading import import_string into default name space.,from django . utils . module_loading import import_string
from django.utils import six into default name space.,from django . utils import six
from django.views import debug into default name space.,from django . views import debug
"call the function logging.getLogger with string 'django.request' as the argument, assign the return object handle to logger.",logger = logging . getLogger ( 'django.request' )
"derive class BaseHandler, derive from the base class object, making this a new style class.",class BaseHandler ( object ) :
response_fixes is a list with http.fix_location_header and http.conditional_content_removal as elements.,"response_fixes = [ http . fix_location_header , http . conditional_content_removal , ]"
"define initialization method __init__, with self class instance as the argument.",def __init__ ( self ) :
"set class fields _request_middleware, _view_middleware, _template_response_middleware, _response_middleware and _exception_middleware to None.",self . _request_middleware = self . _view_middleware = self . _template_response_middleware = self . _response_middleware = self . _exception_middleware = None
define method load_middleware with class instance self as the argument.,def load_middleware ( self ) :
self._view_middleware is an empty list.,self . _view_middleware = [ ]
self._template_response_middleware is an empty list.,self . _template_response_middleware = [ ]
_response_middleware is an empty list.,self . _response_middleware = [ ]
exception_middleware is an empty list.,self . _exception_middleware = [ ]
request_middleware is an empty list.,request_middleware = [ ]
for every middleware_path in settings.MIDDLEWARE_CLASSES:,for middleware_path in settings . MIDDLEWARE_CLASSES :
"evaluate the function import_string with middleware_path as argument, substitute the result for my_class.",mw_class = import_string ( middleware_path )
"try,",try :
"call the mw_class function, store the result in the mw_instance.",mw_instance = mw_class ( )
"if MiddlewareNotUsed exception is raised,",except MiddlewareNotUsed :
skip this iteration of he smallest enclosing loop.,continue
if mw_instance has an attribute named 'process_request'.,"if hasattr ( mw_instance , 'process_request' ) :"
append mw_instance.process_request at the end of request_middleware.,request_middleware . append ( mw_instance . process_request )
if mw_instance has an attribute named 'process_view'.,"if hasattr ( mw_instance , 'process_view' ) :"
append mw_instance.process_view at the end of self._view_middleware.,self . _view_middleware . append ( mw_instance . process_view )
if mw_instance has an attribute named 'process_template_response'.,"if hasattr ( mw_instance , 'process_template_response' ) :"
insert mw_instance.process_template_response at the beginning of self._template_response_middleware.,"self . _template_response_middleware . insert ( 0 , mw_instance . process_template_response )"
if mw_instance has an attribute named 'process_response'.,"if hasattr ( mw_instance , 'process_response' ) :"
insert mw_instance.process_response at the beginning of self._response_middleware.,"self . _response_middleware . insert ( 0 , mw_instance . process_response )"
if mw_instance has an attribute named 'process_exception'.,"if hasattr ( mw_instance , 'process_exception' ) :"
insert mw_instance.process_exception at the beginning of self._exception_middleware.,"self . _exception_middleware . insert ( 0 , mw_instance . process_exception )"
substitute self._request_middleware for request_middleware.,self . _request_middleware = request_middleware
"define the method make_view_atomic, with self class instance and view as the arguments.","def make_view_atomic ( self , view ) :"
"get attribute '_non_atomic_requests' from the view object, if the attribute doesnt exist return the empty set, substitute the result for non_atomic_requests.","non_atomic_requests = getattr ( view , '_non_atomic_requests' , set ( ) )"
"call the method connections.all(), perform the following for every db in the result,",for db in connections . all ( ) :
"if value under the key 'ATOMIC_REQUESTS of db.settings_dic dictionary is True and db.alias is not present in the non_atomic_requests,",if ( db . settings_dict [ 'ATOMIC_REQUESTS' ] and db . alias not in non_atomic_requests ) :
"call the function transaction.atomic, with using set to db.alias as the argument, return value is a function which is called,",view = transaction . atomic ( using = db . alias ) ( view )
"with the argument view, store the result in the view. return view",return view
"define method get_exception_response, with self class instance, request, resolver and status_code as the arguments.","def get_exception_response ( self , request , resolver , status_code ) :"
"try,",try :
"call the function resolver.resolve_error_handler with status_code as an argument, assign the result to the callback and param_dict, respectively.","callback , param_dict = resolver . resolve_error_handler ( status_code )"
"call the callback function with request and dictionary argument param_dict as the arguments, substitute it for response.","response = callback ( request , ** param_dict )"
"if an exception occurred,",except :
"call the method signals.got_request_exception.send with the sender set to the type of this class, and request set to request as the arguments.","signals . got_request_exception . send ( sender = self . __class__ , request = request )"
"call the method self.handle_uncaught_exception with request, resolver and return value of the function sys.exec_info as the arguments.","response = self . handle_uncaught_exception ( request , resolver , sys . exc_info ( ) )"
return response,return response
"define the method get_response, with self class instance and request as the arguments.","def get_response ( self , request ) :"
substitute settings.ROOT_URLCONF for urlconf.,urlconf = settings . ROOT_URLCONF
call the method urlresolvers.set_urlconf with urlconf as the argument.,urlresolvers . set_urlconf ( urlconf )
"call the method urlresolvers.RegexURLResolver with raw literal string '^/' and urlconf as the arguments, substitute the result for resolver.","resolver = urlresolvers . RegexURLResolver ( r'^/' , urlconf )"
"try,",try :
set response to None.,response = None
"for every middleware_method in self._request_middleware,",for middleware_method in self . _request_middleware :
"call the middleware_method with the request as an argument, substitute the result for response.",response = middleware_method ( request )
"if response is True,",if response :
breaks from the smallest enclosing loop execution.,break
"if response is None,",if response is None :
"if request has an attribute named 'urlconf',","if hasattr ( request , 'urlconf' ) :"
substitute request.urlconf for urlconf.,urlconf = request . urlconf
call the function urlresolvers.set_urlconf with urlconf as the argument.,urlresolvers . set_urlconf ( urlconf )
"call the method urlresolvers.RegexURLResolver with raw literal string '^/' and urlconf as the arguments, substitute the result for resolver.","resolver = urlresolvers . RegexURLResolver ( r'^/' , urlconf )"
call to the resolver.resolve method with request.path_info as an argument.,resolver_match = resolver . resolve ( request . path_info )
"assign the values to the callback, callback_args, callback_kwargs, respectively, from the resolver_match tuple.","callback , callback_args , callback_kwargs = resolver_match"
substitute resolver_match for request.resolver_match.,request . resolver_match = resolver_match
"for every middleware_method in self._view_middleware,",for middleware_method in self . _view_middleware :
"call the middleware_method with request, callback, callback_args and callback_kwargs as the arguments, substitute the result for response.","response = middleware_method ( request , callback , callback_args , callback_kwargs )"
"if response is True,",if response :
break from the smallest enclosing loop execution.,break
"if response is None,",if response is None :
"call the method self.make_view_atomic with callback as the argument, substitute the result for the wrapped_callback.",wrapped_callback = self . make_view_atomic ( callback )
"try,",try :
"call the function wrapped_callback with request, list or arguments callback_args and dictionary arguments callback_kwargs,","response = wrapped_callback ( request , * callback_args , ** callback_kwargs )"
"as the arguments, substitute the result for response. if Exception, renamed to e, exception is caught,",except Exception as e :
"for every middleware_method in self._exception_middleware,",for middleware_method in self . _exception_middleware :
"call the middleware_method with request and e as the arguments, substitute the result for response.","response = middleware_method ( request , e )"
"if response is True,",if response :
break from the smallest enclosing loop execution.,break
"if response is None,",if response is None :
raise the exception.,raise
"if response is None,",if response is None :
"if callback is of instance types.FunctionType,","if isinstance ( callback , types . FunctionType ) :"
"get the name of the callback, substitute it for view_name.",view_name = callback . __name__
"if not,",else :
"get the name of the type of the callback, append the string '.__call__' to it, substitute it for view_name.",view_name = callback . __class__ . __name__ + '.__call__'
"substitute the '%s' in the string ""The view %s.%s didn't return an HttpResponse object. It returned None instead."",","raise ValueError ( ""The view %s.%s didn't return an HttpResponse object. It returned None instead."" % ( callback . __module__ , view_name ) )"
"with the name of the module callback is in and the view_name, respectively, use it as the argument for the ValueError exception raise. if response has an attribute named 'render' and response.render is a callable function,","if hasattr ( response , 'render' ) and callable ( response . render ) :"
"for every middleware_method in self._template_response_middleware,",for middleware_method in self . _template_response_middleware :
"call the function middleware_method with the request and response as the arguments, assign the result to response.","response = middleware_method ( request , response )"
"if response is None,",if response is None :
"replace '%s' in the string ""%s.process_template_response didn't return an HttpResponse object. It returned None instead."",","raise ValueError ( ""%s.process_template_response didn't return an "" ""HttpResponse object. It returned None instead."" % ( middleware_method . __self__ . __class__ . __name__ ) )"
"with name of the class type of the middleware_method instance, use it as the argument for call to the ValueError exception raise. call the response.render() method and assign the return to the response.",response = response . render ( )
"if exception http.Http404 as e is caught,",except http . Http404 as e :
"substitute '%s' in 'Not Found: %s' with request.path, extra is an dictionary with two pairs of elements 'status_code' with value 404,","logger . warning ( 'Not Found: %s' , request . path , extra = { 'status_code' : 404 , 'request' : request } )"
"and 'request with value request, respectively use the previous as the arguments for the call to the logger.warning function. if settings.DEBUG is True,",if settings . DEBUG :
"call the function debug.technical_404_response with request and e as arguments, assign the result to response.","response = debug . technical_404_response ( request , e )"
"if not,",else :
"call the method self.get_exception_response with request, resolver and integer 404 as the arguments, assign the result to response.","response = self . get_exception_response ( request , resolver , 404 )"
"if exception PermissionDenied is caught,",except PermissionDenied :
"substitute '%s' in 'Forbidden (Permission denied): %s' with request.path, extra is an dictionary with two pairs of elements,","logger . warning ( 'Forbidden (Permission denied): %s' , request . path , extra = { 'status_code' : 403 , 'request' : request } )"
"'status_code' with value 403, and 'request with value request, respectively use the previous as the arguments for the call to the logger.warning function. call the method self.get_exception_response with request, resolver and integer 403 as the arguments, assign the result to response.","response = self . get_exception_response ( request , resolver , 403 )"
"if exception SuspiciousOperation as e is caught,",except SuspiciousOperation as e :
"substitute '%s' in 'django.security.%s' with the name of the type of the class object e, use it as the argument for the call to the,",security_logger = logging . getLogger ( 'django.security.%s' % e . __class__ . __name__ )
"function logging.getLogger, assign the result to the security_logger. evaluate the function force_text with e as an argument, extra is an dictionary with two pair of elements,","security_logger . error ( force_text ( e ) , extra = { 'status_code' : 400 , 'request' : request } )"
"'status code' with integer value of 400 and 'request' with value request, respectively use the previous to call the function security_logger.error. if settings.DEBUG is True,",if settings . DEBUG :
"evaluate the function debug.technical_500_response with request, evaluated value of function sys.exc_info as a list,","return debug . technical_500_response ( request , * sys . exc_info ( ) , status_code = 400 )"
"status code set to integer 400, return the result. call the method self.get_exception_response with the request, resolver and integer 400 as the arguments, substitute the result for response.","response = self . get_exception_response ( request , resolver , 400 )"
"if SystemExit exception is caught,",except SystemExit :
raise an exception.,raise
"otherwise if any other exception is caught,",except :
call the method signals.got_request_exception.send with sender set to type of the self class instance and request set to request.,"signals . got_request_exception . send ( sender = self . __class__ , request = request )"
"call to the self.handle_uncaught_exception method with request, resolver and value of the evaluated function sys.exec_info,","response = self . handle_uncaught_exception ( request , resolver , sys . exc_info ( ) )"
"as the arguments, substitute the result for response. try,",try :
"for every middleware_method in self._response_middleware,",for middleware_method in self . _response_middleware :
"call the function middleware_method with request and response as the arguments, substitute the result for response.","response = middleware_method ( request , response )"
"if response is None,",if response is None :
"substitute '%s' is ""%s.process_response didn't return an HttpResponse object. It returned None instead."",","raise ValueError ( ""%s.process_response didn't return an "" ""HttpResponse object. It returned None instead."" % ( middleware_method . __self__ . __class__ . __name__ ) )"
"with the name of the type of the self class instance of the middleware_method, raise the ValueError with the previous as the argument. call the method self.apply_response_fixes with the request and response as the arguments, substitute the result for response.","response = self . apply_response_fixes ( request , response )"
"if any exception is caught,",except :
call the signals.got_request_exception.send method with sender set to type of the self class instance and request set to request.,"signals . got_request_exception . send ( sender = self . __class__ , request = request )"
"call to the self.handle_uncaught_exception method with request, resolver and value of the evaluated function sys.exec_info,","response = self . handle_uncaught_exception ( request , resolver , sys . exc_info ( ) )"
"as the arguments, substitute the result for response. append the request to the end of the protected class member response._closable_objects.",response . _closable_objects . append ( request )
return response.,return response
"define the method handle_uncaught_exception with self class instance, request, resolver and exec_info as arguments.","def handle_uncaught_exception ( self , request , resolver , exc_info ) :"
"if settings.DEBUG_PROPAGATE_EXCEPTIONS is True,",if settings . DEBUG_PROPAGATE_EXCEPTIONS :
raise an exception.,raise
"substitute '%s' in 'Internal Server Error: %s' with request.path, exc_info set to exc_info,","logger . error ( 'Internal Server Error: %s' , request . path , exc_info = exc_info , extra = { 'status_code' : 500 , 'request' : request } )"
"extra is an dictionary with two pairs of elements 'status_code' with value 500, and 'request with value request, respectively use the previous as the arguments for the call to the logger.error function. if settings.DEBUG is True,",if settings . DEBUG :
"evaluate debug.technical_500_response with request and list of arguments exec_info, return the result.","return debug . technical_500_response ( request , * exc_info )"
if resolver.urlconf_module is None:,if resolver . urlconf_module is None :
"call the function reraise from the module six, with list of arguments exec_info.",six . reraise ( * exc_info )
"call the resolver.resolve_error_handler with integer 500 as the argument, assign the resulting tuple elements to the callback,","callback , param_dict = resolver . resolve_error_handler ( 500 )"
"and param_dict, respectively. evaluate the function callback with request and dictionary of parameters param_dict as the arguments, return the result.","return callback ( request , ** param_dict )"
"define the method apply_response_fixes with self class instance, request and response as the arguments.","def apply_response_fixes ( self , request , response ) :"
"for every func in self.response_fixes,",for func in self . response_fixes :
"call the function func with request and response as arguments, assign the result to response.","response = func ( request , response )"
return response.,return response
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
import module cgi.,import cgi
import module codecs.,import codecs
import module logging.,import logging
import module sys.,import sys
from io import BytesIO into default name space.,from io import BytesIO
from threading import Lock into default name space.,from threading import Lock
import module warnings.,import warnings
from django import http into default name space.,from django import http
from django.conf import settings into default name space.,from django . conf import settings
from django.core import signals into default name space.,from django . core import signals
from django.core.handlers import base into default name space.,from django . core . handlers import base
from django.core.urlresolvers import set_script_prefix into default name space.,from django . core . urlresolvers import set_script_prefix
from django.utils import datastructures into default name space.,from django . utils import datastructures
from django.utils.deprecation import RemovedInDjango19Warning into default name space.,from django . utils . deprecation import RemovedInDjango19Warning
from django.utils.encoding import force_str and force_text into default name space.,"from django . utils . encoding import force_str , force_text"
from django.utils.functional import cached_property into default name space.,from django . utils . functional import cached_property
from django.utils import six into default name space.,from django . utils import six
from django.http.response import REASON_PHRASES as STATUS_CODE_TEXT # NOQA into default name space.,from django . http . response import REASON_PHRASES as STATUS_CODE_TEXT
"call logging.getLogger method with string 'django.request' as argument, store the result in logger.",logger = logging . getLogger ( 'django.request' )
"ISO_8859_1 is a string 'iso-8859-1', UTF_8 is a string 'utf-8'.","ISO_8859_1 , UTF_8 = str ( 'iso-8859-1' ) , str ( 'utf-8' )"
"derive class LimitedStream from the object base class, making it a new-style class.",class LimitedStream ( object ) :
"def initialization method __init__ with self class instance, stream, limit and buf_size set to integer value of the product 64*1024*1024.","def __init__ ( self , stream , limit , buf_size = 64 * 1024 * 1024 ) :"
substitute stream for self.stream.,self . stream = stream
substitute limit for self.remaining.,self . remaining = limit
substitute empty bytes string for self.buffer.,self . buffer = b''
substitute buf_size for self.buf_size.,self . buf_size = buf_size
define the method _read_limited with self class instance and size set to None as arguments.,"def _read_limited ( self , size = None ) :"
"if size is None or size is greater than self.remaining,",if size is None or size > self . remaining :
substitute self.remaining for size.,size = self . remaining
if size equals to integer zero.,if size == 0 :
return empty bytes string.,return b''
"read size number of bytes from self.stream stream, store the result in the result.",result = self . stream . read ( size )
decrement self.remaining by length of result.,self . remaining -= len ( result )
return result.,return result
define the method read with self class instance and size set to None as arguments.,"def read ( self , size = None ) :"
"if size is None,",if size is None :
"add self.buffer and self._read_limited method return value together, store it in result.",result = self . buffer + self . _read_limited ( )
substitute empty bytes string for self.buffer.,self . buffer = b''
"otherwise if size is less than length of self.buffer,",elif size < len ( self . buffer ) :
substitute first size elements of self.buffer for result.,result = self . buffer [ : size ]
truncate first size number of elements of self.buffer.,self . buffer = self . buffer [ size : ]
"if not,",else :
"call the method self.read_limited with length of self.buffer subtracted from size as argument, add result to self.buffer, store it in result.",result = self . buffer + self . _read_limited ( size - len ( self . buffer ) )
substitute empty bytes string for self.buffer.,self . buffer = b''
return result.,return result
define method readline with self class instance and size set to None.,"def readline ( self , size = None ) :"
"while newline character is not contained in self.buffer and, size is None or length of self.buffer is less than size,",while b'\n' not in self . buffer and ( size is None or len ( self . buffer ) < size ) :
"if size is not zero,",if size :
"call the self._read_limiter with length of self.buffer subtracted from size as argument, store the result into chunk.",chunk = self . _read_limited ( size - len ( self . buffer ) )
"if not,",else :
"call the method self._read_limited, store the return value into chunk.",chunk = self . _read_limited ( )
"if chunk is empty,",if not chunk :
break the execution of the smallest enclosing loop.,break
increment self.buffer by chunk.,self . buffer += chunk
"call the function BytesIO with self.buffer as argument, store the result is sio.",sio = BytesIO ( self . buffer )
"if size is not empty,",if size :
"call the sio.readline method with size as an argument, substitute the result for line.",line = sio . readline ( size )
"if not,",else :
"call the sio.readline method, substitute the result for line.",line = sio . readline ( )
"call the sio.read method, substitute the result for self.buffer.",self . buffer = sio . read ( )
return line.,return line
derive the class WSGIRequest from base class http.HttpRequest.,class WSGIRequest ( http . HttpRequest ) :
define the initialization method __init__ with self class instance and environ as arguments.,"def __init__ ( self , environ ) :"
"call the get_script_name function with environ as argument, substitute the result for script_name.",script_name = get_script_name ( environ )
"call the get_path_info function with environ as argument, substitute the result for path_info.",path_info = get_path_info ( environ )
"if path_info is empty,",if not path_info :
path_info is a character '/'.,path_info = '/'
substitute environ for self.environ.,self . environ = environ
substitute path_info for self.path_info.,self . path_info = path_info
"strip trailing '/' from the script_name string, remove first occurrence of '/' in path_info string, append second result to the first, separated with '/', assign the result to self.path.","self . path = '%s/%s' % ( script_name . rstrip ( '/' ) , path_info . replace ( '/' , '' , 1 ) )"
substitute environ for self.META.,self . META = environ
assign path_info to the value under the 'PATH_INFO' key of the self.META dictionary.,self . META [ 'PATH_INFO' ] = path_info
assign script_name to the value under the 'SCRIP_NAME' key of the self.META dictionary.,self . META [ 'SCRIPT_NAME' ] = script_name
"convert value under the 'REQUEST_METHOD' key of the environ dictionary to uppercase, substitute it for self.method.",self . method = environ [ 'REQUEST_METHOD' ] . upper ( )
"get the value under the 'CONTENT_TYPE' key of environ dictionary, if the key doesnt exist get the empty string,","_ , content_params = cgi . parse_header ( environ . get ( 'CONTENT_TYPE' , '' ) )"
"use it to call the cgi.parse_header method, assign the result to the _ and content_params respectively. if string 'charset' is contained in content_params,",if 'charset' in content_params :
"try,",try :
"get the value under the 'charset' key of content_params dictionary, use it to call the codec.lookup method.",codecs . lookup ( content_params [ 'charset' ] )
"if exception LookupError is caught,",except LookupError :
do nothing.,pass
"if not,",else :
"get the value under the 'charset' key of content_params dictionary, substitute it for self.encoding.",self . encoding = content_params [ 'charset' ]
self._post_parse_error is boolean False.,self . _post_parse_error = False
"try,",try :
"convert value under the 'CONTENT_LENGTH' key of the environ dictionary to an integer, substitute it for content_length.",content_length = int ( environ . get ( 'CONTENT_LENGTH' ) )
"if exception ValueError or TypeError is caught,","except ( ValueError , TypeError ) :"
content_length is integer 0.,content_length = 0
"self._stream is a class instance of a LimitedStream class, initialized with self.environ dictionary value under the 'wsgi.input' key,","self . _stream = LimitedStream ( self . environ [ 'wsgi.input' ] , content_length )"
and content_length. self._read_started is boolean False.,self . _read_started = False
self.resolver_match is None.,self . resolver_match = None
define the method _get_scheme with self class instance as argument.,def _get_scheme ( self ) :
return value under the 'wsgi.url_scheme' key of self.environ dictionary.,return self . environ . get ( 'wsgi.url_scheme' )
define the method _get_request with self class instance as argument.,def _get_request ( self ) :
"call the warnings.warn method with string '`request.REQUEST` is deprecated, use `request.GET` or `request.POST` instead.',","warnings . warn ( '`request.REQUEST` is deprecated, use `request.GET` or ' '`request.POST` instead.' , RemovedInDjango19Warning , 2 )"
"RemovedInDjango19Warning and integer 2 as arguments. if self does not have an '_request' attribute,","if not hasattr ( self , '_request' ) :"
"call the datastructures.MergeDict with self.POST and self.GET as arguments, assign the result to self._request.","self . _request = datastructures . MergeDict ( self . POST , self . GET )"
return self._request.,return self . _request
decorator cached_property.,@ cached_property
define method GET with self class instance as an argument.,def GET ( self ) :
"call the get_bytes_from_wsgi function with self.environ, string 'QUERY_STRING' and empty string as arguments, substitute the return value for raw_query_string.","raw_query_string = get_bytes_from_wsgi ( self . environ , 'QUERY_STRING' , '' )"
"evaluate the http.QueryDict method with raw_query_string and encoding set to self._encoding as arguments, return the result.","return http . QueryDict ( raw_query_string , encoding = self . _encoding )"
def _get_post method with self class instance as the argument.,def _get_post ( self ) :
if self does not has an '_post' attribute.,"if not hasattr ( self , '_post' ) :"
call the self._load_post_and_files method.,self . _load_post_and_files ( )
return self._post.,return self . _post
define the _set_post method with self class instance and post as the arguments.,"def _set_post ( self , post ) :"
substitute post for self._post.,self . _post = post
decorator cached_property.,@ cached_property
define COOKIES method with self as the argument.,def COOKIES ( self ) :
"call get_str_from_wsgi function with self.environ, string 'HTTP_COOKIE' and empty string as arguments, substitute it for raw_cookie.","raw_cookie = get_str_from_wsgi ( self . environ , 'HTTP_COOKIE' , '' )"
"evaluate the function http.parse_cookie with raw_cookie as an argument, return the result.",return http . parse_cookie ( raw_cookie )
define _get_files method with self class instance as the argument.,def _get_files ( self ) :
"if self does not have '_files' attribute,","if not hasattr ( self , '_files' ) :"
call the method self._load_post_and_files.,self . _load_post_and_files ( )
return self._files.,return self . _files
_get_post is a getter function and _set_post is a setter function for POST attribute of this class.,"POST = property ( _get_post , _set_post )"
_get_files is getter function for FILES attribute of this class.,FILES = property ( _get_files )
_get_request is getter function for REQUEST attribute of this class.,REQUEST = property ( _get_request )
derive the WSGIHandler class from the base class base.BaseHandler.,class WSGIHandler ( base . BaseHandler ) :
evaluate function Lock() assign the result to initLock.,initLock = Lock ( )
substitute WSGIRequest for request_class.,request_class = WSGIRequest
"define private method __call__ with self class instance, environ and start_response as the arguments.","def __call__ ( self , environ , start_response ) :"
"if self._request_middleware is None,",if self . _request_middleware is None :
"with self.initLock,",with self . initLock :
"try,",try :
"if self._request_middleware is None,",if self . _request_middleware is None :
call the self.load_middleware method.,self . load_middleware ( )
"if exception is caught,",except :
self._request_middleware is None.,self . _request_middleware = None
re raise an exception.,raise
"call the get_script_name function with environ as argument, use the result as an argument for call to the set_script_prefix function.",set_script_prefix ( get_script_name ( environ ) )
call the signals.request_started.send method with sender set to self.__class__ as argument.,signals . request_started . send ( sender = self . __class__ )
"try,",try :
"call the self.request_class method with environ as an argument, substitute the result for request.",request = self . request_class ( environ )
"if UnicodeDecodeError exception is caught,",except UnicodeDecodeError :
"call the logger.warning method with string 'Bad Request (UnicodeDecodeError)', exec_info set to sys.exec_info() and dictionary extra","logger . warning ( 'Bad Request (UnicodeDecodeError)' , exc_info = sys . exc_info ( ) , extra = { 'status_code' : 400 , } )"
"with one entry 'status_code' is integer 400, as arguments. call the http.HttpResponseBadRequest function, assign the result to the response.",response = http . HttpResponseBadRequest ( )
"if not,",else :
"call the self.get_response with request as the argument, substitute the result for response.",response = self . get_response ( request )
substitute self.__class__ for response._handler_class.,response . _handler_class = self . __class__
"replace '%s' in the string '%s %s' with response.status_code and response.reason_phrase, respectively, substitute it for status.","status = '%s %s' % ( response . status_code , response . reason_phrase )"
"convert to k and v to strings for every k and v in return value of the response.item method, response_headers is a list containing all the above iteration elements.","response_headers = [ ( str ( k ) , str ( v ) ) for k , v in response . items ( ) ]"
"for every c in return value of the method response.cookies.values,",for c in response . cookies . values ( ) :
"convert 'Set-Cookie' to a string and convert the return value of method c.output(header='') call to a string,","response_headers . append ( ( str ( 'Set-Cookie' ) , str ( c . output ( header = '' ) ) ) )"
"format the previous in a tuple, append the tuple to the response_headers. call the start_response function with force_str(status) method return value and response_headers as arguments.","start_response ( force_str ( status ) , response_headers )"
return response.,return response
define the get_path_info function with environ as the argument.,def get_path_info ( environ ) :
"call the function get_bytes_from_wsgi with environ, string 'PATH_INFO' and character '/' as arguments, substitute the result for path_info.","path_info = get_bytes_from_wsgi ( environ , 'PATH_INFO' , '/' )"
return path_info.decode method return value called with UTF_8 as the argument.,return path_info . decode ( UTF_8 )
define get_script_name function with environ as an argument.,def get_script_name ( environ ) :
"if settings.FORCE_SCRIPT_NAME is not None,",if settings . FORCE_SCRIPT_NAME is not None :
"evaluate the force_text function with settings.FORCE_SCRIPT_NAME as argument, return the result.",return force_text ( settings . FORCE_SCRIPT_NAME )
"call the get_bytes_from_wsgi function with environ, string 'SCRIPT_URL' and empty strings as arguments, substitute the result for script_url.","script_url = get_bytes_from_wsgi ( environ , 'SCRIPT_URL' , '' )"
"if script_url is false,",if not script_url :
"call the get_bytes_from_wsgi function with environ, string 'REDIRECT_URL' and empty strings as arguments, substitute the result for script_url.","script_url = get_bytes_from_wsgi ( environ , 'REDIRECT_URL' , '' )"
"if script_url is true,",if script_url :
"call the get_bytes_from_wsgi function with environ, string 'PATH_INFO' and empty strings as arguments, substitute the result for path_info.","path_info = get_bytes_from_wsgi ( environ , 'PATH_INFO' , '' )"
"take all but the length of path_info last elements of script_url, substitute it for script_name.",script_name = script_url [ : - len ( path_info ) ]
"if not,",else :
"call the get_bytes_from_wsgi function with environ, string 'SCRIPT_NAME' and empty strings as arguments, substitute the result for script_name.","script_name = get_bytes_from_wsgi ( environ , 'SCRIPT_NAME' , '' )"
return scrip_name.decode method result called with UTF_8 as argument.,return script_name . decode ( UTF_8 )
"define the function get_bytes_from_wsgi with environ, key and default as arguments.","def get_bytes_from_wsgi ( environ , key , default ) :"
"convert key and default to strings, get the value under the key string key of the environ dictionary, if it does not exists use the,","value = environ . get ( str ( key ) , str ( default ) )"
"default string value, substitute it for value. return value if six.PY2 is true, if not return value.encode(ISO_8859_1).",return value if six . PY2 else value . encode ( ISO_8859_1 )
"define the get_str_from_wsgi function with environ, key and default as arguments.","def get_str_from_wsgi ( environ , key , default ) :"
"convert key and default to strings, get the value under the key string key of the environ dictionary, if it does not exists use the,","value = environ . get ( str ( key ) , str ( default ) )"
"default string value, substitute it for value. return value if six.PY2 is true, if not return value.encode(ISO_8859_1).decode(UTF_8).",return value if six . PY2 else value . encode ( ISO_8859_1 ) . decode ( UTF_8 )
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
from django.conf import settings into default name space.,from django . conf import settings
from django.utils.module_loading import import_string into default name space.,from django . utils . module_loading import import_string
from django.core.mail.utils import CachedDnsName and DNS_NAME into default name space.,"from django . core . mail . utils import CachedDnsName , DNS_NAME"
"from django.core.mail.message import EmailMessage, EmailMultiAlternatives, SafeMIMEText, SafeMIMEMultipart,","from django . core . mail . message import ( EmailMessage , EmailMultiAlternatives , SafeMIMEText , SafeMIMEMultipart , DEFAULT_ATTACHMENT_MIME_TYPE , make_msgid , BadHeaderError , forbid_multi_line_headers )"
"DEFAULT_ATTACHMENT_MIME_TYPE, make_msgid, BadHeaderError and forbid_multi_line_headers into default name space. __all__ is a list of strings, 'CachedDnsName', 'DNS_NAME', 'EmailMessage', 'EmailMultiAlternatives', 'SafeMIMEText',","__all__ = [ 'CachedDnsName' , 'DNS_NAME' , 'EmailMessage' , 'EmailMultiAlternatives' , 'SafeMIMEText' , 'SafeMIMEMultipart' , 'DEFAULT_ATTACHMENT_MIME_TYPE' , 'make_msgid' , 'BadHeaderError' , 'forbid_multi_line_headers' , 'get_connection' , 'send_mail' , 'send_mass_mail' , 'mail_admins' , 'mail_managers' , ]"
"'SafeMIMEMultipart', 'DEFAULT_ATTACHMENT_MIME_TYPE', 'make_msgid', 'BadHeaderError', 'forbid_multi_line_headers', 'get_connection', 'send_mail', 'send_mass_mail', 'mail_admins' and 'mail_managers'. define function get_connection with backend set to None, fail_silently set to boolean False and dictionary kwds as arguments.","def get_connection ( backend = None , fail_silently = False , ** kwds ) :"
"call the function import_string with backend if exists or settings.EMAIL_BACKEND if not, store the result into klass.",klass = import_string ( backend or settings . EMAIL_BACKEND )
"call the klass method with fail_silently set to fail_silently and dictionary arguments kwds as arguments, return the result.","return klass ( fail_silently = fail_silently , ** kwds )"
"define send_mail funtion with subject, message, from_email, recipient_list, fail_silently set to boolean False,","def send_mail ( subject , message , from_email , recipient_list , fail_silently = False , auth_user = None , auth_password = None , connection = None , html_message = None ) :"
"if connection exists dont modify it, if not call get_connection function with username set to auth_user, password set to auth_password, fail_silently set to fail_silently as arguments, assign it to connection.","connection = connection or get_connection ( username = auth_user , password = auth_password , fail_silently = fail_silently )"
"call the EmailMultiAlternatives function with, subject, message, from_email, recipient_list and connection set to connection, as arguments, assign the result to mail.","mail = EmailMultiAlternatives ( subject , message , from_email , recipient_list , connection = connection )"
"if html_message is True,",if html_message :
call the mail.attach_alternative method with html_message and string 'text/html' as arguments.,"mail . attach_alternative ( html_message , 'text/html' )"
return the evaluated result of the mail.send method.,return mail . send ( )
"define the function send_mass_mail with, datatuple, fail_silently set to False, auth_user set to None, auth_password set to None,","def send_mass_mail ( datatuple , fail_silently = False , auth_user = None , auth_password = None , connection = None ) :"
"if connection exists dont change it, if not call the get_connection function with username set to auth_user,","connection = connection or get_connection ( username = auth_user , password = auth_password , fail_silently = fail_silently )"
"password set to auth_password, fail_silently set to fail_silently as arguments, assign the result to connection. call the EmailMessage function wit subject, message, sender, recipient and connection set to connection,","messages = [ EmailMessage ( subject , message , sender , recipient , connection = connection ) for subject , message , sender , recipient in datatuple ]"
"for every subject, message, sender and recipient in datatuple, store the results in the messages list. return evaluated result of the method connection.send_messages with messages as argument.",return connection . send_messages ( messages )
"define the function mail_admins with subject, message, fails_silently set to boolean False, connection set to None,","def mail_admins ( subject , message , fail_silently = False , connection = None , html_message = None ) :"
"if settings.ADMINS is false,",if not settings . ADMINS :
return nothing.,return
"call the function EmailMultiAlternatives with settings.EMAIL_SUBJECT_PREFIX and subject converted to strings and concatenated,","mail = EmailMultiAlternatives ( '%s%s' % ( settings . EMAIL_SUBJECT_PREFIX , subject ) , message , settings . SERVER_EMAIL , [ a [ 1 ] for a in settings . ADMINS ] , connection = connection )"
"message, settings.SERVER_EMAIL, list of second elements of a for every a in settings.Managers and connection set to connection, as arguments, assign the result to mail. if html_message is true,",if html_message :
call method mail.attach_alternative as html_message and string 'text/hmtl' as arguments.,"mail . attach_alternative ( html_message , 'text/html' )"
call the mail.send method with fail_silently=fail_silently as argument.,mail . send ( fail_silently = fail_silently )
"define the function mail_managers with subject, message, fails_silently set to boolean False, connection set to None,","def mail_managers ( subject , message , fail_silently = False , connection = None , html_message = None ) :"
"if settings.MANAGERS does not exist,",if not settings . MANAGERS :
return nothing.,return
"call the function EmailMultiAlternatives with settings.EMAIL_SUBJECT_PREFIX and subject converted to strings and concatenated,","mail = EmailMultiAlternatives ( '%s%s' % ( settings . EMAIL_SUBJECT_PREFIX , subject ) , message , settings . SERVER_EMAIL , [ a [ 1 ] for a in settings . MANAGERS ] , connection = connection )"
"message, settings.SERVER_EMAIL, list of second elements of a for every a in settings.Managers and connection set to connection, as arguments, assign the result to mail. if html_message is true,",if html_message :
call the mail.attach_alternative method with html_message and string 'text/html' as arguments.,"mail . attach_alternative ( html_message , 'text/html' )"
call the mail.send method with fail_silently set to fail_silently as argument.,mail . send ( fail_silently = fail_silently )
derive the class BaseEmailBackend from the object base class.,class BaseEmailBackend ( object ) :
"define the method __init__ with arguments: self, fail_silently set to boolean False and unpacked dictionary kwargs.","def __init__ ( self , fail_silently = False , ** kwargs ) :"
substitute fail_silently for self.fail_silently.,self . fail_silently = fail_silently
define the method open with argument self.,def open ( self ) :
do nothing.,pass
define the method close with argument self.,def close ( self ) :
do nothing,pass
define the method __enter__ with argument self.,def __enter__ ( self ) :
call the method self.open.,self . open ( )
return self.,return self
"define the method __exit__ with arguments: self, exc_type, exc_value and traceback.","def __exit__ ( self , exc_type , exc_value , traceback ) :"
call the method self.close.,self . close ( )
define the method send_messages with arguments self and email_messages.,"def send_messages ( self , email_messages ) :"
raise an NotImplementedError exception with argument string 'subclasses of BaseEmailBackend must override send_messages() method'.,raise NotImplementedError ( 'subclasses of BaseEmailBackend must override send_messages() method' )
import module sys.,import sys
import module threading.,import threading
from django.core.mail.backends.base import BaseEmailBackend into default name space.,from django . core . mail . backends . base import BaseEmailBackend
from django.utils import six into default name space.,from django . utils import six
derive the class EmailBackend from the BaseEmailBackend base class.,class EmailBackend ( BaseEmailBackend ) :
"define the __init__ method with arguments: self, unpacked list args and unpacked dictionary kwargs.","def __init__ ( self , * args , ** kwargs ) :"
"pop the value under the 'stream' key of the kwargs dictionary, if it exists replace it for self.stream, if not replace sys.stdout for self.stream.","self . stream = kwargs . pop ( 'stream' , sys . stdout )"
"call the method threading.RLock, substitute the result for self._lock.",self . _lock = threading . RLock ( )
"call the __init__ method from the base class of the EmailBackend class, with arguments: unpacked list args and unpacked dictionary kwargs.","super ( EmailBackend , self ) . __init__ ( * args , ** kwargs )"
define the method write_message with arguments self and message.,"def write_message ( self , message ) :"
"call the method message.message, substitute the result for msg.",msg = message . message ( )
"call the method msg.as_bytes, substitute the result for msg_data.",msg_data = msg . as_bytes ( )
"if six.PY3 is boolean True,",if six . PY3 :
"if method msg.get_charset evaluates to true, call the get_output_charset method on the return value of the msg.get_charset method, substitute the result for charset, otherwise if it is false, substitute the string 'utf-8' for charset.",charset = msg . get_charset ( ) . get_output_charset ( ) if msg . get_charset ( ) else 'utf-8'
"call the method msg_data.decode with argument charset, substitute the result for msg_data.",msg_data = msg_data . decode ( charset )
"call the method self.stream.write with argument string '%s\n', with '%s' replaced with msg_data.",self . stream . write ( '%s\n' % msg_data )
write 79 '-' characters into self.stream file stream.,self . stream . write ( '-' * 79 )
write a newline into a self.stream file stream.,self . stream . write ( '\n' )
define the method send_messages with arguments self and email_messages.,"def send_messages ( self , email_messages ) :"
"if email_messages is false,",if not email_messages :
return.,return
msg_count is an integer 0.,msg_count = 0
"call the method self._lock, with the result,",with self . _lock :
"try,",try :
"call the method self.open, substitute the result for stream_created.",stream_created = self . open ( )
"for every message in email_messages,",for message in email_messages :
call the method self.write_message with argument message.,self . write_message ( message )
call the method self.stream.flush.,self . stream . flush ( )
increment msg_count by one.,msg_count += 1
"if stream_created is true,",if stream_created :
call the method self.close.,self . close ( )
"if Exception exception is caught,",except Exception :
"if self.fail_silently is boolean False,",if not self . fail_silently :
raise an exception.,raise
return msg_count.,return msg_count
from django.core.mail.backends.base import BaseEmailBackend into default name space.,from django . core . mail . backends . base import BaseEmailBackend
derive the class EmailBackend from the BaseEmailBackend base class.,class EmailBackend ( BaseEmailBackend ) :
define the method send_messages with arguments self and email_messages.,"def send_messages ( self , email_messages ) :"
"create list out of email_messages, return the length of the list.",return len ( list ( email_messages ) )
import module datetime.,import datetime
import module os.,import os
from django.conf import settings into default name space.,from django . conf import settings
from django.core.exceptions import ImproperlyConfigured into default name space.,from django . core . exceptions import ImproperlyConfigured
from django.core.mail.backends.console import EmailBackend as ConsoleEmailBackend into default name space.,from django . core . mail . backends . console import EmailBackend as ConsoleEmailBackend
from django.utils import six into default name space.,from django . utils import six
derive the class EmailBackend from the ConsoleEmailBackend base class.,class EmailBackend ( ConsoleEmailBackend ) :
"define the __init__ method with arguments: self, unpacked list args and unpacked dictionary kwargs.","def __init__ ( self , * args , ** kwargs ) :"
self._fname is None.,self . _fname = None
"if 'file_path' is contained in kwargs,",if 'file_path' in kwargs :
"pop the value under the 'file_path' key of kwargs dictionary, substitute it for self.file_path.",self . file_path = kwargs . pop ( 'file_path' )
"if not,",else :
"get 'EMAIL_FILE_PATH' from the settings, if it exists, substitute it for self.file_path, if not substitute None for self.file_path.","self . file_path = getattr ( settings , 'EMAIL_FILE_PATH' , None )"
"if self.file_path is not an instance of six.string_types,","if not isinstance ( self . file_path , six . string_types ) :"
"raise an ImproperlyConfigured exception with argument string 'Path for saving emails is invalid: %r', replace '%r' with self.file_path.",raise ImproperlyConfigured ( 'Path for saving emails is invalid: %r' % self . file_path )
"call the os.path.abspath with argument self.file_path, substitute the result for self.file_path.",self . file_path = os . path . abspath ( self . file_path )
"if self.file_path file path exists and it is not a directory,",if os . path . exists ( self . file_path ) and not os . path . isdir ( self . file_path ) :
"raise an ImproperlyConfigured exception with argument string 'Path for saving email messages exists, but is not a directory: %s', replace '%s' with self.file_path.","raise ImproperlyConfigured ( 'Path for saving email messages exists, but is not a directory: %s' % self . file_path )"
"otherwise if self.file_path file path doesnt exists,",elif not os . path . exists ( self . file_path ) :
"try,",try :
call the os.makedirs with argument self.file_path.,os . makedirs ( self . file_path )
"if OSError, renamed to err, is caught,",except OSError as err :
"raise an ImproperlyConfigured exception with argument string 'Could not create directory for saving email messages: %s (%s)',","raise ImproperlyConfigured ( 'Could not create directory for saving email messages: %s (%s)' % ( self . file_path , err ) )"
"replace '%s' with self.file_path and err, respectively. if self.file_path file is not writable,","if not os . access ( self . file_path , os . W_OK ) :"
"raise an ImproperlyConfigured exception with argument string 'Could not write to directory: %s', replace '%s' with self.file_path.",raise ImproperlyConfigured ( 'Could not write to directory: %s' % self . file_path )
set value under the 'stream' key of kwargs dictionary to None.,kwargs [ 'stream' ] = None
call the __init__ method of the base class of the EmailBackend class with arguments: unpacked list args and unpacked dictionary kwargs.,"super ( EmailBackend , self ) . __init__ ( * args , ** kwargs )"
define the method write_message with arguments self and message.,"def write_message ( self , message ) :"
"call the as_bytes method on the return value of the message.message method append to it '\n' character, use it as the argument for the call to the self.stream.write method.",self . stream . write ( message . message ( ) . as_bytes ( ) + b'\n' )
write 79 '-' characters into self.stream file stream.,self . stream . write ( b'-' * 79 )
write a newline character into self.stream file stream.,self . stream . write ( b'\n' )
define the method _get_filename with argument self.,def _get_filename ( self ) :
if self._fname is None:,if self . _fname is None :
"call the strftime function with argument string ""%Y%m%d-%H%M%S"" on the return value of the function datetime.datetime.now, substitute the result for timestamp.","timestamp = datetime . datetime . now ( ) . strftime ( ""%Y%m%d-%H%M%S"" )"
"fname is a string ""%s-%s.log"", with '%s' replaced by timestamp and absolute value of the return value of the function id with argument self, respectively.","fname = ""%s-%s.log"" % ( timestamp , abs ( id ( self ) ) )"
"join self.file_path and fname into a valid file path, substitute it for self._fname.","self . _fname = os . path . join ( self . file_path , fname )"
return self._fname.,return self . _fname
define the method open with argument self.,def open ( self ) :
if self.stream is None:,if self . stream is None :
open the file in mode 'ab' and with file name obtained by calling the self._get_filename method.,"self . stream = open ( self . _get_filename ( ) , 'ab' )"
return boolean True.,return True
return boolean True.,return False
define the method close with argument self.,def close ( self ) :
"try,",try :
"if self.stream is not None,",if self . stream is not None :
call the self.stream.close function.,self . stream . close ( )
"finally perform,",finally :
self.stream is None.,self . stream = None
from django.core import mail into default name space.,from django . core import mail
from django.core.mail.backends.base import BaseEmailBackend into default name space.,from django . core . mail . backends . base import BaseEmailBackend
derive the class EmailBackend from the BaseEmailBackend base class.,class EmailBackend ( BaseEmailBackend ) :
"define the method __init__ with arguments: self, unpacked list args and unpacked dictionary kwargs.","def __init__ ( self , * args , ** kwargs ) :"
"call the method __init__ from the base class of EmailBackend class, with arguments: unpacked list args and unpacked dictionary kwargs.","super ( EmailBackend , self ) . __init__ ( * args , ** kwargs )"
"if mail doesnt have an 'outbox' attribute,","if not hasattr ( mail , 'outbox' ) :"
mail.outbox is an empty list.,mail . outbox = [ ]
define the method send_messages with arguments self and messages.,"def send_messages ( self , messages ) :"
msg_count is integer 0.,msg_count = 0
"for every message in messages,",for message in messages :
call the method message.message.,message . message ( )
increment mes_count by one.,msg_count += 1
call the method mail.outbox.extend with messages.,mail . outbox . extend ( messages )
return msg_count.,return msg_count
import module smtplib.,import smtplib
import module ssl.,import ssl
import module threading.,import threading
from django.conf import settings into default name space.,from django . conf import settings
from django.core.mail.backends.base import BaseEmailBackend into default name space.,from django . core . mail . backends . base import BaseEmailBackend
from django.core.mail.utils import DNS_NAME into default name space.,from django . core . mail . utils import DNS_NAME
from django.core.mail.message import sanitize_address into default name space.,from django . core . mail . message import sanitize_address
derive the class EmailBackend from the BaseEmailBackend base class.,class EmailBackend ( BaseEmailBackend ) :
"define the method __init__ with arguments: self, host set to None, port set to None, username set to None, password set to None,","def __init__ ( self , host = None , port = None , username = None , password = None , use_tls = None , fail_silently = False , use_ssl = None , timeout = None , ** kwargs ) :"
"use_tls set to None, fail_silently set to False, use_ssl set to None, timeout set to None and unpacked dictionary kwargs. call the __init__ method from the base class of the EmailBackend class with argument fail_silently set to fail_silently.","super ( EmailBackend , self ) . __init__ ( fail_silently = fail_silently )"
"if host exists substitute it for self.host, if not substitute settings.EMAIL_HOST for self.host.",self . host = host or settings . EMAIL_HOST
"if port exists substitute it for self.host, if not substitute settings.EMAIL_PORT for self.port.",self . port = port or settings . EMAIL_PORT
"if username is None substitute settings.EMAIL_HOST_USER for self.username, if not substitute username for self.username.",self . username = settings . EMAIL_HOST_USER if username is None else username
"if password is None substitute settings.EMAIL_HOST_PASSWORD for self.username, if not substitute password for self.password.",self . password = settings . EMAIL_HOST_PASSWORD if password is None else password
"if use_tls is None substitute settings.EMAIL_USE_TLS for self.username, if not substitute use_tls for self.use_tls.",self . use_tls = settings . EMAIL_USE_TLS if use_tls is None else use_tls
"if use_ssl is None substitute settings.EMAIL_USE_SSL for self.username, if not substitute use_ssl for self.use_ssl.",self . use_ssl = settings . EMAIL_USE_SSL if use_ssl is None else use_ssl
substitute timeout for self.timeout.,self . timeout = timeout
"if self.use_ssl and self.use_tls are boolean True,",if self . use_ssl and self . use_tls :
"raise an ValueError exception with argument string ""EMAIL_USE_TLS/EMAIL_USE_SSL are mutually exclusive, so only set one of those settings to True."".","raise ValueError ( ""EMAIL_USE_TLS/EMAIL_USE_SSL are mutually exclusive, so only set "" ""one of those settings to True."" )"
self.connection is None.,self . connection = None
"call the method threading.RLock, substitute the result for self._lock.",self . _lock = threading . RLock ( )
define the method open with argument self.,def open ( self ) :
"if self.connection is true,",if self . connection :
"return boolean False,",return False
"substitute smtplib.SMTP_SSL for connection_class if self.use_ssl is true, if not substitute smtplib.SMTP for connection_class.",connection_class = smtplib . SMTP_SSL if self . use_ssl else smtplib . SMTP
connection_params is a dictionary with 1 initial entry: return value of the function DNS_NAME.get_fqdn for 'local_hostname'.,connection_params = { 'local_hostname' : DNS_NAME . get_fqdn ( ) }
"if self.timeout is not None,",if self . timeout is not None :
set value under the 'timeout' key of the connection_params to self.timeout.,connection_params [ 'timeout' ] = self . timeout
"try,",try :
"self.connection is a instance of a class contained in connection_class, instantiated with arguments: self.host, self.port,","self . connection = connection_class ( self . host , self . port , ** connection_params )"
"and unpacked dictionary connection_params. if self.use_ssl and self.use_tls are false,",if not self . use_ssl and self . use_tls :
call the method self.connection.ehlo.,self . connection . ehlo ( )
call the method self.connection.starttls.,self . connection . starttls ( )
call the method self.connection.ehlo.,self . connection . ehlo ( )
"if self.username and self.password are true,",if self . username and self . password :
call the method self.connection.login with arguments self.username and self.password.,"self . connection . login ( self . username , self . password )"
return boolean True.,return True
"if smtplib.SMTPException exception is caught,",except smtplib . SMTPException :
"if self.fail_silently is boolean False,",if not self . fail_silently :
raise an exception.,raise
define the method close with argument self.,def close ( self ) :
"if self.connection is None,",if self . connection is None :
return nothing.,return
"try,",try :
"try,",try :
call the method self.connection.quit.,self . connection . quit ( )
"if ssl.SSLError or smtplib.SMTPServerDisconnected exception occurred,","except ( ssl . SSLError , smtplib . SMTPServerDisconnected ) :"
call the method self.connection.close.,self . connection . close ( )
"if smtplib.SMTPException exception is caught,",except smtplib . SMTPException :
"if self.fail_silently is boolean True,",if self . fail_silently :
return nothing.,return
raise an exception.,raise
"finally perform,",finally :
self.connection is None.,self . connection = None
define the method send_messages with arguments self and email_message.,"def send_messages ( self , email_messages ) :"
"if email_messages is false,",if not email_messages :
return nothing.,return
"call the method self._lock, with the return value,",with self . _lock :
"call the method self.open, substitute the result for the new_conn_created.",new_conn_created = self . open ( )
"if self.connection is false,",if not self . connection :
return nothing.,return
num_sent is an integer 0.,num_sent = 0
for every message in email_messages:,for message in email_messages :
"call the method self._send with argument message, substitute the result for sent.",sent = self . _send ( message )
"if sent is true,",if sent :
increment num_sent by one.,num_sent += 1
"if new_conn_created is true,",if new_conn_created :
call the self.close method.,self . close ( )
return num_sent.,return num_sent
define the method _send with arguments self and email_message.,"def _send ( self , email_message ) :"
"call the email_message.recipients method, if it evaluates to false,",if not email_message . recipients ( ) :
return boolean False.,return False
"call the function sanitize_address with arguments email_message.from_email and email_message.encoding, substitute the result for from_email.","from_email = sanitize_address ( email_message . from_email , email_message . encoding )"
"call the function sanitize_address with arguments addr and email_message.encoding, for every addr in return value of the function email_message.recipients, store the results in a recipients list.","recipients = [ sanitize_address ( addr , email_message . encoding ) for addr in email_message . recipients ( ) ]"
"call the function email_message.message, substitute the result for message.",message = email_message . message ( )
"try,",try :
"call the method self.connection.sendmail with arguments: from_email, recipients and return value of the function message.as_bytes.","self . connection . sendmail ( from_email , recipients , message . as_bytes ( ) )"
"if smtplib.SMTPException exception is caught,",except smtplib . SMTPException :
"if self.fail_silently is false,",if not self . fail_silently :
raise an exception.,raise
return boolean False.,return False
return boolean True.,return True
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
import module mimetypes.,import mimetypes
import module os.,import os
import module random.,import random
import module sys.,import sys
import module time.,import time
"from email import charset as Charset, encoders as Encoders, message_from_string and generator.","from email import ( charset as Charset , encoders as Encoders , message_from_string , generator )"
from email.message import Message into default name space.,from email . message import Message
from email.mime.text import MIMEText into default name space.,from email . mime . text import MIMEText
from email.mime.multipart import MIMEMultipart into default name space.,from email . mime . multipart import MIMEMultipart
from email.mime.base import MIMEBase into default name space.,from email . mime . base import MIMEBase
from email.mime.message import MIMEMessage into default name space.,from email . mime . message import MIMEMessage
from email.header import Header into default name space.,from email . header import Header
"from email.utils import formatdate, getaddresses, formataddr and parseaddr into default name space.","from email . utils import formatdate , getaddresses , formataddr , parseaddr"
from django.conf import settings into default name space.,from django . conf import settings
from django.core.mail.utils import DNS_NAME into default name space.,from django . core . mail . utils import DNS_NAME
from django.utils.encoding import force_text into default name space.,from django . utils . encoding import force_text
from django.utils import six into default name space.,from django . utils import six
"call the function Charset.Charset with argument string 'utf-8', substitute the result for utf8_charset.",utf8_charset = Charset . Charset ( 'utf-8' )
utf8_charset.body_encoding is None.,utf8_charset . body_encoding = None
DEFAULT_ATTACHMENT_MIME_TYPE is a string 'application/octet-stream'.,DEFAULT_ATTACHMENT_MIME_TYPE = 'application/octet-stream'
derive the class BadHeaderError from the ValueError base class.,class BadHeaderError ( ValueError ) :
do nothing.,pass
define the function make_msgid with argument idstring set to None.,def make_msgid ( idstring = None ) :
"call the function time.time, substitute the result for timeval.",timeval = time . time ( )
"call the function time.gmtime with argument timeval, use string '%Y%m%d%H%M%S' and the previous result as an argument for the call to the time.strftime function, substitute the result for utcdate.","utcdate = time . strftime ( '%Y%m%d%H%M%S' , time . gmtime ( timeval ) )"
"try,",try :
"call the function os.getpid, substitute it for pid.",pid = os . getpid ( )
"if AttributeError exception is caught,",except AttributeError :
pid is integer 1.,pid = 1
"call the function random.randrange with argument integer 100000, substitute the result for randint.",randint = random . randrange ( 100000 )
"if idstring is None,",if idstring is None :
idstring is an empty string.,idstring = ''
"if not,",else :
"append idstring to the '.' character, substitute it for idstring.",idstring = '.' + idstring
substitute DNS_NAME for idhost.,idhost = DNS_NAME
"msgid is a string '<%s.%s.%s%s@%s>', replace '%s' with utcdate, pid, randint, idstring and idhost, respectively.","msgid = '<%s.%s.%s%s@%s>' % ( utcdate , pid , randint , idstring , idhost )"
return msgid.,return msgid
"ADDRESS_HEADERS is a set containing strings: 'from', 'sender', 'reply-to', 'to', 'cc', 'bcc', 'resent-from', 'resent-sender',","ADDRESS_HEADERS = set ( [ 'from' , 'sender' , 'reply-to' , 'to' , 'cc' , 'bcc' , 'resent-from' , 'resent-sender' , 'resent-to' , 'resent-cc' , 'resent-bcc' , ] )"
"'resent-to', 'resent-cc' and 'resent-bcc'. define the function forbid_multi_line_headers with arguments: name, val and encoding.","def forbid_multi_line_headers ( name , val , encoding ) :"
if encoding does not exists substitute it for settings.DEFAULT_CHARSET.,encoding = encoding or settings . DEFAULT_CHARSET
"call the function force_text with argument val, substitute it for val.",val = force_text ( val )
"if characters '\n' or '\r' are contained in val,",if '\n' in val or '\r' in val :
"raise an BadHeaderError exception with argument string ""Header values can't contain newlines (got %r for header %r)"",","raise BadHeaderError ( ""Header values can't contain newlines (got %r for header %r)"" % ( val , name ) )"
"where '%r' are replaced by val and name, respectively. try,",try :
call the method val.encode with argument string 'ascii'.,val . encode ( 'ascii' )
"if UnicodeEncodeError exception is caught,",except UnicodeEncodeError :
"convert name to lower case, if it is contained in ADDRESS_HEADERS,s",if name . lower ( ) in ADDRESS_HEADERS :
"call the function sanitize_address with arguments addr and encoding, for every addr in return value of the getadresses function with tuple containing val as argument, join all the results into a string separated by ', ', substitute the result for val.","val = ', ' . join ( sanitize_address ( addr , encoding ) for addr in getaddresses ( ( val , ) ) )"
"if not,",else :
"call the encode function on the Header class instance, created with arguments val and encoding, substitute the result for val.","val = Header ( val , encoding ) . encode ( )"
"if not,",else :
"if name converted to lower case equals to string 'subject',",if name . lower ( ) == 'subject' :
"call the encode function on the Header class instance, created with argument val, substitute the result for val.",val = Header ( val ) . encode ( )
return name converted to a string and val.,"return str ( name ) , val"
define the function sanitize_address with arguments addr and encoding.,"def sanitize_address ( addr , encoding ) :"
"if addr is a instance of six.string_types,","if isinstance ( addr , six . string_types ) :"
"call the parseaddr function with return value of the force_text with argument addr, as argument, substitute the result for addr.",addr = parseaddr ( force_text ( addr ) )
nm and addr are addr.,"nm , addr = addr"
"try,",try :
"call the encode function on the Header class instance, created with arguments nm and encoding, substitute the result for nm.","nm = Header ( nm , encoding ) . encode ( )"
"if UnicodeEncodeError exception is caught,",except UnicodeEncodeError :
"call the encode function on the Header class instance, created with arguments nm and string 'utf-8', substitute the result for nm.","nm = Header ( nm , 'utf-8' ) . encode ( )"
"try,",try :
call the addr.encode method with string 'ascii' as an argument.,addr . encode ( 'ascii' )
"if UnicodeEncodeError exception is caught,",except UnicodeEncodeError :
"if character '@' is contained in addr,",if '@' in addr :
"call the addr.split method with character '@' and integer 1 as arguments, substitute the result for localpart and domain, respectively.","localpart , domain = addr . split ( '@' , 1 )"
"instantiate Header class with localpart and encoding, convert it to a string, substitute the result for localpart.","localpart = str ( Header ( localpart , encoding ) )"
call the decode function with argument string 'ascii' on the return value of the method domain.encode with argument string 'idna' substitute the result for domain.,domain = domain . encode ( 'idna' ) . decode ( 'ascii' )
"join localpart and domain in a string separated by '@' character, substitute it for addr.","addr = '@' . join ( [ localpart , domain ] )"
"if not,",else :
"call the encode function on the Header class instance, created with arguments addr and encoding, substitute the result for addr.","addr = Header ( addr , encoding ) . encode ( )"
call the formataddr function with argument tuple containing 2 elements nm and addr.,"return formataddr ( ( nm , addr ) )"
derive the class MIMEMixin.,class MIMEMixin ( ) :
define the method as_string with arguments self and unixfrom set to boolean False.,"def as_string ( self , unixfrom = False ) :"
fp is a instance of a class six.StringIO.,fp = six . StringIO ( )
g is an instance of a class generator.Generator called with fp and mangle_from_ set to False.,"g = generator . Generator ( fp , mangle_from_ = False )"
call the method g.flatten with arguments self and unixfrom set to unixfrom.,"g . flatten ( self , unixfrom = unixfrom )"
"call the method fp.getvalue, return the result.",return fp . getvalue ( )
"if six.PY2 is boolean True,",if six . PY2 :
substitute as_string for as_bytes.,as_bytes = as_string
"if not,",else :
define the method as_bytes with arguments self and unixfrom set to boolean False.,"def as_bytes ( self , unixfrom = False ) :"
fp is a instance of a class six.BytesIO.,fp = six . BytesIO ( )
g is an instance of a class generator.BytesGenerator called with fp and mangle_from_ set to False.,"g = generator . BytesGenerator ( fp , mangle_from_ = False )"
call the method g.flatten with arguments self and unixfrom set to unixfrom.,"g . flatten ( self , unixfrom = unixfrom )"
"call the method fp.getvalue, return the result.",return fp . getvalue ( )
derive the class SafeMIMEMessage from the MIMEMixin and MIMEMessage base class.,"class SafeMIMEMessage ( MIMEMixin , MIMEMessage ) :"
"define the method __setitem__ with arguments self, name and val.","def __setitem__ ( self , name , val ) :"
"call the function forbid_multi_line_headers with 3 arguments: name, val and string 'ascii', substitute the result for name and val, respectively.","name , val = forbid_multi_line_headers ( name , val , 'ascii' )"
"call the method MIMEMessage.__setitem__ with arguments self, name and val.","MIMEMessage . __setitem__ ( self , name , val )"
derive the class SafeMIMEText from the MIMEMixin and MIMEText base class.,"class SafeMIMEText ( MIMEMixin , MIMEText ) :"
"define the __init__ method with arguments: self, text, subtype and charset.","def __init__ ( self , text , subtype , charset ) :"
substitute charset for self.encoding.,self . encoding = charset
"if charset equals to string 'utf-8',",if charset == 'utf-8' :
"call the method MIMEText.__init__ with 4 arguments: self, text, subtype and None.","MIMEText . __init__ ( self , text , subtype , None )"
delete the value under the 'Content-Transfer-Encoding' key of self dictionary.,del self [ 'Content-Transfer-Encoding' ]
"if integers 3 and 2 in a tuple are smaller than the sys.version_info and sys.version_info is smaller than integers 3,4 and 4 in a tuple, respectively,","if ( 3 , 2 ) < sys . version_info < ( 3 , 3 , 4 ) :"
"call the method text.encode with argument utf8_charset.output_charset, substitute the result for payload.",payload = text . encode ( utf8_charset . output_charset )
"call the method payload.decode with 2 arguments: string 'ascii' and string 'surrogateescape', substitute the result for self._payload.","self . _payload = payload . decode ( 'ascii' , 'surrogateescape' )"
call the method self.set_charset with utf8_charset as an argument.,self . set_charset ( utf8_charset )
"if not,",else :
"call the method payload.decode with 2 arguments: text and utf8_charset, substitute the result for self._payload.","self . set_payload ( text , utf8_charset )"
"call the method self.replace_header with argument string 'Content-Type', 'text/%s; charset=""%s""', where '%s' symbols are replaced by:","self . replace_header ( 'Content-Type' , 'text/%s; charset=""%s""' % ( subtype , charset ) )"
"subtype and charset, respectively. if not,",else :
"call the method MIMEText.__init__ with 4 arguments: self, text, subtype and charset.","MIMEText . __init__ ( self , text , subtype , charset )"
"define the method __setitem__ with arguments self, name and val.","def __setitem__ ( self , name , val ) :"
"call the function forbid_multi_line_headers with 3 arguments: name, val and self.encoding, substitute the result for name and val, respectively.","name , val = forbid_multi_line_headers ( name , val , self . encoding )"
"call the method MIMEText.__setitem__ with arguments self, name and val.","MIMEText . __setitem__ ( self , name , val )"
derive the class SafeMIMEMultipart from the MIMEMixin and MIMEMultipart base class.,"class SafeMIMEMultipart ( MIMEMixin , MIMEMultipart ) :"
"define the method __init__ with 6 arguments: self, _subtype set to string 'mixed', boundary set to None, _subparts set to None,","def __init__ ( self , _subtype = 'mixed' , boundary = None , _subparts = None , encoding = None , ** _params ) :"
encoding set to None and unpacked dictionary _params. substitute encoding for self.encoding.,self . encoding = encoding
"call the method MIMEMultipart.__init__ with 5 arguments: self, _subtype, boundary, _subparts and unpacked dictionary _params.","MIMEMultipart . __init__ ( self , _subtype , boundary , _subparts , ** _params )"
"define the method __setitem__ with arguments self, name and val.","def __setitem__ ( self , name , val ) :"
"call the function forbid_multi_line_headers with 3 arguments: name, val and self.encoding, substitute the result for name and val, respectively.","name , val = forbid_multi_line_headers ( name , val , self . encoding )"
"call the method MIMEMultipart.__setitem__ with arguments self, name and val.","MIMEMultipart . __setitem__ ( self , name , val )"
derive the class EmailMessage from the object base class.,class EmailMessage ( object ) :
content_subtype is a string 'plain'.,content_subtype = 'plain'
mixed_subtype is a string 'mixed'.,mixed_subtype = 'mixed'
encoding is None.,encoding = None
"define the method __init__ with 10 arguments: self, subject set to an empty string, body set to an empty string,","def __init__ ( self , subject = '' , body = '' , from_email = None , to = None , bcc = None , connection = None , attachments = None , headers = None , cc = None ) :"
"if to is true,",if to :
"if to is not an six.string_types instance raise an error with message string '""to"" argument must be a list or tuple'.","assert not isinstance ( to , six . string_types ) , '""to"" argument must be a list or tuple'"
"put to into a list, assign it to self.to.",self . to = list ( to )
"if not,",else :
self.to is an empty list.,self . to = [ ]
"if cc is true,",if cc :
"if cc is not an six.string_types instance raise an error with message string '""cc"" argument must be a list or tuple'.","assert not isinstance ( cc , six . string_types ) , '""cc"" argument must be a list or tuple'"
"put cc into a list, assign it to self.cc.",self . cc = list ( cc )
"if not,",else :
self.cc is an empty list.,self . cc = [ ]
"if bcc is true,",if bcc :
"if bcc is not an six.string_types instance raise an error with message string '""bcc"" argument must be a list or tuple'.","assert not isinstance ( bcc , six . string_types ) , '""bcc"" argument must be a list or tuple'"
"put bcc into a list, assign it to self.bcc.",self . bcc = list ( bcc )
"if not,",else :
self.bcc is an empty list.,self . bcc = [ ]
"if from_email exists substitute from_email for self.from_email, if not substitute settings.DEFAULT_FROM_EMAIL for self.from_email.",self . from_email = from_email or settings . DEFAULT_FROM_EMAIL
substitute subject for self.subject.,self . subject = subject
substitute body for self.body.,self . body = body
"if attachments exists substitute it for self.attachments, if not attachments is an empty list.",self . attachments = attachments or [ ]
"if headers exists substitute it for self.extra_headers, if not extra_headers is an empty dictionary.",self . extra_headers = headers or { }
substitute connection for self.connection.,self . connection = connection
define the method get_connection with arguments self and fail_silently set to boolean False.,"def get_connection ( self , fail_silently = False ) :"
from django.core.mail import get_connection into default name space.,from django . core . mail import get_connection
"if self.connection is false,",if not self . connection :
"call the function get_connection with argument fail_silently set to fail_silently, substitute it for self.connection.",self . connection = get_connection ( fail_silently = fail_silently )
return self.connection.,return self . connection
define the method message with argument self.,def message ( self ) :
"if self.encoding exists substitute it for encoding, if not substitute settings.DEFAULT_CHARSET for encoding.",encoding = self . encoding or settings . DEFAULT_CHARSET
"msg is a instance of a SafeMIMEText class created with arguments: self.body, self.content_subtype and encoding.","msg = SafeMIMEText ( self . body , self . content_subtype , encoding )"
"call the self._create_message method with argument msg, substitute it for msg.",msg = self . _create_message ( msg )
substitute self.subject for value under the 'Subject' key of msg dictionary.,msg [ 'Subject' ] = self . subject
"call the method self.extra_headers.get with string 'From' and self.from_email as arguments, substitute the result for value under the 'From' key of msg dictionary.","msg [ 'From' ] = self . extra_headers . get ( 'From' , self . from_email )"
"call the method self.extra_headers.get with arguments: string 'To' and joined string from self.to elements separated by ', ',","msg [ 'To' ] = self . extra_headers . get ( 'To' , ', ' . join ( self . to ) )"
"substitute the result for value under the 'To' key of msg dictionary. if self.cc is true,",if self . cc :
"join elements of self.cc into a string separated by ', ', substitute the result for value under the 'Cc' key of msg dictionary.","msg [ 'Cc' ] = ', ' . join ( self . cc )"
"call the key.lower method for every key in self.extra_headers, join the results into a header_names.",header_names = [ key . lower ( ) for key in self . extra_headers ]
"if 'date' is not in header_names,",if 'date' not in header_names :
"call the formatdate function, substitute it for value under the 'Date' key of msg dictionary.",msg [ 'Date' ] = formatdate ( )
"if message-id' is not in header_names,",if 'message-id' not in header_names :
"call the make_msgid function, substitute it for value under the 'Message-ID' key of msg dictionary.",msg [ 'Message-ID' ] = make_msgid ( )
"for every name and value in return value of the method self.extra_headers.items,","for name , value in self . extra_headers . items ( ) :"
"convert name to lower case if it equals to string 'from' or 'to,","if name . lower ( ) in ( 'from' , 'to' ) :"
"skip this loop execution,",continue
substitute value for value under name key of msg dictionary.,msg [ name ] = value
return msg.,return msg
define the method recipients with argument self.,def recipients ( self ) :
"add together self.to, self.cc and self.bcc, return the result.",return self . to + self . cc + self . bcc
define the method send with arguments self and fail_silently set to boolean False.,"def send ( self , fail_silently = False ) :"
"call the method self.recipients, if it evaluates to false,",if not self . recipients ( ) :
return an integer 0.,return 0
"call the method self.get_connection with argument fail_silently, on the result call the method send_messages with one argument: list containing self, return the result.",return self . get_connection ( fail_silently ) . send_messages ( [ self ] )
"define the method attach with 4 arguments: self, filename set to None, content set to None and mimetype set to None.","def attach ( self , filename = None , content = None , mimetype = None ) :"
"if filename is an instance of MIMEBase,","if isinstance ( filename , MIMEBase ) :"
if content is not None raise an error.,assert content is None
if mimetype is not None raise an error.,assert mimetype is None
append filename to the self.attachments list.,self . attachments . append ( filename )
"if not,",else :
if content is not None raise an error.,assert content is not None
"append a tuple containing 3 elements: filename, content, mimetype to self.attachments list.","self . attachments . append ( ( filename , content , mimetype ) )"
"define the method attach_file with arguments self, path and mimetype set to None.","def attach_file ( self , path , mimetype = None ) :"
"call the os.path.basename with path as argument, substitute the result for filename.",filename = os . path . basename ( path )
"open file named path in 'rb' mode, with file descriptor as f,","with open ( path , 'rb' ) as f :"
"read the whole file f, substitute the result for content.",content = f . read ( )
"call the method self.attach with arguments filename, content and mimetype.","self . attach ( filename , content , mimetype )"
define the method _create_message with arguments self and msg.,"def _create_message ( self , msg ) :"
"call the method self._create_attachments with argument msg, return the result.",return self . _create_attachments ( msg )
define the method _create_attachments with arguments self and msg.,"def _create_attachments ( self , msg ) :"
"if self.attachments is true,",if self . attachments :
"if self.encoding exists substitute it for encoding, if not substitute settings.DEFAULT_CHARSET for encoding.",encoding = self . encoding or settings . DEFAULT_CHARSET
substitute msg for body_msg.,body_msg = msg
"msg is an instance of a class SafeMIMEMultipart, created with arguments: _subtype set to self.mixed_subtype and encoding set to encoding.","msg = SafeMIMEMultipart ( _subtype = self . mixed_subtype , encoding = encoding )"
"if self.body is true,",if self . body :
call the method msg.attach with an argument body_msg.,msg . attach ( body_msg )
"for every attachment in self.attachments,",for attachment in self . attachments :
"if attachment is an instance of MIMEBase,","if isinstance ( attachment , MIMEBase ) :"
call the method msg.attach with an argument attachment.,msg . attach ( attachment )
"if not,",else :
"call the method self._create_attachment with an unpacked list attachment as an argument, use the result as an argument for the call to the msg.attach method.",msg . attach ( self . _create_attachment ( * attachment ) )
return msg.,return msg
"define the method _create_mime_attachment with arguments self, content and mimetype.","def _create_mime_attachment ( self , content , mimetype ) :"
"call the method mimetype.split with arguments: character '/' and integer 1, substitute the result for basetype and subtype, respectively.","basetype , subtype = mimetype . split ( '/' , 1 )"
"if basetype equals a string 'text',",if basetype == 'text' :
"if self.encoding exists substitute it for encoding, if not substitute settings.DEFAULT_CHARSET for encoding.",encoding = self . encoding or settings . DEFAULT_CHARSET
"attachment is an instance of a class SafeMIMEText, created with arguments: content, subtype and encoding.","attachment = SafeMIMEText ( content , subtype , encoding )"
"otherwise if basetype equals a string 'message' and subtype equals a string 'rfc822',",elif basetype == 'message' and subtype == 'rfc822' :
"if content is an instance of a EmailMessage class,","if isinstance ( content , EmailMessage ) :"
"call the method content.message, substitute the result for content.",content = content . message ( )
"otherwise if content is not an instance of Message class,","elif not isinstance ( content , Message ) :"
"call the message_from_string function with an argument content, substitute the result for content.",content = message_from_string ( content )
"attachment is an instance of a class SafeMIMEMessage, created with the arguments content and subtype.","attachment = SafeMIMEMessage ( content , subtype )"
"if not,",else :
"attachment is an instance of a class MIMEBase, created with the arguments basetype and subtype.","attachment = MIMEBase ( basetype , subtype )"
call the method attachment.set_payload with an argument content.,attachment . set_payload ( content )
call the method Encoders.encode_base64 with an argument attachment.,Encoders . encode_base64 ( attachment )
return attachment.,return attachment
"define the method _create_attachment with 4 arguments: self, filename, content and mimetype set to None.","def _create_attachment ( self , filename , content , mimetype = None ) :"
"if mimetype is None,",if mimetype is None :
"call the mimetypes.guess_type with an argument filename, assign the result to the mimetype and _, respectively.","mimetype , _ = mimetypes . guess_type ( filename )"
"if mimetype is None,",if mimetype is None :
substitute DEFAULT_ATTACHMENT_MIME_TYPE for mimetype.,mimetype = DEFAULT_ATTACHMENT_MIME_TYPE
"call the method self._create_mime_attachment with the arguments content and mimetype, substitute the result for attachment.","attachment = self . _create_mime_attachment ( content , mimetype )"
"if filename is true,",if filename :
"try,",try :
call the method filename.encode with an argument string 'ascii',filename . encode ( 'ascii' )
"if UnicodeEncodeError exception is caught,",except UnicodeEncodeError :
"if six.PY2 is true,",if six . PY2 :
"call the method filename.encode with an argument string 'utf-8', substitute the result for filename.",filename = filename . encode ( 'utf-8' )
"filename is a tuple containing 3 initial elements: string 'utf-8', and empty string and filename.","filename = ( 'utf-8' , '' , filename )"
"call the method attachment.add_header with 3 arguments: string 'Content-Disposition', string 'attachment' and filename set to filename.","attachment . add_header ( 'Content-Disposition' , 'attachment' , filename = filename )"
return attachment.,return attachment
derive the class EmailMultiAlternatives from the EmailMessage base class.,class EmailMultiAlternatives ( EmailMessage ) :
alternative_subtype is a string 'alternative'.,alternative_subtype = 'alternative'
"define the method __init__ with 11 arguments: self, subject set to an empty string, body set to an empty string,","def __init__ ( self , subject = '' , body = '' , from_email = None , to = None , bcc = None , connection = None , attachments = None , headers = None , alternatives = None , cc = None ) :"
"call the method __init__ from the base class of the EmailMultiAlternatives class, with 9 arguments: subject, body, from_email, to,","super ( EmailMultiAlternatives , self ) . __init__ ( subject , body , from_email , to , bcc , connection , attachments , headers , cc )"
"bcc, connection, attachments, headers and cc. if alternatives exists substitute it for self.alternatives, if not self.alternatives is an empty list.",self . alternatives = alternatives or [ ]
"define the method attach_alternative with arguments self, content and mimetype.","def attach_alternative ( self , content , mimetype ) :"
"if content is None, raise an error.",assert content is not None
"if mimetype is None, raise an error.",assert mimetype is not None
"append a tuple containing 2 elements: content and mimetype, to the self.alternatives list.","self . alternatives . append ( ( content , mimetype ) )"
define the method _create_message with arguments self and msg.,"def _create_message ( self , msg ) :"
"call the method self._create_alternatives with an argument msg, use it as an argument for the call to the self._create_attachments method, return the result.",return self . _create_attachments ( self . _create_alternatives ( msg ) )
define the method _create_alternatives with arguments self and msg.,"def _create_alternatives ( self , msg ) :"
"if self.encoding exists substitute it for encoding, if not substitute settings.DEFAULT_CHARSET for encoding.",encoding = self . encoding or settings . DEFAULT_CHARSET
"if self.alternatives is true,",if self . alternatives :
substitute msg for body_msg.,body_msg = msg
"msg is an instance of a class SafeMIMEMultipart, created with the arguments: _subtype set to self.alternative_subtype and encoding set to encoding.","msg = SafeMIMEMultipart ( _subtype = self . alternative_subtype , encoding = encoding )"
"if self.body is true,",if self . body :
call the msg.attach with an argument body_msg.,msg . attach ( body_msg )
"for every alternative in self.alternatives,",for alternative in self . alternatives :
"call the method self._create_mime_attachment with unpacked list alternative as an argument, use the result as an argument for the call to the msg.attach method.",msg . attach ( self . _create_mime_attachment ( * alternative ) )
return msg.,return msg
import module socket.,import socket
derive class CachedDnsName from the object base class.,class CachedDnsName ( object ) :
define the method __str__ with argument self.,def __str__ ( self ) :
"evaluate the self.get_fqdn method, return the result.",return self . get_fqdn ( )
define the method get_fqdn with argument self.,def get_fqdn ( self ) :
"if self doesnt have an attribute '_fqdn',","if not hasattr ( self , '_fqdn' ) :"
"call the function socket.getfqdn, substitute the result for self._fqdn.",self . _fqdn = socket . getfqdn ( )
return self._fqdn.,return self . _fqdn
DNS_NAME is a instance of CachedDnsName class.,DNS_NAME = CachedDnsName ( )
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
import module collections.,import collections
from importlib import import_module into default name space.,from importlib import import_module
import module os.,import os
import module sys.,import sys
import module django.,import django
from django.apps import apps into default name space.,from django . apps import apps
from django.conf import settings into default name space.,from django . conf import settings
from django.core.exceptions import ImproperlyConfigured into default name space.,from django . core . exceptions import ImproperlyConfigured
"from django.core.management.base import BaseCommand, CommandError, CommandParser and handle_default_options into default name space.","from django . core . management . base import ( BaseCommand , CommandError , CommandParser , handle_default_options )"
from django.core.management.color import color_style into default name space.,from django . core . management . color import color_style
from django.utils import lru_cache into default name space.,from django . utils import lru_cache
from django.utils import six into default name space.,from django . utils import six
define the function find_commands with an argument management_dir.,def find_commands ( management_dir ) :
"join management_dir and string 'commands' into a file path name, substitute it for command_dir.","command_dir = os . path . join ( management_dir , 'commands' )"
"try,",try :
"for every f in return value of the os.listdir function called with an argument command_dir, append f without 3 last elements to a list, only if f doesnt start with character '_' and doesnt ends with string '.py', return the resulting list.",return [ f [ : - 3 ] for f in os . listdir ( command_dir ) if not f . startswith ( '_' ) and f . endswith ( '.py' ) ]
"if OSError exception is caught,",except OSError :
return an empty list.,return [ ]
define the function load_command_class with arguments: app_name and name.,"def load_command_class ( app_name , name ) :"
"replace '%s' in string '%s.management.commands.%s' with app_name and name, respectively, use it as an result for the call to the","module = import_module ( '%s.management.commands.%s' % ( app_name , name ) )"
"import_module function, substitute the result for module. return an instance of the module.Command class.",return module . Command ( )
decorator lru_cache.lru_cache with an argument maxsize set to None.,@ lru_cache . lru_cache ( maxsize = None )
define the function get_commands.,def get_commands ( ) :
"commands is an dictionary containing elements: string 'django.core' for every name in the function find_commands return value, called with first element of __path__ as an argument.",commands = { name : 'django.core' for name in find_commands ( __path__ [ 0 ] ) }
"if settings.configured is false,",if not settings . configured :
return commands.,return commands
"for every app_config in reversed list created out of the return value of the function apps.get_app_configs,",for app_config in reversed ( list ( apps . get_app_configs ( ) ) ) :
"join app_config.path and string 'management' into a file path, substitute it for path.","path = os . path . join ( app_config . path , 'management' )"
"call the method commands.update, with an argument dictionary containing entries: app_config_name for name, for every name in return value of the function find_commands, called with an argument path.",commands . update ( { name : app_config . name for name in find_commands ( path ) } )
return commands.,return commands
"define the function call_command with 3 arguments: name, unpacked list args and unpacked dictionary options.","def call_command ( name , * args , ** options ) :"
"try,",try :
"call the function get_commands, substitute the value under the name key of the return value, for app_name.",app_name = get_commands ( ) [ name ]
"if KeyError exception is caught,",except KeyError :
"raise an CommandError exception with an argument string ""Unknown command: %r"", with '%r' replaced by name.","raise CommandError ( ""Unknown command: %r"" % name )"
"if app_name is an instance of BaseCommand,","if isinstance ( app_name , BaseCommand ) :"
substitute app_namefor command.,command = app_name
"if not,",else :
"call the function load_command_class with arguments: app_name and name, substitute the result for command.","command = load_command_class ( app_name , name )"
"all the method command.create_parser with arguments: empty and name, substitute the result for parser.","parser = command . create_parser ( '' , name )"
"if command.use_argparse is true,",if command . use_argparse :
"call the method parser.parse_args with an argument args set to args, substitute the result for defaults.",defaults = parser . parse_args ( args = args )
"create dictionary out of the unpacked dictionary options, using defaults._get_kwargs as a mapping function, substitute the result for defaults.","defaults = dict ( defaults . _get_kwargs ( ) , ** options )"
"if not,",else :
"call the method parser.parse_args with an arguments args set to an empty list, assign the result for defaults and _, respectively.","defaults , _ = parser . parse_args ( args = [ ] )"
"create dictionary out of the unpacked dictionary options, using defaults.__dict__ as a mapping function, substitute the result for defaults.","defaults = dict ( defaults . __dict__ , ** options )"
"call the command.execute method with arguments: unpacked list args and unpacked dictionary defaults, return the result.","return command . execute ( * args , ** defaults )"
derive the class ManagementUtility from object base class.,class ManagementUtility ( object ) :
define the method __init__ with arguments: self class instance and argv set to None.,"def __init__ ( self , argv = None ) :"
"if argv is true, substitue it for self.argv, if not substitute sys.argv for self.argv.",self . argv = argv or sys . argv [ : ]
"call the function os.path.basename with first element of self.argv as an argument, substitute the result for self.prog_name.",self . prog_name = os . path . basename ( self . argv [ 0 ] )
self.settings_exception is None.,self . settings_exception = None
define the method main_help_text with arguments: self class instance and commands_only set to boolean False.,"def main_help_text ( self , commands_only = False ) :"
"if commands_only is true,",if commands_only :
"call the function get_commands, call the method keys on the result, substitute sorted result for usage.",usage = sorted ( get_commands ( ) . keys ( ) )
"if not,",else :
"usage is a list containing 4 entries: an empty string, string ""Type '%s help <subcommand>' for help on a specific subcommand."",","usage = [ """" , ""Type '%s help <subcommand>' for help on a specific subcommand."" % self . prog_name , """" , ""Available subcommands:"" , ]"
"where '%s' is replaced with self.prog_name, an empty string and string ""Available subcommands:"". call the method collections.defaultdict with a argument: lambda function without arguments that returns an empty list,",commands_dict = collections . defaultdict ( lambda : [ ] )
"substitute the result for commands_dict. for every name and app in return value of the function six.iteritems calle with return argument of function get_commands as an arugment,","for name , app in six . iteritems ( get_commands ( ) ) :"
"if app equals a string 'django.core',",if app == 'django.core' :
app is a string 'django',app = 'django'
"if not,",else :
"call the method app.rpartition with an argument '.', substitute last element of the result for app.",app = app . rpartition ( '.' ) [ - 1 ]
append name to the value of under the app key of the commands_dict.,commands_dict [ app ] . append ( name )
"call the color_style function, substitute the result for style.",style = color_style ( )
"for every app in sorted return value of the commands_dict.keys function,",for app in sorted ( commands_dict . keys ( ) ) :
append an empty string to usage.,"usage . append ( """" )"
"call the style.NOTICE method with an argument string ""[%s]"", where '%s' is replaced with app, append the result to usage.","usage . append ( style . NOTICE ( ""[%s]"" % app ) )"
"for every name in sorted value under the app key of the commands_dict dictionary,",for name in sorted ( commands_dict [ app ] ) :
"append string "" %s"", where '%s' is replaced by name to the usage.","usage . append ( "" %s"" % name )"
"if self.settings_exception is not None,",if self . settings_exception is not None :
"call the method style.NOTICE with an argument string ""Note that only Django core commands are listed as settings are not properly configured (error: %s)."", where '%s' is replaced by self.settings_exception, append the result to usage.","usage . append ( style . NOTICE ( ""Note that only Django core commands are listed "" ""as settings are not properly configured (error: %s)."" % self . settings_exception ) )"
"join usage elements in a string separated by newline characters, return it.",return '\n' . join ( usage )
"define the method fetch_command, with arguments self and subcommand.","def fetch_command ( self , subcommand ) :"
"call the function get_commands, substitute it for commands.",commands = get_commands ( )
"try,",try :
substitute value under the subcommand key of the commands dictionary for app_name.,app_name = commands [ subcommand ]
"if KeyError exception is caught,",except KeyError :
call settings.INSTALLED_APPS.,settings . INSTALLED_APPS
"call the method sys.stderr.write with an argument string ""Unknown command: %r\nType '%s help' for usage.\n"",","sys . stderr . write ( ""Unknown command: %r\nType '%s help' for usage.\n"" % ( subcommand , self . prog_name ) )"
where '%r' is replaced with subcommand and '%s' is replaced with self.prog_name. call the function sys.exit with an argument integer 1.,sys . exit ( 1 )
if app_name is an instance of BaseCommands.,"if isinstance ( app_name , BaseCommand ) :"
substitute app_name for klass.,klass = app_name
"if not,",else :
"call the function load_command_class with arguments app_name and subcommand, substitute the result for klass.","klass = load_command_class ( app_name , subcommand )"
return klass.,return klass
define the method autocomplete with an argument self.,def autocomplete ( self ) :
"if string 'DJANGO_AUTO_COMPLETE' is not contained in os.environ,",if 'DJANGO_AUTO_COMPLETE' not in os . environ :
return nothing.,return
"slit by whitespace the value under the 'COMP_WORDS' key of the os.environ dictionary, substitute the result without the first element for cwords.",cwords = os . environ [ 'COMP_WORDS' ] . split ( ) [ 1 : ]
"convert to an integer value under the 'COMP_CWORD' key of the os.environ dictionary, substitute it for cword.",cword = int ( os . environ [ 'COMP_CWORD' ] )
"try,",try :
substitute cwords element at the cword decremented by 1 index for curr.,curr = cwords [ cword - 1 ]
"if IndexError exception is caugh,",except IndexError :
curr is an empty string.,curr = ''
"call the function get_commands, convert the result to a list, append string 'help' to it, substitute it for subcommands.",subcommands = list ( get_commands ( ) ) + [ 'help' ]
options is a list containing a tuple with 2 entries: string '--help' and None.,"options = [ ( '--help' , None ) ]"
"if cword equlals a integer 1,",if cword == 1 :
"filter all the subcommands element through the lambda function with an argument x, that evaluates the method x.startswith,","print ( ' ' . join ( sorted ( filter ( lambda x : x . startswith ( curr ) , subcommands ) ) ) )"
"with an argument curr, sort the result and join it in a list separated with blank spaces, print it to the standard output. otherwise if first element of cwords is contanied in subcommands and is not equal to string 'help',",elif cwords [ 0 ] in subcommands and cwords [ 0 ] != 'help' :
"call the method self.fetch_command with first element of cwords as an argument, substitute it for subcommand_cls.",subcommand_cls = self . fetch_command ( cwords [ 0 ] )
"if first element of cwords equals a string 'runfcgi',",if cwords [ 0 ] == 'runfcgi' :
"from django.core.servers.fastcgi import FASTCGI_OPTIONS into default namespace,",from django . core . servers . fastcgi import FASTCGI_OPTIONS
"append tuple containing two entries: k and integer 1 to options, for every k in FASTCGI_OPTIONS.","options += [ ( k , 1 ) for k in FASTCGI_OPTIONS ]"
"otherwise if first element of cwords is contanied in tuple with 8 entries: 'dumpdata', 'sql', 'sqlall', 'sqlclear', 'sqlcustom',","elif cwords [ 0 ] in ( 'dumpdata' , 'sql' , 'sqlall' , 'sqlclear' , 'sqlcustom' , 'sqlindexes' , 'sqlsequencereset' , 'test' ) :"
"try,",try :
"call the method apps.get_app_configs, substitute the result for app_configs.",app_configs = apps . get_app_configs ( )
"append tuple containing two entries: app_config.label and integer 0 to options, for every app_config in app_configs.","options += [ ( app_config . label , 0 ) for app_config in app_configs ]"
"if ImportError exception is caught,",except ImportError :
do nothing.,pass
"call the method subcommand_cls.create_parser with 2 argument an empty string an first element of cwords, substitute it for parser.","parser = subcommand_cls . create_parser ( '' , cwords [ 0 ] )"
"if subcommand_cls.use_argparse is true,",if subcommand_cls . use_argparse :
"append to options a tuple containing 2 entries: firs element of sorted list of the s_opt.option_strings,","options += [ ( sorted ( s_opt . option_strings ) [ 0 ] , s_opt . nargs != 0 ) for s_opt in parser . _actions if s_opt . option_strings ]"
"and evaluated boolean expression s_opt.nargs doesnt equal to integer 0, for every s_opt in parser._actions, only if s_opt.option_strings is true, if not,",else :
"append to options a tuple containing 2 entries: result of the method s_opt.get_opt_string and s_opt.nargs,","options += [ ( s_opt . get_opt_string ( ) , s_opt . nargs ) for s_opt in parser . option_list ]"
"for every s_opt in parser.option_list. for every x in slice of cwords from the second element to the element at the cword decremented by 1 index,",prev_opts = [ x . split ( '=' ) [ 0 ] for x in cwords [ 1 : cword - 1 ] ]
"split x by character '=' and append first element of the result to the prev_opts list. for every opt in options, if first element of opt is not contained in prev_opts, append opt to the list, substitute it for options.",options = [ opt for opt in options if opt [ 0 ] not in prev_opts ]
"append tuple containing 2 elements: k and v to a list, for every k and v in options, only if k starts with curr,","options = sorted ( ( k , v ) for k , v in options if k . startswith ( curr ) )"
"sort the result and substitute it for options. for every option in options,",for option in options :
substitute first element of options for opt_label.,opt_label = option [ 0 ]
"if second element of options is true,",if option [ 1 ] :
append '=' to opt_label.,opt_label += '='
print opt_label to the standard output.,print ( opt_label )
call the function sys.exit with an integer 1 as an argument.,sys . exit ( 1 )
"define the method execute with an argument self,",def execute ( self ) :
"try,",try :
substitute first element of self.argv for subcommand.,subcommand = self . argv [ 1 ]
"if IndexError exception is caught,",except IndexError :
subcommand is a string 'help'.,subcommand = 'help'
"parser is an instance of CommandParser class, created with 3 arguments, None, usage as a string ""%(prog)s subcommand [options] [args]"" and add_help set to boolean False.","parser = CommandParser ( None , usage = ""%(prog)s subcommand [options] [args]"" , add_help = False )"
call the method parser.add_argument with an argument string '--settings'.,parser . add_argument ( '--settings' )
call the method parser.add_argument with an argument string '--pythonpath'.,parser . add_argument ( '--pythonpath' )
call the method parser.add_argument with arguments: string 'args' and nargs set to '*'.,"parser . add_argument ( 'args' , nargs = '*' )"
"try,",try :
"call the method parser.parse_known_args wiht an argument self.argv, without the first two elements, assign the result for options,","options , args = parser . parse_known_args ( self . argv [ 2 : ] )"
"and args, respectively. call the method handle_default_options with an argument options.",handle_default_options ( options )
"if CommandError exception is caught,",except CommandError :
do nothing.,pass
"no_settings_commands is a list containing entries: 'help', 'version', '--help', '--version', '-h', 'compilemessages', 'makemessages',","no_settings_commands = [ 'help' , 'version' , '--help' , '--version' , '-h' , 'compilemessages' , 'makemessages' , 'startapp' , 'startproject' , ]"
"'startapp' and 'startproject'. try,",try :
call the settings.INSTALLED_APPS.,settings . INSTALLED_APPS
"if ImproperlyConfigured renamed to exc, exception is caught,",except ImproperlyConfigured as exc :
"substitute exc for self.settings_exception,",self . settings_exception = exc
"if subcommand is contained in no_settings_commands,",if subcommand in no_settings_commands :
call the method settings.configure.,settings . configure ( )
"if settings.configured is true,",if settings . configured :
call the method django.setup.,django . setup ( )
call the method self.autocomplete.,self . autocomplete ( )
if subcommand equals to a string 'help'.,if subcommand == 'help' :
"if string '--commands' is contained in args,",if '--commands' in args :
"call the method self.main_help_text with an argument commands_only set to boolean True, append new line to it, write it to sys.stdout.",sys . stdout . write ( self . main_help_text ( commands_only = True ) + '\n' )
"otherwise, length of options.args is lesser than integer 1,",elif len ( options . args ) < 1 :
"call the method self.main_help_text append new line to it, write it to sys.stdout.",sys . stdout . write ( self . main_help_text ( ) + '\n' )
"if not,",else :
"call the method self.fetch_command with first element of options.args as argument, on the result call the method print_help,","self . fetch_command ( options . args [ 0 ] ) . print_help ( self . prog_name , options . args [ 0 ] )"
"with 2 arguments: self.prog_name and first element of options.args. otherwise if subcommand equals a string 'version' or self.argv, without the first element equals a list containing a string '--version'",elif subcommand == 'version' or self . argv [ 1 : ] == [ '--version' ] :
"call the method django.get_version append new line to it, write it to sys.stdout.",sys . stdout . write ( django . get_version ( ) + '\n' )
"if self.argv, without the first element is contained in a tuple with 2 entries: a list containing a string '--help',","elif self . argv [ 1 : ] in ( [ '--help' ] , [ '-h' ] ) :"
"and a list containing a string '-h', call the method self.main_help_text, append new line to it, write it to sys.stdout.",sys . stdout . write ( self . main_help_text ( ) + '\n' )
"if not,",else :
"call the method self.fetch_command with an argument command, call the method run_from_argv on the result with an argument self.argv.",self . fetch_command ( subcommand ) . run_from_argv ( self . argv )
define the function execute_from_command_line with an argument argv set to None.,def execute_from_command_line ( argv = None ) :
"utility is a instance of ManagementUtility class, created with an argument argv.",utility = ManagementUtility ( argv )
call the method utility.execute.,utility . execute ( )
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
import module os.,import os
import module sys.,import sys
import module warnings.,import warnings
from argparse import ArgumentParser into default name space.,from argparse import ArgumentParser
from optparse import OptionParser into default name space.,from optparse import OptionParser
import module django.,import django
from django.core import checks into default name space.,from django . core import checks
from django.core.exceptions import ImproperlyConfigured into default name space.,from django . core . exceptions import ImproperlyConfigured
from django.core.management.color import color_style and no_style into default name space.,"from django . core . management . color import color_style , no_style"
from django.utils.deprecation import RemovedInDjango19Warning and RemovedInDjango20Warning into default name space.,"from django . utils . deprecation import RemovedInDjango19Warning , RemovedInDjango20Warning"
from django.utils.encoding import force_st into default name space.,from django . utils . encoding import force_str
derive the class CommandError from the base class Exception.,class CommandError ( Exception ) :
do nothing.,pass
derive the CommandParser class from the ArgumentParser base class.,class CommandParser ( ArgumentParser ) :
"define the method __init__ with arguments: self, cmd and unpacked dictionary kwargs.","def __init__ ( self , cmd , ** kwargs ) :"
substitute cmd for self.cmd.,self . cmd = cmd
"call the method __init__ from the base class of the CommandParser class, with unpacked dictionary kwargs as argument.","super ( CommandParser , self ) . __init__ ( ** kwargs )"
"define the method parse_args with 3 arguments: self, args set to None and namespace set to None.","def parse_args ( self , args = None , namespace = None ) :"
"if self.cmd has an attribute 'missing_args_message' and next statement is not true: args is true or any arg doesnt start with '-' for arg in args,","if ( hasattr ( self . cmd , 'missing_args_message' ) and not ( args or any ( [ not arg . startswith ( '-' ) for arg in args ] ) ) ) :"
call the method self.error with an argument self.cmd.missing_args_message.,self . error ( self . cmd . missing_args_message )
"call the parse_args method with arguments args and namespace, from the base class of the CommandParser class.","return super ( CommandParser , self ) . parse_args ( args , namespace )"
define the method error with arguments self and message.,"def error ( self , message ) :"
"if self.cmd._called_from_command_line is true,",if self . cmd . _called_from_command_line :
"call the method error with an argument message, from the base class of the class CommandParser.","super ( CommandParser , self ) . error ( message )"
"if not,",else :
"raise an CommandError exception with an argument string ""Error: %s"", with '%s' replaced by message.","raise CommandError ( ""Error: %s"" % message )"
define the function handle_default_options with an argument options.,def handle_default_options ( options ) :
"if options.settings is true,",if options . settings :
substitute options.settings for value under the 'DJANGO_SETTINGS_MODULE' key of the os.environ dictionary.,os . environ [ 'DJANGO_SETTINGS_MODULE' ] = options . settings
"if options.pythonpath is true,",if options . pythonpath :
insert options.pythonpath at the beginning of sys.path.,"sys . path . insert ( 0 , options . pythonpath )"
derive the OutputWrapper class from the object base class.,class OutputWrapper ( object ) :
"define the method __init__ with 4 arguments: self, out, style, func set to None and endings set to newline character.","def __init__ ( self , out , style_func = None , ending = '\n' ) :"
substitute out for self._out.,self . _out = out
substitute None for self.style_func.,self . style_func = None
"if out has an 'isatty' argument and return value of the function out.isatty is true,","if hasattr ( out , 'isatty' ) and out . isatty ( ) :"
substitute style_func for self.style_func.,self . style_func = style_func
substitute ending for self.ending.,self . ending = ending
define the method __getattr__ with arguments self and name.,"def __getattr__ ( self , name ) :"
"get name attribute of the self._out object, return it.","return getattr ( self . _out , name )"
"define the method write with 4 arguments: self, msg, style_func with None and ending set None.","def write ( self , msg , style_func = None , ending = None ) :"
if ending is None substitute self.ending for ending.,ending = self . ending if ending is None else ending
"if ending is true and msg doesnt end with ending,",if ending and not msg . endswith ( ending ) :
append ending to msg.,msg += ending
"if f is not None append it to a list for every f in tuple containing 3 elements: style_func, self.style_func,","style_func = [ f for f in ( style_func , self . style_func , lambda x : x ) if f is not None ] [ 0 ]"
"and lambda function returning x for x, substitute the firs element of resulting list for style_func. call the function style_func with an argument msg, use the result as an argument for the call to the function force_str,",self . _out . write ( force_str ( style_func ( msg ) ) )
use the result as an argument for the call to the function self._out.write. derive the BaseCommand class from the object base class.,class BaseCommand ( object ) :
options_list is an empty tuple.,option_list = ( )
help is an empty string.,help = ''
args is an empty string.,args = ''
_called_from_command_line is boolean False.,_called_from_command_line = False
can_import_settings is boolean True.,can_import_settings = True
output_transaction is boolean False.,output_transaction = False
leave_locale_alone is boolean False.,leave_locale_alone = False
define the method __init__ with an argument self.,def __init__ ( self ) :
"call the function color_style, substitute the result for self.style.",self . style = color_style ( )
"if self has an 'requires_model_validation' attribute, has_old_option is boolean True, otherwise it is boolean False.","has_old_option = hasattr ( self , 'requires_model_validation' )"
"if self has an 'requires_system_checks' attribute, has_new_option is boolean True, otherwise it is boolean False.","has_new_option = hasattr ( self , 'requires_system_checks' )"
"if has_old_option is true,",if has_old_option :
"call the function warnings.warn with 2 arguments: string '""requires_model_validation"" is deprecated '","warnings . warn ( '""requires_model_validation"" is deprecated ' 'in favor of ""requires_system_checks"".' , RemovedInDjango19Warning )"
"'in favor of ""requires_system_checks"".' and RemovedInDjango19Warning. if has_old_option and has_new_option are both true,",if has_old_option and has_new_option :
"raise an ImproperlyConfigured exception wiht an argument string 'Command %s defines both ""requires_model_validation"" '","raise ImproperlyConfigured ( 'Command %s defines both ""requires_model_validation"" ' 'and ""requires_system_checks"", which is illegal. Use only ' '""requires_system_checks"".' % self . __class__ . __name__ )"
"'and ""requires_system_checks"", which is illegal. Use only ""requires_system_checks"".', replace '%s' for self.__class__.__name__. call the method self.requires_system_checks with an argument: self.requires_system_checks if has_new_option is true,",self . requires_system_checks = ( self . requires_system_checks if has_new_option else self . requires_model_validation if has_old_option else True )
"or if it is false, but has_old_option is true use self.requires_model_validation, if they are both false use boolean True as an argument. property decorator,",@ property
"define the method use_argparse with an argument self,",def use_argparse ( self ) :
"convert self.option_list into a boolean, return the inverted value.",return not bool ( self . option_list )
define the method get_version with an arguments self.,def get_version ( self ) :
"call the function django.get_version, return the result.",return django . get_version ( )
define the method usage with arguments self and subcommand.,"def usage ( self , subcommand ) :"
"substitute '%s' in the string '%%prog %s [options] %s' with subcommand and self.args, respectively, substitute it for usage.","usage = '%%prog %s [options] %s' % ( subcommand , self . args )"
"if self.help is true,",if self . help :
"join usage and self.help into a string, separated by 2 new line characters, return it.","return '%s\n\n%s' % ( usage , self . help )"
"if not,",else :
return usage.,return usage
"define the method create_parser with 3 arguments: self, prog_name and subcommand.","def create_parser ( self , prog_name , subcommand ) :"
"if self.use_argparse is false,",if not self . use_argparse :
"call the function warnings.warn with 2 arguments: string ""OptionParser usage for Django management commands ""","warnings . warn ( ""OptionParser usage for Django management commands "" ""is deprecated, use ArgumentParser instead"" , RemovedInDjango20Warning )"
"""is deprecated, use ArgumentParser instead"" and RemovedInDjango20Warning. parser is an instance of the object OptionParser, created with arguments: prog set to prog_name,","parser = OptionParser ( prog = prog_name , usage = self . usage ( subcommand ) , version = self . get_version ( ) )"
"usage set to return value of the method self.usage called with an argument subcommand, version set to return value of the method self.get_version. call the method parser.add_option with 8 arguments: string '-v', string '--verbosity', action set to string 'store',","parser . add_option ( '-v' , '--verbosity' , action = 'store' , dest = 'verbosity' , default = '1' , type = 'choice' , choices = [ '0' , '1' , '2' , '3' ] , help = 'Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output' )"
"dest set to string 'verbosity', default set to string '1', type set to string 'choice', choices is a list containing elements: '0', '1', '2', '3', and help as a string 'Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output'. call the method parser.add_option with 2 arguments: string '--settings' and help as a string 'The Python path to a settings module, e.g. ""myproject.settings.main"". If this isn\'t provided, the DJANGO_SETTINGS_MODULE environment variable will be used.'.","parser . add_option ( '--settings' , help = 'The Python path to a settings module, e.g. ""myproject.settings.main"". If this isn\'t provided, the DJANGO_SETTINGS_MODULE environment variable will be used.' )"
"call the method parser.add_option with 2 arguments: string '--pythonpath' and help set to string 'A directory to add to the Python path, e.g. ""/home/djangoprojects/myproject"".'.","parser . add_option ( '--pythonpath' , help = 'A directory to add to the Python path, e.g. ""/home/djangoprojects/myproject"".' ) ,"
"call the method parser.add_option with 3 arguments: string '--traceback', action set to a string 'store_true',","parser . add_option ( '--traceback' , action = 'store_true' , help = 'Raise on exception' )"
"and help='Raise on exception'. call the method parser.add_option with 5 arguments: string '--no-color', action set to a string 'store_true',","parser . add_option ( '--no-color' , action = 'store_true' , dest = 'no_color' , default = False , help = ""Don't colorize the command output."" )"
"dest set to string 'no_color' default set to boolean False and help set to a string ""Don't colorize the command output."". for every opt in self.option_list,",for opt in self . option_list :
call the method parser.add_option with an argument opt.,parser . add_option ( opt )
"if not,",else :
"parser is an instance of CommandParser class, created with 3 arguments: self, prog as a string created by joining:","parser = CommandParser ( self , prog = ""%s %s"" % ( os . path . basename ( prog_name ) , subcommand ) , description = self . help or None )"
"os.path.basename(prog_name) and subcommand, separated by whitespace and description set to self.help, if exists, or None, otherwise. call the method parser.add_option with 3 arguments: string '--version', action set to string 'version',","parser . add_argument ( '--version' , action = 'version' , version = self . get_version ( ) )"
"and version set to result of the method self.get_version. call the method parser.add_option with 8 arguments: string '-v', string '--verbosity', action set to string 'store',","parser . add_argument ( '-v' , '--verbosity' , action = 'store' , dest = 'verbosity' , default = '1' , type = int , choices = [ 0 , 1 , 2 , 3 ] , help = 'Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output' )"
"dest set to string 'verbosity', default set to string '1', type set to int, choices is a list, containing integers: 0, 1, 2 and 3, call the method parser.add_option with 2 arguments: string '--settings' and help as a string 'The Python path to a settings module, e.g. ""myproject.settings.main"". If this isn\'t provided, the DJANGO_SETTINGS_MODULE environment variable will be used.'","parser . add_argument ( '--settings' , help = 'The Python path to a settings module, e.g. ""myproject.settings.main"". If this isn\'t provided, the DJANGO_SETTINGS_MODULE environment variable will be used.' )"
"call the method parser.add_option with 2 arguments: string '--pythonpath' and help set to a string 'A directory to add to the Python path, e.g. ""/home/djangoprojects/myproject"".'","parser . add_argument ( '--pythonpath' , help = 'A directory to add to the Python path, e.g. ""/home/djangoprojects/myproject"".' )"
"call the method parser.add_option with 3 arguments: string '--traceback', action set to a string 'store_true',","parser . add_argument ( '--traceback' , action = 'store_true' , help = 'Raise on exception' )"
"and help set to string 'Raise on exception'. call the method parser.add_option with 5 arguments: string '--no-color', action is string 'store_true', dest is string 'no_color',","parser . add_argument ( '--no-color' , action = 'store_true' , dest = 'no_color' , default = False , help = ""Don't colorize the command output."" )"
"default is boolean False, and help is a string ""Don't colorize the command output."". if self.args is true,",if self . args :
call the method parser.add_argument with 2 arguments: string 'args' and nargs set to '*'.,"parser . add_argument ( 'args' , nargs = '*' )"
call the method self.add_arguments with an argument parser.,self . add_arguments ( parser )
return parser,return parser
define the method add_arguments with an argument self and parser.,"def add_arguments ( self , parser ) :"
do nothing,pass
"define the method print_help with 3 arguments: self, prog_name and subcommand.","def print_help ( self , prog_name , subcommand ) :"
call the method self.create_parser with arguments prog_name and subcommand.,"parser = self . create_parser ( prog_name , subcommand )"
call the method parser.print_help.,parser . print_help ( )
define the method run_from_argv with arguments self and argv.,"def run_from_argv ( self , argv ) :"
self._called_from_command_line is boolean True.,self . _called_from_command_line = True
"call the method self.create_parser with first and second element of argv, substitute the result for parser.","parser = self . create_parser ( argv [ 0 ] , argv [ 1 ] )"
"if self.use_argparse is true,",if self . use_argparse :
"call the method parser.parse_args with argv, without the first 2 elements, substitute the result for options.",options = parser . parse_args ( argv [ 2 : ] )
"call the function vars with an argument options, substitute the result for cmd_options.",cmd_options = vars ( options )
"if 'args' is contained in options,",if 'args' in options :
substitute options.args for args.,args = options . args
delete value under the 'args' key of the cmd_options dictionary.,del cmd_options [ 'args' ]
"if not,",else :
args is an empty tuple.,args = ( )
"if not,",else :
"call the method parser.parse_args with argv, without the first 2 elements, substitute the result for options and args.","options , args = parser . parse_args ( argv [ 2 : ] )"
"call the function vars with an argument options, substitute the result for cmd_options.",cmd_options = vars ( options )
call the function handle_default_options with an argument options.,handle_default_options ( options )
"try,",try :
"call the method self.execute, with 2 arguments: unpacked list args and unpacked dictionary cmd_options.","self . execute ( * args , ** cmd_options )"
"if Exception, renamed to e, exception is caught,",except Exception as e :
"if options.traceback is true or e is not CommandError instance,","if options . traceback or not isinstance ( e , CommandError ) :"
raise an exception.,raise
"if it exists, get 'stderr' attribute of self, substitute it for stderr, if not, stderr is an instance of OutputWrapper class,","stderr = getattr ( self , 'stderr' , OutputWrapper ( sys . stderr , self . style . ERROR ) )"
"created with arguments sys.stderr and self.style.ERROR. replace '%s' in string '%s: %s' with e.__class__.__name__ and e, respectively, write it to the stderr stream.","stderr . write ( '%s: %s' % ( e . __class__ . __name__ , e ) )"
call the function sys.exit with an argument integer 1.,sys . exit ( 1 )
"define the method execute with 3 arguments: self, unpacked list args and unpacked dictionary options.","def execute ( self , * args , ** options ) :"
"self.stdout is an instance of OutputWrapper class created with an argument: value under the 'stdout' key of the options dictionary,","self . stdout = OutputWrapper ( options . get ( 'stdout' , sys . stdout ) )"
if the key doesnt exists use sys.stdout as an argument. if value under the 'no_color' key of the options dictionary.,if options . get ( 'no_color' ) :
"call the function no_style, substitute the result for self.style.",self . style = no_style ( )
"self.stderr is an OutputWrapper object instance, created with value under the 'stderr' key of the options dictionary as an argument,","self . stderr = OutputWrapper ( options . get ( 'stderr' , sys . stderr ) )"
"if the key doesnt exists use sys.stderr as an argument. if not,",else :
"self.stderr is an instance of an OutputWrapper object, created with 2 arguments: value under the 'stderr' key of the options dictionary, if it doesnt exists use the sys.stderr instead, and self.style.ERROR.","self . stderr = OutputWrapper ( options . get ( 'stderr' , sys . stderr ) , self . style . ERROR )"
"if self.can_import_settings is true,",if self . can_import_settings :
"from django.conf import settings into default namespace,",from django . conf import settings
saved_locale is None.,saved_locale = None
"if self.leave_locale_alone is false,",if not self . leave_locale_alone :
"if self.can_import_settings is false,",if not self . can_import_settings :
"raise an CommandError exception with an argument string, ""Incompatible values of 'leave_locale_alone' ""","raise CommandError ( ""Incompatible values of 'leave_locale_alone' "" ""(%s) and 'can_import_settings' (%s) command "" ""options."" % ( self . leave_locale_alone , self . can_import_settings ) )"
"""(%s) and 'can_import_settings' (%s) command options."", replace '%s' with self.leave_locale_alone and self.can_import_settings. from django.utils import translation into default namespace.",from django . utils import translation
"call the method translation.get_language, substitute th result for saved_locale.",saved_locale = translation . get_language ( )
call the method translation.activate with an argument string 'en-us'.,translation . activate ( 'en-us' )
"try,",try :
"if self.requires_system_checks is true and values under the 'skip_validation' and 'skip_checks' keys of the options dictionary are false,",if ( self . requires_system_checks and not options . get ( 'skip_validation' ) and not options . get ( 'skip_checks' ) ) :
"call the method self.check,",self . check ( )
"call the method self.handle with 2 arguments unpacked list args and unpacked dictionary options, substitute the result for output.","output = self . handle ( * args , ** options )"
"if output is true,",if output :
"if self.output_transaction is true,",if self . output_transaction :
from django.db import connections and DEFAULT_DB_ALIAS into default namespace.,"from django . db import connections , DEFAULT_DB_ALIAS"
"get the value under the 'database' key of the options dictionary, if it doesnt exists use the DEFAULT_DB_ALIAS to address an element","connection = connections [ options . get ( 'database' , DEFAULT_DB_ALIAS ) ]"
"from the connections list, substitute it for connection. call the method connection.ops.start_transaction_sql, if it evaluates to true,",if connection . ops . start_transaction_sql ( ) :
"call the method connection.ops.start_transaction_sql, use the result as an argument for the call to the method self.style.SQL_KEYWORD,",self . stdout . write ( self . style . SQL_KEYWORD ( connection . ops . start_transaction_sql ( ) ) )
write the result to the self.stdout stream. write output to self.stdout stream.,self . stdout . write ( output )
"if self.output_transaction is true,",if self . output_transaction :
"call the method connection.ops.end_transaction_sql, use the result as the argument for the call to the method self.style.SQL_KEYWORD,",self . stdout . write ( '\n' + self . style . SQL_KEYWORD ( connection . ops . end_transaction_sql ( ) ) )
"append the result to the '\n' string, write it to self.stdout. finally perform,",finally :
"if saved_locale is not None,",if saved_locale is not None :
call the method translation.activate with an argument saved_locale.,translation . activate ( saved_locale )
"define the method with 3 arguments: self, app_config set to None and display_num_errors set to boolean False.","def validate ( self , app_config = None , display_num_errors = False ) :"
"if app_config is None,",if app_config is None :
app_configs is not None.,app_configs = None
"if not,",else :
app_configs is a list containing app_config.,app_configs = [ app_config ]
"call the method self.check with 2 arguments app_configs set to app_configs, display_num_errors set to display_num_errors, return the result.","return self . check ( app_configs = app_configs , display_num_errors = display_num_errors )"
"define the method check with 4 arguments: self, app_configs set to None, tags set to None, display_num_errors set to boolean False.","def check ( self , app_configs = None , tags = None , display_num_errors = False ) :"
"call the method checks.run_checks with 2 arguments: app_configs set to app_configs, tags set t tags, substitute the result for all_issues.","all_issues = checks . run_checks ( app_configs = app_configs , tags = tags )"
msg is an empty string.,"msg = """""
visible_issue_count is an integer 0.,visible_issue_count = 0
"if all_issues is true,",if all_issues :
"append e to debugs list for every e in all_issues, if e.level is lesser than checks.INFO and result of the method e.is_silenced in false.",debugs = [ e for e in all_issues if e . level < checks . INFO and not e . is_silenced ( ) ]
"append e to infos list for every e in all_issues, if checks.INFO is lesser or equal to e.level,",infos = [ e for e in all_issues if checks . INFO <= e . level < checks . WARNING and not e . is_silenced ( ) ]
"and e.level is lesser than checks.WARNING and result of the method e.is_silenced in false. append e to warnings list for every e in all_issues, if checks.WARNING is lesser than or equal to e.level,",warnings = [ e for e in all_issues if checks . WARNING <= e . level < checks . ERROR and not e . is_silenced ( ) ]
"and e.level is lesser than checks.WARNING and result of the method e.is_silenced in false. append e to errors list for every e in all_issues, if checks.ERROR is lesser than or equal to e.level,",errors = [ e for e in all_issues if checks . ERROR <= e . level < checks . CRITICAL ]
"and e.level is lesser than checks.CRITICAL. append e to criticals list for every e in all_issues, if checks.CRITICAL is lesser than or equal to e.level.",criticals = [ e for e in all_issues if checks . CRITICAL <= e . level ]
"sorted_issues is a list of tuples with 5 entries: criticals and 'CRITICALS', errors and 'ERRORS', warnings and 'WARNINGS',","sorted_issues = [ ( criticals , 'CRITICALS' ) , ( errors , 'ERRORS' ) , ( warnings , 'WARNINGS' ) , ( infos , 'INFOS' ) , ( debugs , 'DEBUGS' ) , ]"
"infos, 'INFOS' for every issues and group_name in sorted_issues,","for issues , group_name in sorted_issues :"
"if issues is true,",if issues :
increment visible_issue_count for length of issues.,visible_issue_count += len ( issues )
"if e.is_serious method evaluates to true, call the function color_style, on the result call the method ERROR with result of the force_str called with an argument e, if not call the function color_style on the result call the method ERROR with result of the force_str called with an argument e, for every e in issues, formatted is a tuple containing the previous result.",formatted = ( color_style ( ) . ERROR ( force_str ( e ) ) if e . is_serious ( ) else color_style ( ) . WARNING ( force_str ( e ) ) for e in issues )
"sort elements formatted, join them in the list separated with newline character, substitute the result for formatted.","formatted = ""\n"" . join ( sorted ( formatted ) )"
"substitute '%s' in the string '\n%s:\n%s\n', with group_name and formatted, substitute the result for msg.","msg += '\n%s:\n%s\n' % ( group_name , formatted )"
"if msg is true,",if msg :
"replace '%s' in string ""System check identified some issues:\n%s"" with msg, substitute it for msg.","msg = ""System check identified some issues:\n%s"" % msg"
"if display_num_errors is true,",if display_num_errors :
"if msg is true,",if msg :
append newline character to msg.,msg += '\n'
"append string ""System check identified %s (%s silenced)."" to msg, replace first '%s' for: string ""no issues"",","msg += ""System check identified %s (%s silenced)."" % ( ""no issues"" if visible_issue_count == 0 else ""1 issue"" if visible_issue_count == 1 else ""%s issues"" % visible_issue_count , len ( all_issues ) - visible_issue_count , )"
"if visible_issue_count equals to integer 0, or for string ""1 issue"" if visible_issue_count equals integer 1, or for string ""%s issues"", with '%s' replaced by visible_issue_count, subtract visible_issue_count from length of all_issues, and substitute it for second '%s' in the stirting string. if any element in the return value of the e.is_serious method is true, and if return value of the method e.is_silenced is false,",if any ( e . is_serious ( ) and not e . is_silenced ( ) for e in all_issues ) :
"for every e in all_issues, raise an CommandError with argument msg,",raise CommandError ( msg )
"otherwise if msg and visible_issue_count are true,",elif msg and visible_issue_count :
write msg to self.stderr stream.,self . stderr . write ( msg )
"otherwise if msg is true,",elif msg :
write msg to self.stderr stream.,self . stdout . write ( msg )
"define the method handle with 3 arguments: self, unpacked args and unpacked dictionary options.","def handle ( self , * args , ** options ) :"
raise an NotImplementedError exception with an argument string 'subclasses of BaseCommand must provide a handle() method'.,raise NotImplementedError ( 'subclasses of BaseCommand must provide a handle() method' )
derive the AppCommand class from the BaseCommand base class.,class AppCommand ( BaseCommand ) :
"missing_args_message is an string ""Enter at least one application label."".","missing_args_message = ""Enter at least one application label."""
define the method add_arguments with self and parser as arguments.,"def add_arguments ( self , parser ) :"
"call the method parser.add_argument with 4 arguments: string 'args', metavar set to 'app_label', nargs set to '+',","parser . add_argument ( 'args' , metavar = 'app_label' , nargs = '+' , help = 'One or more application label.' )"
"and help set to string 'One or more application label.'. define the method handle with 3 arguments: self, unpacked list app_labels and unpacked dictionary options.","def handle ( self , * app_labels , ** options ) :"
from django.apps import apps into default name space.,from django . apps import apps
"try,",try :
"call the method apps.get_app_config with an argument app_lable, for every app_label in app_labels, append the results to app_configs list.",app_configs = [ apps . get_app_config ( app_label ) for app_label in app_labels ]
"if LookupError or ImportError, renamed to e, exceptions are caught,","except ( LookupError , ImportError ) as e :"
"raise an CommandError with an argument string ""%s. Are you sure your INSTALLED_APPS setting is correct?"", with '%s' replaced by e.","raise CommandError ( ""%s. Are you sure your INSTALLED_APPS setting is correct?"" % e )"
output is an empty list.,output = [ ]
"for eery app_config in app_configs,",for app_config in app_configs :
"call the self.handle_app_config method with app_config and options as arguments, substitute the result for app_output.","app_output = self . handle_app_config ( app_config , ** options )"
"if app_output is true,",if app_output :
append app_output to output.,output . append ( app_output )
"join elements of output into a string, separated by newline characters, return it.",return '\n' . join ( output )
"define the method handle_app_config with 3 arguments: self, app_config and unpacked dictionary options.","def handle_app_config ( self , app_config , ** options ) :"
"try,",try :
substitute self.handle_app for handle_app.,handle_app = self . handle_app
"if AttributeError exception is caught,",except AttributeError :
"raise an NotImplementedError with an argument string ""Subclasses of AppCommand must provide a handle_app_config() method."".","raise NotImplementedError ( ""Subclasses of AppCommand must provide"" ""a handle_app_config() method."" )"
"if not,",else :
"call the function warnings.warn with 3 argument: string ""AppCommand.handle_app() is superseded by AppCommand.handle_app_config()."",","warnings . warn ( ""AppCommand.handle_app() is superseded by "" ""AppCommand.handle_app_config()."" , RemovedInDjango19Warning , stacklevel = 2 )"
"RemovedInDjango19Warning and stacklevel set to integer 2. if app_config.models_module is None,",if app_config . models_module is None :
"raise an CommandError with an argument string ""AppCommand cannot handle app '%s' in legacy mode because it doesn't have a models module."", where '%s' is replaced by app_config.label.","raise CommandError ( ""AppCommand cannot handle app '%s' in legacy mode "" ""because it doesn't have a models module."" % app_config . label )"
call the function handle_app with 2 arguments: app_config.models_module and unpacked dictionary options.,"return handle_app ( app_config . models_module , ** options )"
derive the LabelCommand class from the BaseCommand base class.,class LabelCommand ( BaseCommand ) :
label is a string 'label',label = 'label'
"substitute string ""Enter at least one %s."", with '%s' replaced by label, for missing_args_message.","missing_args_message = ""Enter at least one %s."" % label"
define the method add_arguments with arguments self and parser.,"def add_arguments ( self , parser ) :"
"call the method parser.add_argument with 3 arguments: string 'args', metavar set to self.label and nargs set to '+'.","parser . add_argument ( 'args' , metavar = self . label , nargs = '+' )"
"define the method handle with 3 arguments: self, unpacked list labels and unpacked dictionary options.","def handle ( self , * labels , ** options ) :"
output is an empty list.,output = [ ]
"for every label in labels,",for label in labels :
"call the method self.handle_label with 2 arguments: label and unpacked dictionary options, substitute the result for label_output.","label_output = self . handle_label ( label , ** options )"
"if label_output is true,",if label_output :
append label_output to output.,output . append ( label_output )
"join output into a string, separated by newline characters, return it.",return '\n' . join ( output )
"define the method handle_label with 3 arguments: self, label and unpacked dictionary options.","def handle_label ( self , label , ** options ) :"
raise an NotImplementedError exception with an argument string 'subclasses of LabelCommand must provide a handle_label() method'.,raise NotImplementedError ( 'subclasses of LabelCommand must provide a handle_label() method' )
derive the NoArgsCommand class from the BaseCommand base class.,class NoArgsCommand ( BaseCommand ) :
args is an empty string.,args = ''
define the method __init__ with an argument self.,def __init__ ( self ) :
"call the function warnings.warn with 2 arguments: string ""NoArgsCommand class is deprecated and will be removed in Django 2.0. ""","warnings . warn ( ""NoArgsCommand class is deprecated and will be removed in Django 2.0. "" ""Use BaseCommand instead, which takes no arguments by default."" , RemovedInDjango20Warning )"
"""Use BaseCommand instead, which takes no arguments by default."" and RemovedInDjango20Warning. call the __init__ method from the base class of the NoArgsCommand class.","super ( NoArgsCommand , self ) . __init__ ( )"
"define the method handle with 3 arguments: self, unpacked list args and unpacked dictionary options.","def handle ( self , * args , ** options ) :"
"if args is true,",if args :
"raise an CommandError exception with an argument string ""Command doesn't accept any arguments"".","raise CommandError ( ""Command doesn't accept any arguments"" )"
"call the self.handle_noargs method with with unpacked dictionary options as argument, return the result.",return self . handle_noargs ( ** options )
define the method handle_noargs with 2 arguments: self and unpacked dictionary options.,"def handle_noargs ( self , ** options ) :"
raise an NotImplementedError with an argument string 'subclasses of NoArgsCommand must provide a handle_noargs() method'.,raise NotImplementedError ( 'subclasses of NoArgsCommand must provide a handle_noargs() method' )
import module os.,import os
import module sys.,import sys
from django.utils import termcolors into default name space.,from django . utils import termcolors
"define the function supports_color, without arguments.",def supports_color ( ) :
substitute sys.platform for plat.,plat = sys . platform
"evaluate the logic expression, plat does not equals to string 'Pocket PC', and plat does not equals to string 'win32'",supported_platform = plat != 'Pocket PC' and ( plat != 'win32' or 'ANSICON' in os . environ )
"or string 'ANICON' is in os.environ, substitute the evaluated boolean for supported_platform. if sys.stdout has an attribute named 'isatty' and call to the sys.stdout.isatty returns boolean True, substitute True for is_a_tty.","is_a_tty = hasattr ( sys . stdout , 'isatty' ) and sys . stdout . isatty ( )"
"if supported_platform is False or is_a_tty is False,",if not supported_platform or not is_a_tty :
return boolean False.,return False
return boolean True.,return True
"define function color_style, without input arguments.",def color_style ( ) :
"call the function supports_color, if evaluates to False,",if not supports_color ( ) :
substitute return value of function no_style for style.,style = no_style ( )
"if not,",else :
"get the value under the key 'DJANGO_COLORS' of os.environ dictionary, if key doesnt exists return empty string, assign the result to DJANGO_COLORS.","DJANGO_COLORS = os . environ . get ( 'DJANGO_COLORS' , '' )"
"call the function termcolors.parse_color_setting with DJANGO_COLORS as an argument, assign the result to color_settings.",color_settings = termcolors . parse_color_setting ( DJANGO_COLORS )
"if color_setting is True,",if color_settings :
define class dummy.,class dummy :
do nothing.,pass
style is an instance of the dummy class.,style = dummy ( )
"for every role in termcolors.PALETTES list at the index termcolors.NOCOLOR_PALETTE,",for role in termcolors . PALETTES [ termcolors . NOCOLOR_PALETTE ] :
"assign the value of the dictionary color_settings under the key role to format, if key doesnt exist assign the empty dictionary.","format = color_settings . get ( role , { } )"
sets the role attribute of the style object to the value of the call to the termcolors.make_style function with dictionary format as an argument.,"setattr ( style , role , termcolors . make_style ( ** format ) )"
substitute style.ERROR for style.ERROR_OUTPUT.,style . ERROR_OUTPUT = style . ERROR
"if not,",else :
substitute return value of function no_style for style.,style = no_style ( )
return style.,return style
"define function no_style, without input arguments.",def no_style ( ) :
define class dummy.,class dummy :
define private method __getattr__ with self class instance and attr as the arguments.,"def __getattr__ ( self , attr ) :"
"create lambda identity function which returns x for input parameter x, return the function.",return lambda x : x
return an instance of a dummy class.,return dummy ( )
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
from django.apps import apps into default name space.,from django . apps import apps
from django.core import checks into default name space.,from django . core import checks
from django.core.checks.registry import registry into default name space.,from django . core . checks . registry import registry
from django.core.management.base import BaseCommand and CommandError into default name space.,"from django . core . management . base import BaseCommand , CommandError"
derive the class Command from the BaseCommand base class.,class Command ( BaseCommand ) :
"help is a string ""Checks the entire Django project for potential problems."".","help = ""Checks the entire Django project for potential problems."""
requires_system_checks is boolean False.,requires_system_checks = False
define the method add_arguments with arguments self and parser.,"def add_arguments ( self , parser ) :"
"call the method parser.add_argument with 3 arguments: string 'args', metavar set to string 'app_label' and nargs set to '*'.","parser . add_argument ( 'args' , metavar = 'app_label' , nargs = '*' )"
"call the method parser.add_argument with 5 arguments: string '--tag', string '-t', action set to string 'append',","parser . add_argument ( '--tag' , '-t' , action = 'append' , dest = 'tags' , help = 'Run only checks labeled with given tag.' )"
"dest set to string 'tags' and help set to string 'Run only checks labeled with given tag.'. call the method parser.add_argument with 4 arguments: string '--list-tags', action set to string 'store_true',","parser . add_argument ( '--list-tags' , action = 'store_true' , dest = 'list_tags' , help = 'List available tags.' )"
"dest set to string 'list_tags' and help set to string 'List available tags.'. define method handle with arguments self, unapcked list app_labels and unpacked dictionary options.","def handle ( self , * app_labels , ** options ) :"
"if value under the 'list_tags' key of options dictionay is true,",if options . get ( 'list_tags' ) :
"call the method registry.tags_available, sort the result and join it into a string, separate by newlines, write it to self.stdout.",self . stdout . write ( '\n' . join ( sorted ( registry . tags_available ( ) ) ) )
return nothing.,return
"if app_labels is true,",if app_labels :
"call the method apps.get_app_config with an argument app_label, for every app_label in app_labels, append the results to a list,",app_configs = [ apps . get_app_config ( app_label ) for app_label in app_labels ]
"substitute the resulting list for app_config. if not,",else :
app_configs is None.,app_configs = None
"get the value under the 'tags' key of the options dictionary, if it exists substitute it for tags, if not, tags is None.","tags = options . get ( 'tags' , None )"
"if tags exists and if all elements in the return value of the method checks.tag_exists called with an argument tag,",if tags and any ( not checks . tag_exists ( tag ) for tag in tags ) :
"for every tag in tags, are false, for every tag in tags, if return value of the method checks.tag_exists called with an argument tag, evaluates to false,",invalid_tag = next ( tag for tag in tags if not checks . tag_exists ( tag ) )
"use tag as an argument to call the iterator method next, substitute the result for invalid_tag. raise an CommandError exception with an argument string 'There is no system check with the ""%s"" tag.', where '%s' is replaced with invalid_tag.","raise CommandError ( 'There is no system check with the ""%s"" tag.' % invalid_tag )"
"call the method self.check with arguments: app_configs set to app_configs, tags set to tags, display_num_errors set to boolean True.","self . check ( app_configs = app_configs , tags = tags , display_num_errors = True )"
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
import module codecs.,import codecs
import module glob.,import glob
import module os.,import os
from django.core.management.base import BaseCommand and CommandError into default name space.,"from django . core . management . base import BaseCommand , CommandError"
from django.core.management.utils import find_command and popen_wrapper into default name space.,"from django . core . management . utils import find_command , popen_wrapper"
from django.utils._os import npath and upath into default name space.,"from django . utils . _os import npath , upath"
define the function has_bom with fn as argument.,def has_bom ( fn ) :
"open the file fn in read mode, with file descriptor as f,","with open ( fn , 'rb' ) as f :"
read 4 bytes from file f and store it in sample.,sample = f . read ( 4 )
"evaluate the boolean expression, if first three characters of sample equals to string of bytes '\xef\xbb\xbf\',",return sample [ : 3 ] == b'\xef\xbb\xbf' or sample . startswith ( codecs . BOM_UTF16_LE ) or sample . startswith ( codecs . BOM_UTF16_BE )
"of if sample starts with codecs.BOM_UTF16_LE or sample starts with codecs.BOM_UTF16_BE, return the evaluated boolean expression. define the function is_writable with path as argument,",def is_writable ( path ) :
"try,",try :
"with open file path in append mode,","with open ( path , 'a' ) :"
"call the os.utime unction, with path and None as arguments.","os . utime ( path , None )"
"if IOError or OSError exceptions occurred,","except ( IOError , OSError ) :"
return boolean False.,return False
return boolean True.,return True
derive class Command from base class BaseCommand.,class Command ( BaseCommand ) :
help is string 'Compiles .po files to .mo files for use with builtin gettext support.'.,help = 'Compiles .po files to .mo files for use with builtin gettext support.'
requires_system_checks is boolean False.,requires_system_checks = False
leave_locale_alone is boolean True.,leave_locale_alone = True
program is string 'msgfmt',program = 'msgfmt'
program_options is list containing string '--check-format'.,program_options = [ '--check-format' ]
define method add_arguments with self class instance and parser as arguments.,"def add_arguments ( self , parser ) :"
"call the method parser.add_argument with string '--locale', string '-l', dest set to string 'locale', action set to string 'append',","parser . add_argument ( '--locale' , '-l' , dest = 'locale' , action = 'append' , default = [ ] , help = 'Locale(s) to process (e.g. de_AT). Default is to process all. ' 'Can be used multiple times.' )"
"default as an empty list and help as an string 'Locale(s) to process (e.g. de_AT). Default is to process all. Can be used multiple times.'. call the method parser.add_argument with string '--exclude', string '-x', dest set to string 'exclude', action set to string 'append',","parser . add_argument ( '--exclude' , '-x' , dest = 'exclude' , action = 'append' , default = [ ] , help = 'Locales to exclude. Default is none. Can be used multiple times.' )"
default as an empty list and help as an string 'Locales to exclude. Default is none. Can be used multiple times.'. define the handle method with self class instance and dictionary **options as arguments.,"def handle ( self , ** options ) :"
"get the value under the key 'locale' of the options dictionary, substitute it for locale.",locale = options . get ( 'locale' )
"get the value under the key 'exclude' of the options dictionary, substitute it for exclude.",exclude = options . get ( 'exclude' )
"get the value under the key 'exclude' of the options dictionary, convert it to an integer, substitute it for exclude.",self . verbosity = int ( options . get ( 'verbosity' ) )
"if evaluation of the function find_command with self.program as argument equals to None,",if find_command ( self . program ) is None :
"raise CommandError exception, with sring ""Can't find %s. Make sure you have GNU gettext tools 0.15 or newer installed."" as argument, substitute '%s' with self.program.","raise CommandError ( ""Can't find %s. Make sure you have GNU gettext "" ""tools 0.15 or newer installed."" % self . program )"
"basedirs is a list containing tuple with strings, 'conf/locale' and 'locale'.","basedirs = [ os . path . join ( 'conf' , 'locale' ) , 'locale' ]"
if value under the 'DJANGO_SETTINGS_MODULE' key of os.environ dictionary exists.,if os . environ . get ( 'DJANGO_SETTINGS_MODULE' ) :
from django.conf import settings into default name space.,from django . conf import settings
"call function update with path as the argument, for every path in settings.LOCALE_PATHS, extend basedirs list with previous items.",basedirs . extend ( [ upath ( path ) for path in settings . LOCALE_PATHS ] )
"create a list out of basedir elements for which function os.path.isdir returns true, apply the os.path.abspath function on every element, and put the results in a list, basedir is set of previous list elements.","basedirs = set ( map ( os . path . abspath , filter ( os . path . isdir , basedirs ) ) )"
"if basedirs is empty,",if not basedirs :
"raise CommandError exception with string ""This script should be run from the Django Git checkout or your project or app tree, or with the settings module specified."", as argument.","raise CommandError ( ""This script should be run from the Django Git "" ""checkout or your project or app tree, or with "" ""the settings module specified."" )"
all_locales is an empty string.,all_locales = [ ]
"for every basedir in basedirs,",for basedir in basedirs :
"locale_dirs is a list of elements from the list of path names that maths the basedir path with '/*' wild card characters for which call to the os.path.isdir returned true, assign it to locale_dirs.","locale_dirs = filter ( os . path . isdir , glob . glob ( '%s/*' % basedir ) )"
extend all_locales list with the elements of locale_dirs list on which os.path.basename function was applied.,"all_locales . extend ( map ( os . path . basename , locale_dirs ) )"
"take locale or all_locales, whichever is not empty, respectively, and substitute it for locales.",locales = locale or all_locales
locales is relative complement of set exclude in set locales.,locales = set ( locales ) - set ( exclude )
"for every basedir in basedirs,",for basedir in basedirs :
"if locales in not empty,",if locales :
"join basedir, l and string 'LC_MESSAGES' into a path separated by '/' for every l in locales, assign the list to dirs.","dirs = [ os . path . join ( basedir , l , 'LC_MESSAGES' ) for l in locales ]"
"if not,",else :
dirs is a list containing basedir.,dirs = [ basedir ]
locations is an empty list.,locations = [ ]
"for every ldir in dirs,",for ldir in dirs :
"for dirpath, dirnames and filenames, respectively, in directory tree tuple starting from the ldir,","for dirpath , dirnames , filenames in os . walk ( ldir ) :"
"extend locations with tuple containing dirpath and f, for every f in filenames, only if it ends with string '.po'.","locations . extend ( ( dirpath , f ) for f in filenames if f . endswith ( '.po' ) )"
"if locations is not empty,",if locations :
"call the self.compile_messages with locations as argument,",self . compile_messages ( locations )
define compile_messages method with self class instance and locations as a arguments.,"def compile_messages ( self , locations ) :"
"for every i and tuple containing dirpath and f, in enumerated list of locations,","for i , ( dirpath , f ) in enumerate ( locations ) :"
"if self.verbosity is greater than integer 0,",if self . verbosity > 0 :
"call the self.stdout.write method with string 'processing file %s in %s\n' as argument, replacing all the occurrences of '%s' with f and dirpath, respectively.","self . stdout . write ( 'processing file %s in %s\n' % ( f , dirpath ) )"
po_path is a string containing joined directory path from dirpath and f.,"po_path = os . path . join ( dirpath , f )"
evaluate function has_bom with po_path as argument.,if has_bom ( po_path ) :
"raise CommandError exception with string ""The %s file has a BOM (Byte Order Mark). Django only supports .po files encoded in UTF-8 and without any BOM."", with '%s' replaced with po_path, as argument.","raise CommandError ( ""The %s file has a BOM (Byte Order Mark). "" ""Django only supports .po files encoded in "" ""UTF-8 and without any BOM."" % po_path )"
"call os.path.splitext function with po_path as argument, substitute the first element of the result for base_path.",base_path = os . path . splitext ( po_path ) [ 0 ]
if i equals to integer 0 and,if i == 0 and not is_writable ( npath ( base_path + '.mo' ) ) :
"call the self.stderr.write, with string ""The po files under %s are in a seemingly not writable location. mo files will not be updated/created."" as argument, with '%s' replaced by dirpath.","self . stderr . write ( ""The po files under %s are in a seemingly not writable location. "" ""mo files will not be updated/created."" % dirpath )"
return nothing.,return
"extend self.program list with self.program_options, string '-o',","args = [ self . program ] + self . program_options + [ '-o' , npath ( base_path + '.mo' ) , npath ( base_path + '.po' ) ]"
"return value of the npath function with string '.mo' appended to the base_path as argument, and return value of the npath function with string '.po' appended to the base_path as argument, substitute it for args. call the popen_wrapper with args as the argument, assign the result to the output, errors and status, respectively.","output , errors , status = popen_wrapper ( args )"
"if status is True,",if status :
"if errors is True,",if errors :
"msg is a string ""Execution of %s failed: %s"", with '%s' replaced by self.program and errors.","msg = ""Execution of %s failed: %s"" % ( self . program , errors )"
"if not,",else :
"msg is a string ""Execution of %s failed"", with '%s' replaced by self.program.","msg = ""Execution of %s failed"" % self . program"
raise CommandError exception with msg as argument.,raise CommandError ( msg )
from django.conf import settings into default name space.,from django . conf import settings
from django.core.cache import caches into default name space.,from django . core . cache import caches
from django.core.cache.backends.db import BaseDatabaseCache into default name space.,from django . core . cache . backends . db import BaseDatabaseCache
from django.core.management.base import BaseCommand and CommandError into default name space.,"from django . core . management . base import BaseCommand , CommandError"
"from django.db import connections, router, transaction, models and DEFAULT_DB_ALIAS into default name space.","from django . db import connections , router , transaction , models , DEFAULT_DB_ALIAS"
from django.db.utils import DatabaseError into default name space.,from django . db . utils import DatabaseError
from django.utils.encoding import force_text into default name space.,from django . utils . encoding import force_text
derive the class Command from the BaseCommand base class.,class Command ( BaseCommand ) :
"help is an string ""Creates the tables needed to use the SQL cache backend."".","help = ""Creates the tables needed to use the SQL cache backend."""
requires_system_checks is boolean False.,requires_system_checks = False
define the method add_arguments with arguments self and parser.,"def add_arguments ( self , parser ) :"
"call the method parser.add_argument with 4 arguments: string 'args', metavar set to string 'table_name', nargs set to '*' character,","parser . add_argument ( 'args' , metavar = 'table_name' , nargs = '*' , help = 'Optional table names. Otherwise, settings.CACHES is used to ' 'find cache tables.' )"
"and help set to a string 'Optional table names. Otherwise, settings.CACHES is used to find cache tables.' . call the method parser.add_argument with 5 arguments: string '--database', action set to string 'store', dest as a string 'database',","parser . add_argument ( '--database' , action = 'store' , dest = 'database' , default = DEFAULT_DB_ALIAS , help = 'Nominates a database onto which the cache tables will be ' 'installed. Defaults to the ""default"" database.' )"
"default set to DEFAULT_DB_ALIAS and help set to a string: 'Nominates a database onto which the cache tables will be installed. Defaults to the ""default"" database.' define the method handle with arguments self, unpacked list tablenames and unpacked dictionary options.","def handle ( self , * tablenames , ** options ) :"
"get value under the 'database' key of the options dictionary, substitute it for db.",db = options . get ( 'database' )
"get the value under the 'verbosity' key of the options dictionary, convet it to an integer and substitute for self.verbosity.",self . verbosity = int ( options . get ( 'verbosity' ) )
"if length of tablenames is greater than zero,",if len ( tablenames ) :
"for every tablename in tablenames,",for tablename in tablenames :
call the method self.create_table with arguments: db and tablename.,"self . create_table ( db , tablename )"
"if not,",else :
"for every cache_alias in settings.CACHES,",for cache_alias in settings . CACHES :
substitute value under the cache_alias key of the caches dictionary for cache.,cache = caches [ cache_alias ]
"if cache is an instance of BaseDatabaseCache,","if isinstance ( cache , BaseDatabaseCache ) :"
all the method self.create_table with arguments: db and cache._table.,"self . create_table ( db , cache . _table )"
"define the method create_table with arguments self, database and tablename.","def create_table ( self , database , tablename ) :"
"cache is an instance of BaseDatabaseCache class, created with arguments: tablename and an empty dictionary.","cache = BaseDatabaseCache ( tablename , { } )"
"call the method router.allow_migrate with 2 arguments: database and cache.cache_model_class, if it evaluates to false,","if not router . allow_migrate ( database , cache . cache_model_class ) :"
return nothing.,return
substitute value under the database key of the connections dictionary for connection.,connection = connections [ database ]
"if tablename is contained in return value of the method connection.introspection.table_names,",if tablename in connection . introspection . table_names ( ) :
"if self.verbosity is greater than integer 0,",if self . verbosity > 0 :
"replace '%s' in string ""Cache table '%s' already exists."" with tablename, write it to the self.stdout stream.","self . stdout . write ( ""Cache table '%s' already exists."" % tablename )"
return nothing.,return
fields is an tuple containing 3 entries: return value of the method models.CharField called with 4 arguments:,"fields = ( models . CharField ( name = 'cache_key' , max_length = 255 , unique = True , primary_key = True ) , models . TextField ( name = 'value' ) , models . DateTimeField ( name = 'expires' , db_index = True ) , )"
"name set to a string 'cache_key', max_length set to integer 255, unique set to boolean True and primary_key set to boolean True, return value of the method models.TextField called with argument name set to a string 'value', and return value of the method models.DateTimeField called with 2 arguments: name set to string 'expires' and db_index set to True. table_output is an empty list.",table_output = [ ]
index_output is an empty list.,index_output = [ ]
substitute connection.ops.quote_name for qn.,qn = connection . ops . quote_name
"for every f in fields,",for f in fields :
"field_output is an list containing 2 elements: return value of the function qn called with an argument f.name,","field_output = [ qn ( f . name ) , f . db_type ( connection = connection ) ]"
"and return value of the function f.db_type called with an argument connection set to connection. if f.null is false, append string append ""NOT NULL"" to field_output, otherwise append ""NULL"" to field_output.","field_output . append ( ""%sNULL"" % ( ""NOT "" if not f . null else """" ) )"
"if f.primary_key is true,",if f . primary_key :
"append string ""PRIMARY KEY"" to field_output.","field_output . append ( ""PRIMARY KEY"" )"
"otherwise if f.unique is true,",elif f . unique :
"append string ""UNIQUE"" to field_output.","field_output . append ( ""UNIQUE"" )"
"if f.db_index is true,",if f . db_index :
"if f.unique is true, substitute ""UNIQUE "" for unique, otherwise unique is an empty string.","unique = ""UNIQUE "" if f . unique else """""
"replace '%s' in string ""CREATE %sINDEX %s ON %s (%s);"" with: unique, return value of the function qn called with an argument:","index_output . append ( ""CREATE %sINDEX %s ON %s (%s);"" % ( unique , qn ( '%s_%s' % ( tablename , f . name ) ) , qn ( tablename ) , qn ( f . name ) ) )"
"a string '%s_%s', where '%s' is replaced with tablename and f.name, respectively, return value of the function qn called with an argument tablename and return value of the function qn called with an argument f.name. join field_output elements into a string, separated by whitespaces, append it to table_output.","table_output . append ( "" "" . join ( field_output ) )"
"full_statement is a list containing: string ""CREATE TABLE %s ("", where %s is replaced by result of the function qn called with an argument tablename.","full_statement = [ ""CREATE TABLE %s ("" % qn ( tablename ) ]"
"for every i and line in enumerated iterable table_output,","for i , line in enumerate ( table_output ) :"
"replace %s in string ' %s%s' with: line and character ',' if i is lesser than length of table_output decremented by one,","full_statement . append ( ' %s%s' % ( line , ',' if i < len ( table_output ) - 1 else '' ) )"
"or with an empty string if its not, append the resulting string to full_statement. append string ');' to full_statement.",full_statement . append ( ');' )
"evaluate method transaction.atomic with arguments: using set to database and savepoint set to connection.features.can_rollback_ddl,","with transaction . atomic ( using = database , savepoint = connection . features . can_rollback_ddl ) :"
"with the result, evaluate method connection.cursor, with return value as curs,",with connection . cursor ( ) as curs :
"try,",try :
"join full_statement into a string, separated by newlines, use it as an argument for the call to the method curs.execute.","curs . execute ( ""\n"" . join ( full_statement ) )"
"if DatabaseError, renamed to e, exception is caught,",except DatabaseError as e :
"raise an CommandError with an argument string ""Cache table '%s' could not be created.\nThe error was: %s."", replace '%s' with:","raise CommandError ( ""Cache table '%s' could not be created.\nThe error was: %s."" % ( tablename , force_text ( e ) ) )"
"tablename and return value of the function force_text called with an argument e, respectively. for every statement in index_output,",for statement in index_output :
execute statement on the database that curs points to.,curs . execute ( statement )
"if self.verbosity is greater than integer 1,",if self . verbosity > 1 :
"replace '%s' in string ""Cache table '%s' created."" with tablename, write it to self.stdout.","self . stdout . write ( ""Cache table '%s' created."" % tablename )"
from django.core.management.base import BaseCommand and CommandError into default name space.,"from django . core . management . base import BaseCommand , CommandError"
from django.db import connections and DEFAULT_DB_ALIAS into default name space.,"from django . db import connections , DEFAULT_DB_ALIAS"
derive the class Command from the BaseCommand base class.,class Command ( BaseCommand ) :
"help is a tuple containing a string ""Runs the command-line client for specified database, or the default database if none is provided."".","help = ( ""Runs the command-line client for specified database, or the "" ""default database if none is provided."" )"
requires_system_checks is boolean False.,requires_system_checks = False
define the method add_arguments with self and parser.,"def add_arguments ( self , parser ) :"
"call the method parser.add_argument with arguments: string '--database', action set to string 'store', dest set to string 'database',","parser . add_argument ( '--database' , action = 'store' , dest = 'database' , default = DEFAULT_DB_ALIAS , help = 'Nominates a database onto which to ' 'open a shell. Defaults to the ""default"" database.' )"
"default set to DEFAULT_DB_ALIAS and help set to string 'Nominates a database onto which to open a shell. Defaults to the ""default"" database.'. define the method handle with arguments self and unpacked dictionary options.","def handle ( self , ** options ) :"
"get the value under the 'database' key of the options dictionary, use it as a key to access the element under the connections dictionary, substitute it for connection.",connection = connections [ options . get ( 'database' ) ]
"try,",try :
call the method connection.client.runshell.,connection . client . runshell ( )
"if OSError exception is caught,",except OSError :
"raise an CommandError exception with an argument string 'You appear not to have the %r program installed or on your path.',",raise CommandError ( 'You appear not to have the %r program installed or on your path.' % connection . client . executable_name )
from django.core.management.base import BaseCommand into default name space.,from django . core . management . base import BaseCommand
"define the function module_to_dict with 2 arguments: module and omittable as a lambda function with an argument k,","def module_to_dict ( module , omittable = lambda k : k . startswith ( '_' ) ) :"
"return dictionary created out of tuple elements k and printable representation of v,","return dict ( ( k , repr ( v ) ) for k , v in module . __dict__ . items ( ) if not omittable ( k ) )"
"for every k and v in return value of the method module.__dict__.items, only if result of the method omittable called with an argument k is false. derive the class Command from the BaseCommand base class.",class Command ( BaseCommand ) :
requires_system_checks is boolean False.,requires_system_checks = False
define the method add_arguments with 2 arguments self and parser.,"def add_arguments ( self , parser ) :"
"call the method parser.add_argument with 5 arguments: string '--all', action set to string 'store_true', dest set to string 'all',","parser . add_argument ( '--all' , action = 'store_true' , dest = 'all' , default = False , help = 'Display all settings, regardless of their value. ' 'Default values are prefixed by ""###"".' )"
"default set to boolean False and help set to a string 'Display all settings, regardless of their value. Default values are prefixed by ""###"".' define the method handle with arguments self and unpacked dictionary options.","def handle ( self , ** options ) :"
"from django.conf import settings, global_settings into default name space.","from django . conf import settings , global_settings"
call the method settings._setup.,settings . _setup ( )
"call the function module_to_dict with an argument settings._wrapped, substitute it for user_settings.",user_settings = module_to_dict ( settings . _wrapped )
"call the function module_to_dict with an argument global_settings, substitute it for default_settings.",default_settings = module_to_dict ( global_settings )
output is an empty string.,output = [ ]
"for every key in sorted list of user_settings,",for key in sorted ( user_settings ) :
"if key is not contained in default_settings,",if key not in default_settings :
"replace '%s' in string ""%s = %s ###"" with key and value under the key key of the user_setting dictionary, append it to the output.","output . append ( ""%s = %s ###"" % ( key , user_settings [ key ] ) )"
"otherwise if value under the key key of the user_settings dictionary is not equal to the value under the key key of the default_settings dictionary,",elif user_settings [ key ] != default_settings [ key ] :
"replace '%s' in string ""%s = %s"" with key and value under the key key of the user_setting dictionary, append it to the output.","output . append ( ""%s = %s"" % ( key , user_settings [ key ] ) )"
"otherwise if value under the key 'all' of the options dictionary is true,",elif options [ 'all' ] :
"replace '%s' in string ""### %s = %s"" with key and value under the key key of the user_setting dictionary, append it to the output.","output . append ( ""### %s = %s"" % ( key , user_settings [ key ] ) )"
"join elements of the output into a string, separated by newlies, return the string.",return '\n' . join ( output )
import module warnings.,import warnings
from collections import OrderedDict into default name space.,from collections import OrderedDict
from django.apps import apps into default name space.,from django . apps import apps
from django.core.management.base import BaseCommand and CommandError into default name space.,"from django . core . management . base import BaseCommand , CommandError"
from django.core import serializers into default name space.,from django . core import serializers
from django.db import router and DEFAULT_DB_ALIAS into default name space.,"from django . db import router , DEFAULT_DB_ALIAS"
from django.utils.deprecation import RemovedInDjango19Warning into default name space.,from django . utils . deprecation import RemovedInDjango19Warning
derive the class Command from the BaseCommand base class.,class Command ( BaseCommand ) :
"help is a tuple containing a string ""Output the contents of the database as a fixture of the given ""","help = ( ""Output the contents of the database as a fixture of the given "" ""format (using each model's default manager unless --all is "" ""specified)."" )"
"""format (using each model's default manager unless --all is specified)."". define the method add_arguments with arguments self and parser.","def add_arguments ( self , parser ) :"
"call the method parser.add_argument with 4 arguments: string 'args', metavar set to string 'app_label[.ModelName]',","parser . add_argument ( 'args' , metavar = 'app_label[.ModelName]' , nargs = '*' , help = 'Restricts dumped data to the specified app_label or app_label.ModelName.' )"
"nargs set to '*' and help is a string 'Restricts dumped data to the specified app_label or app_label.ModelName.'. call the method parser.add_argument with 4 arguments: string '--format', default set to string 'json',","parser . add_argument ( '--format' , default = 'json' , dest = 'format' , help = 'Specifies the output serialization format for fixtures.' )"
"dest set to 'format' and help is a string 'Specifies the output serialization format for fixtures.'. call the method parser.add_argument with 5 arguments: string '--indent', default set to None, dest set to 'indent',","parser . add_argument ( '--indent' , default = None , dest = 'indent' , type = int , help = 'Specifies the indent level to use when pretty-printing output.' )"
"type set to int and help is a string 'Specifies the indent level to use when pretty-printing output.'. call the method parser.add_argument with 5 arguments: string '--database', default set to string 'store', dest set to 'database',","parser . add_argument ( '--database' , action = 'store' , dest = 'database' , default = DEFAULT_DB_ALIAS , help = 'Nominates a specific database to dump fixtures from. ' 'Defaults to the ""default"" database.' )"
"add set to DEFAULT_DB_ALIAS and help is 'Nominates a specific database to dump fixtures from. Defaults to the ""default"" database.'. call the method parser.add_argument with 6 arguments: string '-e', string '--exclude', dest set to 'exclude', action set to 'append',","parser . add_argument ( '-e' , '--exclude' , dest = 'exclude' , action = 'append' , default = [ ] , help = 'An app_label or app_label.ModelName to exclude ' '(use multiple --exclude to exclude multiple apps/models).' )"
"default is a an empty list and help is a string '(use multiple --exclude to exclude multiple apps/models).'. call the method parser.add_argument with 6 arguments: string '-n', string '--natural', action is string 'store_true', dest is string 'use_natural_keys',","parser . add_argument ( '-n' , '--natural' , action = 'store_true' , dest = 'use_natural_keys' , default = False , help = 'Use natural keys if they are available (deprecated: use --natural-foreign instead).' )"
"default is boolean False and help is a string 'Use natural keys if they are available (deprecated: use --natural-foreign instead).'. call the method parser.add_argument with 5 arguments: string '--natural-foreign', action set to string 'store_true',","parser . add_argument ( '--natural-foreign' , action = 'store_true' , dest = 'use_natural_foreign_keys' , default = False , help = 'Use natural foreign keys if they are available.' )"
"dest is string 'use_natural_foreign_keys', default is boolean False and help is a string 'Use natural foreign keys if they are available.'. call the method parser.add_argument with 5 arguments: string '--natural-primary', action set to 'store_true',","parser . add_argument ( '--natural-primary' , action = 'store_true' , dest = 'use_natural_primary_keys' , default = False , help = 'Use natural primary keys if they are available.' )"
"dest is 'use_natural_primary_keys', default is boolean False and help is a string 'Use natural primary keys if they are available.'. call the method parser.add_argument with 6 arguments: string '-a', string '--all', action set to 'store_true',","parser . add_argument ( '-a' , '--all' , action = 'store_true' , dest = 'use_base_manager' , default = False , help = ""Use Django's base manager to dump all models stored in the database, "" ""including those that would otherwise be filtered or modified by a custom manager."" )"
"dest is 'use_base_manager', default is boolean False and help is a string '(use multiple --exclude to exclude multiple apps/models).'. call the method parser.add_argument with 3 arguments: string '--pks', dest set to string 'primary_keys',","parser . add_argument ( '--pks' , dest = 'primary_keys' , help = ""Only dump objects with given primary keys. "" ""Accepts a comma separated list of keys. "" ""This option will only work when you specify one model."" )"
"and help is a string ""Only dump objects with given primary keys. Accepts a comma separated list of keys. "" ""This option will only work when you specify one model."". call the method parser.add_argument with 5 arguments: string '-o', string '--output', default is None, dest set to string 'output',","parser . add_argument ( '-o' , '--output' , default = None , dest = 'output' , help = 'Specifies file to which the output is written.' )"
"and help is a string 'Specifies file to which the output is written.'. define the method handle with arguments self, unpacked list app_labels and unpacked dictionary options.","def handle ( self , * app_labels , ** options ) :"
"get the value under the 'format' key of the options dictionary, substitute the result for format.",format = options . get ( 'format' )
"get the value under the 'indent' key of the options dictionary, substitute the result for indent.",indent = options . get ( 'indent' )
"get the value under the 'database' key of the options dictionary, substitute the result for database.",using = options . get ( 'database' )
"get the value under the 'exclude' key of the options dictionary, substitute the result for exclude.",excludes = options . get ( 'exclude' )
"get the value under the 'output' key of the options dictionary, substitute the result for output.",output = options . get ( 'output' )
"get the value under the 'traceback' key of the options dictionary, substitute the result for traceback.",show_traceback = options . get ( 'traceback' )
"get the value under the 'use_natural_keys' key of the options dictionary, substitute the result for use_natural_keys.",use_natural_keys = options . get ( 'use_natural_keys' )
"if use_natural_keys is true,",if use_natural_keys :
"call the function warnings.warn with an argument string ""``--natural`` is deprecated; use ``--natural-foreign`` instead."",","warnings . warn ( ""``--natural`` is deprecated; use ``--natural-foreign`` instead."" , RemovedInDjango19Warning )"
"and RemovedInDjango19Warning. get the value under the ' use_natural_foreign_keys' key of the options dictionary, substitute the result for use_natural_foreign_keys.",use_natural_foreign_keys = options . get ( 'use_natural_foreign_keys' ) or use_natural_keys
"get the value under the 'use_natural_primary_keys' key of the options dictionary, substitute the result for use_natural_primary_keys.",use_natural_primary_keys = options . get ( 'use_natural_primary_keys' )
"get the value under the 'use_base_manager' key of the options dictionary, substitute the result for use_base_manager.",use_base_manager = options . get ( 'use_base_manager' )
"get the value under the 'primary_keys' key of the options dictionary, substitute the result for pks.",pks = options . get ( 'primary_keys' )
"if pks is true,",if pks :
"split string pks by ',', substitute the result for primary_keys.","primary_keys = pks . split ( ',' )"
"if not,",else :
primary_keys is an empty list.,primary_keys = [ ]
excluded_apps is an empty set.,excluded_apps = set ( )
excluded_models is an empty set.,excluded_models = set ( )
"for every exclude in excludes,",for exclude in excludes :
"if '.' is contained in exclude,",if '.' in exclude :
"try,",try :
"call the method apps.get_model with exclude as an argument, substitute it for model.",model = apps . get_model ( exclude )
"if LookupError exception is caught,",except LookupError :
"raise an CommandError exception with an argument string 'Unknown model in excludes: %s', where '%s' is replaced with exclude.",raise CommandError ( 'Unknown model in excludes: %s' % exclude )
add model to excluded_models set.,excluded_models . add ( model )
"if not,",else :
"try,",try :
"call the method apps.get_app_config with an argument exclude, substitute the result for app_config.",app_config = apps . get_app_config ( exclude )
"if LookupError exception is caught,",except LookupError :
"raise CommandError with an argument string 'Unknown app in excludes: %s', where '%s' is replaced with exclude.",raise CommandError ( 'Unknown app in excludes: %s' % exclude )
add app_config to excluded_apps set.,excluded_apps . add ( app_config )
"if length of app_labels equals integer 0,",if len ( app_labels ) == 0 :
"if primary_keys is true,",if primary_keys :
"raise an CommandError exception with an argument string ""You can only use --pks option with one model"".","raise CommandError ( ""You can only use --pks option with one model"" )"
"app_list is an instance of OrderedDict class, created with an argument a tuple containing elements: app_config and None,","app_list = OrderedDict ( ( app_config , None ) for app_config in apps . get_app_configs ( ) if app_config . models_module is not None and app_config not in excluded_apps )"
"for every app_config in return value of the method apps.get_app_configs, only if app_config.models_module is not None, and app_config is not contained in excluded_apps. if not,",else :
"if length of app_labels is greater than integer 1 and primary_keys is true,",if len ( app_labels ) > 1 and primary_keys :
"raise an CommandError exception with an argument string ""You can only use --pks option with one model"".","raise CommandError ( ""You can only use --pks option with one model"" )"
app_list is an instance of a class OrderedDict.,app_list = OrderedDict ( )
"for every label in app_labels,",for label in app_labels :
"try,",try :
"split label by '.', assign the result to app_label and model_label, respectively.","app_label , model_label = label . split ( '.' )"
"try,",try :
"call the method apps.get_app_config with an argument app_label, substitute the result for app_config.",app_config = apps . get_app_config ( app_label )
"if LookupError exception is caught,",except LookupError :
"raise CommandError with an argument string 'Unknown app in excludes: %s', where '%s' is replaced with exclude.","raise CommandError ( ""Unknown application: %s"" % app_label )"
"if app_config.models_module is None or app_config is contained in excluded_apps,",if app_config . models_module is None or app_config in excluded_apps :
skip this loop iteration.,continue
"try,",try :
"call the method app_config.get_model with an argument model_label, substitute the result for model.",model = app_config . get_model ( model_label )
"if LookupError exception is caught,",except LookupError :
"raise CommandError with an argument string 'Unknown model: %s', where '%s' is replaced with app_label and model_label, respectively.","raise CommandError ( ""Unknown model: %s.%s"" % ( app_label , model_label ) )"
"call the method app_list.setdefault with 2 arguments app_config and an empty list, substitute the result for app_list_value.","app_list_value = app_list . setdefault ( app_config , [ ] )"
"if app_list_value is not None,",if app_list_value is not None :
"if mode is not contained in app_list_value,",if model not in app_list_value :
append model to app_list_value.,app_list_value . append ( model )
"if ValueError exception is caught,",except ValueError :
"if primary_keys is true,",if primary_keys :
"raise an CommandError exception with an argument string ""You can only use --pks option with one model"".","raise CommandError ( ""You can only use --pks option with one model"" )"
substitute label for app_label.,app_label = label
"try,",try :
"call the method apps.get_app_config with an argument app_label, substitute the result for app_config.",app_config = apps . get_app_config ( app_label )
"if LookupError exception is caught,",except LookupError :
"raise CommandError with an argument string 'Unknown application: %s', where '%s' is replaced with app_label.","raise CommandError ( ""Unknown application: %s"" % app_label )"
if app_config.models_module is None or app_config is contained in excluded_apps,if app_config . models_module is None or app_config in excluded_apps :
skip this loop iteration.,continue
value under the app_config key of the app_list is None.,app_list [ app_config ] = None
"if format is not contained in return value of the method serializers.get_public_serializer_formats,",if format not in serializers . get_public_serializer_formats ( ) :
"try,",try :
call the method serializers.get_serializer with an argument format.,serializers . get_serializer ( format )
"if serializers.SerializerDoesNotExist exception is caught,",except serializers . SerializerDoesNotExist :
do nothing.,pass
"raise CommandError with an argument string 'Unknown serialization format: %s', where '%s' is replaced with format.","raise CommandError ( ""Unknown serialization format: %s"" % format )"
define the function get_objects.,def get_objects ( ) :
"call the method app_list.items, use the result as an argument for the call to the function sort_dependencies, for every model in result,",for model in sort_dependencies ( app_list . items ( ) ) :
"if model is contained in excluded_models,",if model in excluded_models :
skip this loop iteration.,continue
"if model._meta.proxy is false and return value of the function router.allow_migrate called with arguments using and model is true,","if not model . _meta . proxy and router . allow_migrate ( using , model ) :"
"if use_base_manager is true,",if use_base_manager :
substitute model._base_manager for objects.,objects = model . _base_manager
"if not,",else :
substitute model._default_manager for objects.,objects = model . _default_manager
"call the method objects.using with an argument using, call the method order_by on the result with an argument model._meta.pk.name,",queryset = objects . using ( using ) . order_by ( model . _meta . pk . name )
"substitute the result for queryset. if primary_keys is true,",if primary_keys :
"call the method queryset.filter with an argument pk__in set to primary_keys, substitute the result for queryset.",queryset = queryset . filter ( pk__in = primary_keys )
"for every obj in result of the method queryset.iterator,",for obj in queryset . iterator ( ) :
"yield obj, as an return value of the generator.",yield obj
"try,",try :
self.stdout.ending is None.,self . stdout . ending = None
"open the output file in writing mode if output is true, assign the file descriptor to stream, otherwise stream is None.","stream = open ( output , 'w' ) if output else None"
"try,",try :
"call the method serializers.serialize with 6 arguments: format, result of the function get_objects, indent set to indent,","serializers . serialize ( format , get_objects ( ) , indent = indent , use_natural_foreign_keys = use_natural_foreign_keys , use_natural_primary_keys = use_natural_primary_keys , stream = stream or self . stdout )"
"use_natural_foreign_keys set to use_natural_foreign_keys, use_natural_primary_keys set to use_natural_primary_keys, and stream set to stream, if the stream is true, otherwise stream set to self.stdout. finally perform,",finally :
"if stream is true,",if stream :
close the file stream.,stream . close ( )
"if Exception, renamed to e, exception is caught,",except Exception as e :
"if show_traceback is true,",if show_traceback :
raise an exception.,raise
"raise CommandError with an argument string ""Unable to serialize database: %s"", where '%s' is replaced with e.","raise CommandError ( ""Unable to serialize database: %s"" % e )"
define the function sort_dependencies with an argument app_list.,def sort_dependencies ( app_list ) :
model_dependencies is an empty list.,model_dependencies = [ ]
models is an empty set.,models = set ( )
"for every app_config and model_list in app_list,","for app_config , model_list in app_list :"
"if model_list is None,",if model_list is None :
"call the method app_config.get_models, substitute the result fr model_list.",model_list = app_config . get_models ( )
"for every model in model_list,",for model in model_list :
add model to models set.,models . add ( model )
"if model has an 'natural_key' attribute,","if hasattr ( model , 'natural_key' ) :"
"get 'dependencies' attribute of the model.natural_key, substitute it for deps, if the attribute doesnt exist, deps in an empty list.","deps = getattr ( model . natural_key , 'dependencies' , [ ] )"
"if deps is true,",if deps :
"for every dep in deps call the method apps.get_model with an argument dep, and append the result to the list, substitute it for deps.",deps = [ apps . get_model ( dep ) for dep in deps ]
"if not,",else :
deps is an empty list.,deps = [ ]
"for every field in model._meta.fields,",for field in model . _meta . fields :
"if field.rel has an 'to' attribute,","if hasattr ( field . rel , 'to' ) :"
substitute field.rel.to with rel_model.,rel_model = field . rel . to
"if rel_model has an attribute 'natural_key' and rel_model is not equal to model,","if hasattr ( rel_model , 'natural_key' ) and rel_model != model :"
append rel_model to deps.,deps . append ( rel_model )
"for every field in model._meta.many_to_many,",for field in model . _meta . many_to_many :
"if field.rel.through._meta.auto_created is true,",if field . rel . through . _meta . auto_created :
substitute field.rel.to for rel_model.,rel_model = field . rel . to
"if rel_model has an 'natural_key' attribute and rel_model is not equal to model,","if hasattr ( rel_model , 'natural_key' ) and rel_model != model :"
append rel_model to deps.,deps . append ( rel_model )
append a tuple containing 2 elements: model and deps to model_dependencies.,"model_dependencies . append ( ( model , deps ) )"
call the methof model_dependencies.reverse.,model_dependencies . reverse ( )
model_list is an empty list.,model_list = [ ]
"while model_dependencies is true,",while model_dependencies :
skipped is an empty list.,skipped = [ ]
changed is boolean False.,changed = False
"while model_dependencies is true,",while model_dependencies :
"remove first element from model_dependencies, assign it to model and deps, respectively.","model , deps = model_dependencies . pop ( )"
found is boolean True.,found = True
"for every d in deps, if d is not contained in models and d is contained in model_list add boolean True to a tuple,",for candidate in ( ( d not in models or d in model_list ) for d in deps ) :
"otherwise add boolean False, for every candidate in the result perform following, if candidate is false,",if not candidate :
found is boolean False.,found = False
"if found is true,",if found :
append model to model_list.,model_list . append ( model )
changed is boolean True.,changed = True
"if not,",else :
"append a tuple containing 2 elemetns: model and deps, to skipped.","skipped . append ( ( model , deps ) )"
"if changed is false,",if not changed :
"raise an CommandError with argument: string ""Can't resolve dependencies for %s in serialized app list."", where '%s' is replaced with:","raise CommandError ( ""Can't resolve dependencies for %s in serialized app list."" % ', ' . join ( '%s.%s' % ( model . _meta . app_label , model . _meta . object_name ) for model , deps in sorted ( skipped , key = lambda obj : obj [ 0 ] . __name__ ) ) )"
"model._meta.app_label and model._meta.object_name joined into a string, with separator '.', result joined into a string, separated by string ', ' for every model and deps in sorted list of elements skipped sorted by key: return value of the lambda function with an argument obj, and result the __name__ field of the first element of obj. substitute skipped for model_dependencies.",model_dependencies = skipped
return model_list.,return model_list
import module sys.,import sys
from importlib import import_module into default name space.,from importlib import import_module
from django.apps import apps into default name space.,from django . apps import apps
"from django.db import connections, router, transaction and DEFAULT_DB_ALIAS into default name space.","from django . db import connections , router , transaction , DEFAULT_DB_ALIAS"
from django.core.management import call_command into default name space.,from django . core . management import call_command
from django.core.management.base import BaseCommand and CommandError into default name space.,"from django . core . management . base import BaseCommand , CommandError"
from django.core.management.color import no_style into default name space.,from django . core . management . color import no_style
from django.core.management.sql import sql_flush and emit_post_migrate_signal into default name space.,"from django . core . management . sql import sql_flush , emit_post_migrate_signal"
from django.utils.six.moves import input into default name space.,from django . utils . six . moves import input
from django.utils import six into default name space.,from django . utils import six
derive the class Command from the BaseCommand base class.,class Command ( BaseCommand ) :
"help is a tuple containing a string: 'Removes ALL DATA from the database, including data added during '","help = ( 'Removes ALL DATA from the database, including data added during ' 'migrations. Unmigrated apps will also have their initial_data ' 'fixture reloaded. Does not achieve a ""fresh install"" state.' )"
"'migrations. Unmigrated apps will also have their initial_data fixture reloaded. Does not achieve a ""fresh install"" state.' define the add_arguments with arguments self and parser.","def add_arguments ( self , parser ) :"
"call the method parser.add_argument with 5 arguments: string '--noinput', action set to string 'store_false',","parser . add_argument ( '--noinput' , action = 'store_false' , dest = 'interactive' , default = True , help = 'Tells Django to NOT prompt the user for input of any kind.' )"
"dest set to string 'interactive', default set to boolean True, help as a string 'Tells Django to NOT prompt the user for input of any kind.'. call the method parser.add_argument with 5 arguments: string '--database', action set to string 'store', dest as a string 'database',","parser . add_argument ( '--database' , action = 'store' , dest = 'database' , default = DEFAULT_DB_ALIAS , help = 'Nominates a database to flush. Defaults to the ""default"" database.' )"
"default set to DEFAULT_DB_ALIAS and help as a string 'Nominates a database to flush. Defaults to the ""default"" database.'. call the method parser.add_argument with 5 arguments: string '--no-initial-data', action set to string 'store_false',","parser . add_argument ( '--no-initial-data' , action = 'store_false' , dest = 'load_initial_data' , default = True , help = 'Tells Django not to load any initial data after database synchronization.' )"
"dest set to string 'load_initial_data', default=True and help as a string 'Tells Django not to load any initial data after database synchronization.'. define the method handle with arguments self and unpacked dictionary options.","def handle ( self , ** options ) :"
substitute value under the 'database' key of the options dictionary for database.,database = options . get ( 'database' )
substitute value under the database key of the connections dictionary for connection.,connection = connections [ database ]
substitute value under the 'verbosity' key of the options dictionary for verbosity.,verbosity = options . get ( 'verbosity' )
substitute value under the 'interactive' key of the options dictionary for interactive.,interactive = options . get ( 'interactive' )
"get the value 'reset_sequences' key of the options dictionary, if it exists substitute it for reset_sequences, otherwise reset_sequences is boolean True.","reset_sequences = options . get ( 'reset_sequences' , True )"
"get the value 'allow_cascade' key of the options dictionary, if it exists substitute it for allow_cascade, otherwise allow_cascade is boolean False.","allow_cascade = options . get ( 'allow_cascade' , False )"
"get the value 'inhibit_post_migrate' key of the options dictionary, if it exists substitute it for inhibit_post_migrate, otherwise inhibit_post_migrate is boolean False.","inhibit_post_migrate = options . get ( 'inhibit_post_migrate' , False )"
"call the function no_style, substitute it for self.style.",self . style = no_style ( )
"for every app_config in return value of the method apps.get_app_configs,",for app_config in apps . get_app_configs ( ) :
"try,",try :
call the function import_module with 2 arguments: string .management and app_config.name.,"import_module ( '.management' , app_config . name )"
"if ImportError exception is caught,",except ImportError :
do nothing.,pass
"call the method sql_flush with 5 arguments: self.style, connection, only_django set to boolean True,","sql_list = sql_flush ( self . style , connection , only_django = True , reset_sequences = reset_sequences , allow_cascade = allow_cascade )"
"reset_sequences set to reset_sequences, allow_cascade set to allow_cascade, substitute the result for sql_list. if interactive is true,",if interactive :
"request user input from the standard input, assign it o confirm, with the query string: ""You have requested a flush of the database.""","confirm = input ( """"""You have requested a flush of the database. This will IRREVERSIBLY DESTROY all data currently in the %r database, and return each table to an empty state. Are you sure you want to do this? Type 'yes' to continue, or 'no' to cancel: """""" % connection . settings_dict [ 'NAME' ] )"
"""This will IRREVERSIBLY DESTROY all data currently in the %r database, and return each table to an empty state."" ""Are you sure you want to do this?""Type 'yes' to continue, or 'no' to cancel: "", where '%s' is replaced with value under the 'NAME' key of the connection.settings_dict dictionary. if not,",else :
confirm is a string 'yes'.,confirm = 'yes'
"if confirm equals a string 'yes',",if confirm == 'yes' :
"try,",try :
"call the method transaction.atomic with 2 arguments: using set to database, savepoint set to connection.features.can_rollback_ddl,","with transaction . atomic ( using = database , savepoint = connection . features . can_rollback_ddl ) :"
"with the result, call the method connection.cursor, with the result as cursor,",with connection . cursor ( ) as cursor :
"for every sql in sql_list,",for sql in sql_list :
call the method cursor.execute with an argument sql.,cursor . execute ( sql )
"if Exception, renamed to e, exception is caught,",except Exception as e :
"new_msg is a tuple containing a string: ""Database %s couldn't be flushed. Possible reasons:\n""","new_msg = ( ""Database %s couldn't be flushed. Possible reasons:\n"" "" * The database isn't running or isn't configured correctly.\n"" "" * At least one of the expected database tables doesn't exist.\n"" "" * The SQL was invalid.\n"" ""Hint: Look at the output of 'django-admin.py sqlflush'. That's the SQL this command wasn't able to run.\n"" ""The full error: %s"" ) % ( connection . settings_dict [ 'NAME' ] , e )"
""" * The database isn't running or isn't configured correctly.\n * At least one of the expected database tables doesn't exist.\n"" "" * The SQL was invalid.\nHint: Look at the output of 'django-admin.py sqlflush'. That's the SQL this command wasn't able to run.\n"" ""The full error: %s"", where '%s' is replaced by value under the 'NAME' key of the connection.settings_dict dictionary and e. call the function six.reraise with 3 arguments: CommandError, CommandError created with argument new_msg,","six . reraise ( CommandError , CommandError ( new_msg ) , sys . exc_info ( ) [ 2 ] )"
"and third element of the return value of the function sys.exc_info. if inhibit_post_migrate is false,",if not inhibit_post_migrate :
"call the method self.emit_post_migrate with arguments verbosity, interactive and database.","self . emit_post_migrate ( verbosity , interactive , database )"
"if value under the 'load_initial_data' key of the options dictionary is true,",if options . get ( 'load_initial_data' ) :
"call the function call_command with 3 arguments: string 'loaddata', string 'initial_data' and unpacked dictionary options.","call_command ( 'loaddata' , 'initial_data' , ** options )"
"if not,",else :
"write string ""Flush cancelled.\n"" to self.stdout stream.","self . stdout . write ( ""Flush cancelled.\n"" )"
"class static method,",@ staticmethod
"define the method emit_post_migrate with arguments verbosity, interactive and database.","def emit_post_migrate ( verbosity , interactive , database ) :"
all_models is an empty list.,all_models = [ ]
"for every app_config in return value of the method apps.get_app_configs,",for app_config in apps . get_app_configs ( ) :
"call the method router.get_migratable_models with arguments app_config, database and include_auto_created set to boolean True,","all_models . extend ( router . get_migratable_models ( app_config , database , include_auto_created = True ) )"
"extend all_models list with the result. call the function emit_post_migrate_signal with 4 arguments: all_models converted into a set, verbosity, interactive and database.","emit_post_migrate_signal ( set ( all_models ) , verbosity , interactive , database )"
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
from collections import OrderedDict into default name space.,from collections import OrderedDict
import module keyword.,import keyword
import module re.,import re
from django.core.management.base import BaseCommand and CommandError into default name space.,"from django . core . management . base import BaseCommand , CommandError"
from django.db import connections and DEFAULT_DB_ALIAS into default name space.,"from django . db import connections , DEFAULT_DB_ALIAS"
derive the class Command from the BaseCommand base class.,class Command ( BaseCommand ) :
"help is an string ""Introspects the database tables in the given database and outputs a Django model module."".","help = ""Introspects the database tables in the given database and outputs a Django model module."""
requires_system_checks is boolean False.,requires_system_checks = False
db_module is a string 'django.db'.,db_module = 'django.db'
define the method add_arguments with arguments self and parser.,"def add_arguments ( self , parser ) :"
"call the method parser.add_argument with 5 arguments: string '--database', action set to string 'store', dest as a string 'database',","parser . add_argument ( '--database' , action = 'store' , dest = 'database' , default = DEFAULT_DB_ALIAS , help = 'Nominates a database to ' 'introspect. Defaults to using the ""default"" database.' )"
"default set to DEFAULT_DB_ALIAS and help as a string 'Nominates a database to introspect. Defaults to using the ""default"" database.'. define the method handle with 2 arguments: self and unpacked dictionary options.","def handle ( self , ** options ) :"
"try,",try :
"for every line in return value of the method self.handle_inspection called with an argument options,",for line in self . handle_inspection ( options ) :
"append new line to line, write it to self.stdout stream.","self . stdout . write ( ""%s\n"" % line )"
"if NotImplementedError exception is caught,",except NotImplementedError :
"raise an CommandError exception with an argument ""Database inspection isn't supported for the currently selected database backend."".","raise CommandError ( ""Database inspection isn't supported for the currently selected database backend."" )"
define the method handle_inspection with 2 argument: self and options.,"def handle_inspection ( self , options ) :"
"get value under the 'database' key of the options dictionary, use it as a key to get the value from the connections dictionary,",connection = connections [ options [ 'database' ] ]
"substitute the result for connection. get the value under the 'table_name_filter' key of the options dictionary, substitute it for table_name_filter.",table_name_filter = options . get ( 'table_name_filter' )
"table2model is a lambda function with an argument table_name, return value is the return value of the re.sub method,","table2model = lambda table_name : re . sub ( r'[^a-zA-Z0-9]' , '' , table_name . title ( ) )"
"called with 3 arguments: raw string '[^a-zA-Z0-9]', empty string and result of the method table_name.title. strip_prefix is a lambda function with an argument s, return value is s without the first element if s starts with string 'u'',","strip_prefix = lambda s : s [ 1 : ] if s . startswith ( ""u'"" ) else s"
"otherwise returns s. call the method connection.cursor, with the result as cursor,",with connection . cursor ( ) as cursor :
"yield string ""# This is an auto-generated Django model module."" as the result.","yield ""# This is an auto-generated Django model module."""
"yield string ""# You'll have to do the following manually to clean this up:"" as the result.","yield ""# You'll have to do the following manually to clean this up:"""
"yield string ""# * Rearrange models' order"" as the result.","yield ""# * Rearrange models' order"""
"yield string ""# * Make sure each model has one field with primary_key=True"" as the result.","yield ""# * Make sure each model has one field with primary_key=True"""
"yield string ""# * Remove `managed = False` lines if you wish to allow Django to create, modify, and delete the table"" as the result.","yield ""# * Remove `managed = False` lines if you wish to allow Django to create, modify, and delete the table"""
"yield string ""# Feel free to rename the models, but don't rename db_table values or field names."" as the result.","yield ""# Feel free to rename the models, but don't rename db_table values or field names."""
"yield string ""#"" as the result.","yield ""#"""
"yield string ""# Also note: You'll have to insert the output of 'django-admin.py sqlcustom [app_label]'"" as the result.","yield ""# Also note: You'll have to insert the output of 'django-admin.py sqlcustom [app_label]'"""
"yield string ""# into your database."" as the result.","yield ""# into your database."""
"yield string ""from __future__ import unicode_literals"" as the result.","yield ""from __future__ import unicode_literals"""
yield and empty string as the result.,yield ''
"yield string 'from %s import models' % self.db_module as the result, where ""%s"" is replaced with self.db_module.",yield 'from %s import models' % self . db_module
known_models is an empty list.,known_models = [ ]
"for every table_name in return value of the method connection.introspection.table_names called with an argument cursor,",for table_name in connection . introspection . table_names ( cursor ) :
"if table_name_filter is not None and table_name_filter is callable object,",if table_name_filter is not None and callable ( table_name_filter ) :
"call the function table_name_filter with an argument table_name, if it evaluates to true,",if not table_name_filter ( table_name ) :
"skip this loop iteration,",continue
yield and empty string as the result.,yield ''
yield and empty string as the result.,yield ''
"yield string 'from %s import models' % self.db_module as the result, where ""%s"" is replaced with result of the call to the function,",yield 'class %s(models.Model):' % table2model ( table_name )
"table2model with an argument table_name. call the function table2model with an argument table_name, append the result to known_models.",known_models . append ( table2model ( table_name ) )
"try,",try :
"call the method connection.introspection.get_relations with 2 arguments cursor, table_name and substitute the result for relations.","relations = connection . introspection . get_relations ( cursor , table_name )"
"if NotImplementedError exception is caught,",except NotImplementedError :
relations is an empty dictionary.,relations = { }
"try,",try :
"call the method connection.introspection.get_relations with 2 arguments cursor, table_name and substitute the result for indexes.","indexes = connection . introspection . get_indexes ( cursor , table_name )"
"if NotImplementedError exception is caught,",except NotImplementedError :
indexes is an empty dictionary.,indexes = { }
used_column_names is an empty list.,used_column_names = [ ]
"for every i and row in enumerated result of the method connection.introspection.get_table_description called with arguments: cursor and table_name,","for i , row in enumerate ( connection . introspection . get_table_description ( cursor , table_name ) ) :"
comment_notes is an empty list.,comment_notes = [ ]
extra_params is an instance of the class OrderedDict.,extra_params = OrderedDict ( )
substitute first element of row for column_name.,column_name = row [ 0 ]
"if i is contained in relations, is_relation is boolean True, otherwise is_relation is boolean False.",is_relation = i in relations
"call the method self.normalize_col_name with 3 arguments column_name, used_column_names, is_relation, assign the result to att_name, params and notes, respectively.","att_name , params , notes = self . normalize_col_name ( column_name , used_column_names , is_relation )"
add params to extra_params dictionary.,extra_params . update ( params )
extend comment_notes list with notes.,comment_notes . extend ( notes )
append att_name to used_column_names list.,used_column_names . append ( att_name )
"if column_name is contained in indexes,",if column_name in indexes :
"if value under the 'primary_key' key of the dictionary contained under the column_name key of the dictionary indexes is true,",if indexes [ column_name ] [ 'primary_key' ] :
"value under the 'primary_key' key of the extra_params dictionary is boolean True,",extra_params [ 'primary_key' ] = True
"otherwise if, if value under the 'unique' key of the dictionary contained under the column_name key of the dictionary indexes is true,",elif indexes [ column_name ] [ 'unique' ] :
"value under the 'unique' key of the extra_params dictionary is boolean True,",extra_params [ 'unique' ] = True
"if is_relation is true,",if is_relation :
"if second element of the i-th row of relations equals table_name, rel_to is string 'self',","rel_to = ""self"" if relations [ i ] [ 1 ] == table_name else table2model ( relations [ i ] [ 1 ] )"
"otherwise call the method table2model with second element of the i-th row of relations and substitute it for rel_to. if rel_to is contained in known_models,",if rel_to in known_models :
"append rel_to to string 'ForeignKey(, substitute the result for field_type.",field_type = 'ForeignKey(%s' % rel_to
"if not,",else :
"append rel_to to string 'ForeignKey(, append character ""'"" to it, substitute the result for field_type.","field_type = ""ForeignKey('%s'"" % rel_to"
"if not,",else :
"call the method self.get_field_type with 3 arguments connection, table_name and row, assign the result to field_type, field_params,","field_type , field_params , field_notes = self . get_field_type ( connection , table_name , row )"
"field_notes, respectively. add field_params to extra_params dictionary.",extra_params . update ( field_params )
extend comment_notes list with field_notes.,comment_notes . extend ( field_notes )
append '(' to field_type.,field_type += '('
"if att_name equals string 'id' and extra_params equals a dictionary with 1 entry: boolean True for 'primary_key',",if att_name == 'id' and extra_params == { 'primary_key' : True } :
"if field_type equals a string 'AutoField(',",if field_type == 'AutoField(' :
skip this loop iteration.,continue
"otherwise if field_type equals a string 'IntegerField(' and connection.features.can_introspect_autofield is false,",elif field_type == 'IntegerField(' and not connection . features . can_introspect_autofield :
append string 'AutoField?' to comment_notes.,comment_notes . append ( 'AutoField?' )
"if seventh element of row is true,",if row [ 6 ] :
"if field_type equals a string 'BooleanField(',",if field_type == 'BooleanField(' :
field_type is a string 'NullBooleanField(',field_type = 'NullBooleanField('
"if not,",else :
value under the 'blank' key of the extra_params dictionary is boolean True.,extra_params [ 'blank' ] = True
"if field_type is not equal to string 'TextField(' or string 'CharField(',","if field_type not in ( 'TextField(' , 'CharField(' ) :"
value under the 'null' key of the extra_params dictionary is boolean True.,extra_params [ 'null' ] = True
"field_desc is a string '%s = %s%s', where '%s' is replaced with: att_name, an empty string if '.' is contained in field_type,","field_desc = '%s = %s%s' % ( att_name , '' if '.' in field_type else 'models.' , field_type , )"
"or with string 'models.' if it is not and field_type. if extra_params is true,",if extra_params :
"if field_desc doesnt end with '(',",if not field_desc . endswith ( '(' ) :
"append string ', ' to field_desc.","field_desc += ', '"
"in string '%s=%s' replace '%s' with k and return value of the function strip_prefix with an argument printable representation of v,","field_desc += ', ' . join ( [ '%s=%s' % ( k , strip_prefix ( repr ( v ) ) ) for k , v in extra_params . items ( ) ] )"
"for every k and v in return value of the extra_params.items method, join all results into a string separated by a string ', ', substitute it for field_desc. append string ')' to field_desc.",field_desc += ')'
"if comment_notes is true,",if comment_notes :
"join elements of comment_notes into a string, separated by whitespaces, append it to the string ' #', append the result to field_desc.",field_desc += ' # ' + ' ' . join ( comment_notes )
"yield string ' %s', where '%s' is replaced with field_desc.",yield ' %s' % field_desc
for meta_line in return value of the method self.get_meta called with an argument table_name.,for meta_line in self . get_meta ( table_name ) :
yield meta_line as the result.,yield meta_line
"define the method normalize_col_name with 4 arguments: self, col_name, used_column_names and is_relation.","def normalize_col_name ( self , col_name , used_column_names , is_relation ) :"
field_params is an empty dictionary.,field_params = { }
field_notes is an empty list.,field_notes = [ ]
"convert col_name to lowercase, substitute the result for new_name.",new_name = col_name . lower ( )
"if new_name is not equal to col_name,",if new_name != col_name :
append string 'Field name made lowercase.' to field_notes.,field_notes . append ( 'Field name made lowercase.' )
"if is_relation,",if is_relation :
"if new_name ends with string '_id',",if new_name . endswith ( '_id' ) :
"substitute new_name, without the last 3 elements for new_name.",new_name = new_name [ : - 3 ]
"if not,",else :
substitute col_name for value under the 'db_column' key of the field_params dictionary.,field_params [ 'db_column' ] = col_name
"cal the method re.subn with 3 arguments: raw string '\W', string '_' and new_name.","new_name , num_repl = re . subn ( r'\W' , '_' , new_name )"
"if num_repl is greater than integer 0,",if num_repl > 0 :
append string 'Field renamed to remove unsuitable characters.' to field_notes.,field_notes . append ( 'Field renamed to remove unsuitable characters.' )
"call the method new_name.find, with an argument string '__', if it evaluates to greater or equal than integer 0,",if new_name . find ( '__' ) >= 0 :
"while the result of the method new_name.find, called with an argument string '__' is greater or equals integer 0,",while new_name . find ( '__' ) >= 0 :
replace all the occurrences of '__' with '_' in new_name.,"new_name = new_name . replace ( '__' , '_' )"
"convert col_name to lowercase, on the result call the method find with an argument string '__', if the result is greater of equal to integer 0,",if col_name . lower ( ) . find ( '__' ) >= 0 :
"append string ""Field renamed because it contained more than one '_' in a row."" to field_notes.","field_notes . append ( ""Field renamed because it contained more than one '_' in a row."" )"
"if new_name starts with a string '_',",if new_name . startswith ( '_' ) :
"convert new_name to a string and append it to string 'field', substitute the result for new_name.",new_name = 'field%s' % new_name
"append string ""Field renamed because it started with '_'."" to field_notes.","field_notes . append ( ""Field renamed because it started with '_'."" )"
"if new_name ends with a string '_',",if new_name . endswith ( '_' ) :
"convert new_name to a string and append string 'field' to it, substitute the result for new_name.",new_name = '%sfield' % new_name
"append string ""Field renamed because it ended with '_'."" to field_notes.","field_notes . append ( ""Field renamed because it ended with '_'."" )"
"call the method keyword.iskeyword with an argument new_name, if it evaluates to true,",if keyword . iskeyword ( new_name ) :
append string '_field' to new_name.,new_name += '_field'
"append string ""Field renamed because it was a Python reserved word."" to field_notes.",field_notes . append ( 'Field renamed because it was a Python reserved word.' )
"if first element of new_name is digit,",if new_name [ 0 ] . isdigit ( ) :
"convert new_name to a string and append it to string 'number_', substitute the result for new_name.",new_name = 'number_%s' % new_name
"append string ""Field renamed because it wasn't a valid Python identifier."" to field_notes.","field_notes . append ( ""Field renamed because it wasn't a valid Python identifier."" )"
"if new_name is contained in used_column_names,",if new_name in used_column_names :
num is an integer 0.,num = 0
"in string '%s_%d', replace '%s' with new_name and '%d' with num, while the result is contained in used_column_names,","while '%s_%d' % ( new_name , num ) in used_column_names :"
increment num by one.,num += 1
"in string '%s_%d', replace '%s' with new_name and '%d' with num, substitute the result for new_name.","new_name = '%s_%d' % ( new_name , num )"
"append string ""Field renamed because of name conflict."" to field_notes.",field_notes . append ( 'Field renamed because of name conflict.' )
"if col_name is not equal to new_name and field_notes is true,",if col_name != new_name and field_notes :
substitute col_name for value under the 'db_column' key of the field_params dictionary.,field_params [ 'db_column' ] = col_name
"return new_name, field_params and field_notes.","return new_name , field_params , field_notes"
"define the method get_field_type with 4 arguments: self, connection, table_name and row.","def get_field_type ( self , connection , table_name , row ) :"
field_params is an instance of a class OrderedDict.,field_params = OrderedDict ( )
field_notes is an empty list.,field_notes = [ ]
"try,",try :
"call the method connection.introspection.get_field_type with 2 arguments: second element of row and row, substitute the result for field_type.","field_type = connection . introspection . get_field_type ( row [ 1 ] , row )"
"if KeyError exception is caught,",except KeyError :
field_type is a string 'TextField'.,field_type = 'TextField'
append a string 'This field type is a guess.' to field_notes.,field_notes . append ( 'This field type is a guess.' )
"if field_type is a tuple,",if type ( field_type ) is tuple :
"substitute field_type for field_type and new_params, respectively.","field_type , new_params = field_type"
call the method field_params.update with an argument new_params.1,field_params . update ( new_params )
"if field_type equals a string CharField' and fourth element of row is true,",if field_type == 'CharField' and row [ 3 ] :
"convert fourth element of row to an integer, substitute it for value under the 'max_digits' key of the field_params.",field_params [ 'max_length' ] = int ( row [ 3 ] )
"if field_type equals a string 'DecimalField',",if field_type == 'DecimalField' :
"if fifth and sixth elements of row are None,",if row [ 4 ] is None or row [ 5 ] is None :
"append string 'max_digits and decimal_places have been guessed, as this database handles decimal fields as float' to field_notes.","field_notes . append ( 'max_digits and decimal_places have been guessed, as this ' 'database handles decimal fields as float' )"
"if fifth element of row is not None, substitute it for value under the 'max_digits' key of the field_params,",field_params [ 'max_digits' ] = row [ 4 ] if row [ 4 ] is not None else 10
"otherwise, value under the 'max_digits' key of the field_params is integer 10. if sixth element of row is not None, substitute it for value under the 'decimal_places' key of the field_params,",field_params [ 'decimal_places' ] = row [ 5 ] if row [ 5 ] is not None else 5
"otherwise, value under the 'decimal_places' key of the field_params is integer 5. if not",else :
substitute fifth element of row for value under the 'max_digits' key of the field_params.,field_params [ 'max_digits' ] = row [ 4 ]
substitute sixth element of row for value under the 'decimal_places' key of the field_params.,field_params [ 'decimal_places' ] = row [ 5 ]
"return field_type, field_params and field_notes.","return field_type , field_params , field_notes"
define the method get_meta with arguments self and table_name.,"def get_meta ( self , table_name ) :"
"return the list, containing 4 elements: an empty string, string "" class Meta:"", string "" managed = False"",","return [ """" , "" class Meta:"" , "" managed = False"" , "" db_table = '%s'"" % table_name ]"
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
import module glob.,import glob
import module gzip.,import gzip
import module os.,import os
import module warnings.,import warnings
import module zipfile.,import zipfile
from django.apps import apps into default name space.,from django . apps import apps
from django.conf import settings into default name space.,from django . conf import settings
from django.core import serializers into default name space.,from django . core import serializers
from django.core.management.base import BaseCommand and CommandError into default name space.,"from django . core . management . base import BaseCommand , CommandError"
from django.core.management.color import no_style into default name space.,from django . core . management . color import no_style
"from django.db import connections, router, transaction, DEFAULT_DB_ALIAS, IntegrityError and DatabaseError into default name space.","from django . db import ( connections , router , transaction , DEFAULT_DB_ALIAS , IntegrityError , DatabaseError )"
from django.utils import lru_cache into default name space.,from django . utils import lru_cache
from django.utils.encoding import force_text into default name space.,from django . utils . encoding import force_text
from django.utils.functional import cached_property into default name space.,from django . utils . functional import cached_property
from django.utils._os import upath into default name space.,from django . utils . _os import upath
from itertools import product into default name space.,from itertools import product
"try,",try :
import bz2.,import bz2
has_bz2 is boolean True.,has_bz2 = True
"if ImportError exception is caught,",except ImportError :
has_bz2 is boolean False.,has_bz2 = False
derive the class Command from the BaseCommand base class.,class Command ( BaseCommand ) :
help is an string 'Installs the named fixture(s) in the database.'.,help = 'Installs the named fixture(s) in the database.'
"missing_args_message is a tuple containing a string ""No database fixture specified. Please provide the ""","missing_args_message = ( ""No database fixture specified. Please provide the "" ""path of at least one fixture in the command line."" )"
"""path of at least one fixture in the command line."" define the method add_arguments with 2 arguments: self and parser.","def add_arguments ( self , parser ) :"
"call the method parser.add_argument with 4 arguments: string 'args', metavar set to string 'fixture', nargs set to '+',","parser . add_argument ( 'args' , metavar = 'fixture' , nargs = '+' , help = 'Fixture labels.' )"
"and help set to 'Fixture labels.'. call the method parser.add_argument with 5 arguments: string '--database', action set to string 'store', dest as a string 'database',","parser . add_argument ( '--database' , action = 'store' , dest = 'database' , default = DEFAULT_DB_ALIAS , help = 'Nominates a specific database to load ' 'fixtures into. Defaults to the ""default"" database.' )"
"default set to DEFAULT_DB_ALIAS and help as a string 'Nominates a specific database to load fixtures into. Defaults to the ""default"" database.' call the method parser.add_argument with 5 arguments: string '--app', action as a string 'store', dest as a string 'app_label',","parser . add_argument ( '--app' , action = 'store' , dest = 'app_label' , default = None , help = 'Only look for fixtures in the specified app.' )"
"default set to None, help is a string 'Only look for fixtures in the specified app.'. call the method parser.add_argument with 6 arguments: string '--ignorenonexistent', string '-i', action as a string 'store_true',","parser . add_argument ( '--ignorenonexistent' , '-i' , action = 'store_true' , dest = 'ignore' , default = False , help = 'Ignores entries in the serialized data for fields that do not ' 'currently exist on the model.' )"
"dest as a string 'ignore', default set to boolean False and help set to string 'Ignores entries in the serialized data for fields that do not currently exist on the model.'. define the method handle with 3 arguments: self, unpacked list fixture_labels and unpacked dictionary options.","def handle ( self , * fixture_labels , ** options ) :"
"get the value under the 'ignore' key of the options dictionary, substitute it for self.ignore.",self . ignore = options . get ( 'ignore' )
"get the value under the 'database' key of the options dictionary, substitute it for self.database.",self . using = options . get ( 'database' )
"get the value under the 'app_label' key of the options dictionary, substitute it for self.app_label.",self . app_label = options . get ( 'app_label' )
"get the value under the 'hide_empty' key of the options dictionary, if the key exists substitute it for self.hide_empty,","self . hide_empty = options . get ( 'hide_empty' , False )"
"if not, self.hide_empty is boolean False. get the value under the 'verbosity' key of the options dictionary, substitute it for self.verbosity.",self . verbosity = options . get ( 'verbosity' )
"call the method transaction.atomic with an argument using set to self.using, with the result,",with transaction . atomic ( using = self . using ) :
call the method self.loaddata with an argument fixture_labels.,self . loaddata ( fixture_labels )
"call the method transaction.get_autocommit with an argument self.using, if it evaluates to true,",if transaction . get_autocommit ( self . using ) :
"get the value under the self.using key of the connections dictionary, call the method close on it.",connections [ self . using ] . close ( )
define the method loaddata with 2 arguments self and fixture_labels.,"def loaddata ( self , fixture_labels ) :"
"get the value under the self.using key of the connections dictionary, substitute it for connection.",connection = connections [ self . using ]
self.fixture_count is integer 0.,self . fixture_count = 0
self.loaded_object_count is integer 0.,self . loaded_object_count = 0
self.fixture_object_count is integer 0.,self . fixture_object_count = 0
self.models is an empty set.,self . models = set ( )
"call the method serializers.get_public_serializer_formats, substitute the result for self.serialization_formats.",self . serialization_formats = serializers . get_public_serializer_formats ( )
"self.compression_formats is an dictionary with 3 initial entries: tuple containing 2 elements: open and string 'rb' for None,","self . compression_formats = { None : ( open , 'rb' ) , 'gz' : ( gzip . GzipFile , 'rb' ) , 'zip' : ( SingleZipReader , 'r' ) , }"
"tuple with 2 arguments: gzip.GzipFile and string 'rb' for 'gz', tuple with 2 arguments: SingleZipReader and string 'r' for 'gzip'. if has_bz2 is true,",if has_bz2 :
substitute tuple with 2 elements: bz2.BZ2File and string 'r' for value under the 'bz2' key of the self.compression_formats dictionary.,"self . compression_formats [ 'bz2' ] = ( bz2 . BZ2File , 'r' )"
"call the method connection.constraint_checks_disabled, with the result perform,",with connection . constraint_checks_disabled ( ) :
"for every fixture_label in fixture_labels,",for fixture_label in fixture_labels :
call the method self.load_label with an argument fixture_label.,self . load_label ( fixture_label )
"for model in self.models append model._meta.db_table to a list, substitute the resulting list for table_names.",table_names = [ model . _meta . db_table for model in self . models ]
"try,",try :
call the method connection.check_constraints with an arguments table_names set to table_names.,connection . check_constraints ( table_names = table_names )
"if Exception, renamed to e, exception is caught,",except Exception as e :
"e.args is a tuple, containing 1 element: string ""Problem installing fixtures: %s"", where '%s' is replaced with e.","e . args = ( ""Problem installing fixtures: %s"" % e , )"
raise an exception.,raise
"if self.loaded_object_count is greater than zero,",if self . loaded_object_count > 0 :
"call the method connection.ops.sequence_reset_sql with 2 arguments: return value of the no_style and self.models,","sequence_sql = connection . ops . sequence_reset_sql ( no_style ( ) , self . models )"
"substitute the result for sequence_sql. if sequence_sql is true,",if sequence_sql :
"if self.verbosity is grater than, or equal to integer 2,",if self . verbosity >= 2 :
"write a string ""Resetting sequences\n"" to self.stdout stream.","self . stdout . write ( ""Resetting sequences\n"" )"
"call the method connection.cursor, with the result renamed to cursor, perform the following,",with connection . cursor ( ) as cursor :
"for every line in sequence_sql,",for line in sequence_sql :
call the method cursor.execute with an argument line.,cursor . execute ( line )
"if self.verbosity is greater of equal to integer 1,",if self . verbosity >= 1 :
"if self.fixture_count equals integer 0 and self.hide_empty is true,",if self . fixture_count == 0 and self . hide_empty :
do nothing.,pass
"otherwise if self.fixture_object_count equals self.loaded_object_count,",elif self . fixture_object_count == self . loaded_object_count :
"call the method self.stdout.write with an argument string ""Installed %d object(s) from %d fixture(s)"",","self . stdout . write ( ""Installed %d object(s) from %d fixture(s)"" % ( self . loaded_object_count , self . fixture_count ) )"
"where '%d' is replaced with self.loaded_object_count and self.fixture_count, respectively. if not,",else :
"call the method self.stdout.write with an argument string ""Installed %d object(s) (of %d) from %d fixture(s)"",","self . stdout . write ( ""Installed %d object(s) (of %d) from %d fixture(s)"" % ( self . loaded_object_count , self . fixture_object_count , self . fixture_count ) )"
"substitute '%d' with self.loaded_object_count, self.fixture_object_count and self.fixture_count. define the method load_label with self and fixture_label as arguments.","def load_label ( self , fixture_label ) :"
"for every fixture_file, fixture_dir and fixture_name in return value of the method self.find_fixtures called with an argument fixture_label,","for fixture_file , fixture_dir , fixture_name in self . find_fixtures ( fixture_label ) :"
"call the function os.path.basename with an argument fixture_file, use the result as an argument for the call to the method,","_ , ser_fmt , cmp_fmt = self . parse_name ( os . path . basename ( fixture_file ) )"
"self.parse_name, assign the result to _, ser_fmt and cmp_fmt, respectively. get the value under the cmp_fmt key of the self.compression_formats dictionary, assign it to open_method and mode.","open_method , mode = self . compression_formats [ cmp_fmt ]"
"call the function open_method with arguments: fixture_file and mode, substitute the result for fixture.","fixture = open_method ( fixture_file , mode )"
"try,",try :
increment self.fixture_count by one.,self . fixture_count += 1
objects_in_fixture is integer 0.,objects_in_fixture = 0
loaded_objects_in_fixture is integer 0.,loaded_objects_in_fixture = 0
"if self.verbosity is greater or equal to integer 2,",if self . verbosity >= 2 :
"call the method self.stdout.write with an argument string ""Installing %s fixture '%s' from %s."",","self . stdout . write ( ""Installing %s fixture '%s' from %s."" % ( ser_fmt , fixture_name , humanize ( fixture_dir ) ) )"
"substitute '%s' with ser_fmt, fixture_name and return value of the function humanize called with an argument fixture_dir. call the method serializers.deserialize with 4 arguments: ser_fmt, fixture, using set to self.using,","objects = serializers . deserialize ( ser_fmt , fixture , using = self . using , ignorenonexistent = self . ignore )"
"and ignorenonexistent set to self.ignore, substitute the result for objects. for every obj in objects,",for obj in objects :
increment objects_in_fixture by one.,objects_in_fixture += 1
"call the method router.allow_migrate with 2 arguments: self.using and obj.object.__class__, if it evaluates to true,","if router . allow_migrate ( self . using , obj . object . __class__ ) :"
increment loaded_objects_in_fixture by one.,loaded_objects_in_fixture += 1
add obj.object.__class__ to self.models set.,self . models . add ( obj . object . __class__ )
"try,",try :
call the method obj.save with an argument using set to self.using.,obj . save ( using = self . using )
"if DatabaseError or IntegrityError, renamed to e, exceptions are caught,","except ( DatabaseError , IntegrityError ) as e :"
"e.args is a tuple containing string ""Could not load %(app_label)s.%(object_name)s(pk=%(pk)s): %(error_msg)s,","e . args = ( ""Could not load %(app_label)s.%(object_name)s(pk=%(pk)s): %(error_msg)s"" % { 'app_label' : obj . object . _meta . app_label , 'object_name' : obj . object . _meta . object_name , 'pk' : obj . object . pk , 'error_msg' : force_text ( e ) } , )"
"where '%(app_label)s' is replaced for obj.object._meta.app_label, '%(object_name)s' is replaced with obj.object._meta.object_name, '%(pk)s' is replaced with obj.object.pk and '%(error_msg)s' is replaced with result of the function force_text with an argument e. raise an exceptions",raise
increment self.loaded_object_count by loaded_objects_in_fixture.,self . loaded_object_count += loaded_objects_in_fixture
increment self.fixture_object_count by objects_in_fixture.,self . fixture_object_count += objects_in_fixture
"if Exception, renamed to e, exception is caught,",except Exception as e :
"if e is not an instance of CommandError class,","if not isinstance ( e , CommandError ) :"
"e.args is a tuple containing string ""Problem installing fixture '%s': %s"", where '%s' is replaced with fixture_file, e.","e . args = ( ""Problem installing fixture '%s': %s"" % ( fixture_file , e ) , )"
raise an exception.,raise
"finally perform,",finally :
call the method fixture.close.,fixture . close ( )
"if objects_in_fixture equals integer 0,",if objects_in_fixture == 0 :
"call the method warnings.warn with 2 arguments: string ""No fixture data found for '%s'. (File format may be invalid.)"",","warnings . warn ( ""No fixture data found for '%s'. (File format may be "" ""invalid.)"" % fixture_name , RuntimeWarning )"
"where '%s' is replaced with fixture_name, and RuntimeWarning. decorator method lru_cache.lru_cache with an argument maxsize set to None.",@ lru_cache . lru_cache ( maxsize = None )
define the method find_fixtures with arguments: self and fixture_label.,"def find_fixtures ( self , fixture_label ) :"
"call the method self.parse_name with an argument fixture_label, substitute the result for fixture_name, ser_fmt, cmp_fmt, respective.","fixture_name , ser_fmt , cmp_fmt = self . parse_name ( fixture_label )"
databases is a list containing 2 elements: self.using and None.,"databases = [ self . using , None ]"
"call the method self.compression_formats.keys, convert it to list, substitute it for cmp_fmts if cmp_fmt is None,",cmp_fmts = list ( self . compression_formats . keys ( ) ) if cmp_fmt is None else [ cmp_fmt ]
"otherwise cmp_fmts is a list containing cmp_fmt. call the method serializers.get_public_serializer_formats, substitute the result for ser_fmts if ser_fmt is None,",ser_fmts = serializers . get_public_serializer_formats ( ) if ser_fmt is None else [ ser_fmt ]
"otherwise ser_fmts is a list containing ser_fmt. if self.verbosity is greater or equal to integer 2,",if self . verbosity >= 2 :
"call the method self.stdout.write with an argument string ""Loading '%s' fixtures..."", where '%s' is replaced with fixture_name.","self . stdout . write ( ""Loading '%s' fixtures..."" % fixture_name )"
"if fixture_name is an absolute file path,",if os . path . isabs ( fixture_name ) :
"call the method os.path.dirname with an argument fixture_name, append it to a list, substitute resulting list for fixture_dirs.",fixture_dirs = [ os . path . dirname ( fixture_name ) ]
"call the method os.path.basename with an argument fixture_name, substitute the result for fixture_name.",fixture_name = os . path . basename ( fixture_name )
"if not,",else :
substitute self.fixture_dirs for fixture_dirs.,fixture_dirs = self . fixture_dirs
"if os.path.sep is contained in fixture_name,",if os . path . sep in fixture_name :
"join dir_ and return value of the function os.path.dirname called with an argument fixture_name into a valid file path,","fixture_dirs = [ os . path . join ( dir_ , os . path . dirname ( fixture_name ) ) for dir_ in fixture_dirs ]"
"append it to a list, perform the previous for every dir_ in fixture_dirs, substitute the resulting list for fixture_dirs. call the method os.path.basename with an argument fixture_name, substitute the result for fixture_name.",fixture_name = os . path . basename ( fixture_name )
"for every ext in combo, if ext is true, join it to a string, separated by '.', put the result in a tuple,","suffixes = ( '.' . join ( ext for ext in combo if ext ) for combo in product ( databases , ser_fmts , cmp_fmts ) )"
"perform the previous for every combo in result of the function product called with 3 arguments: databases, ser_fmts and cmp_fmts, substitute the result for suffixes. join fixture_name and suffix into a string, separated by '.' for every suffix in suffixes, put the results in set, substitute it for targets.","targets = set ( '.' . join ( ( fixture_name , suffix ) ) for suffix in suffixes )"
fixture_files is an empty list.,fixture_files = [ ]
"for every fixture_dir in fixture_dirs,",for fixture_dir in fixture_dirs :
if self.verbosity is greater or equals to integer 2.,if self . verbosity >= 2 :
"call the method self.stdout.write with an argument string ""Checking %s for fixtures..."",","self . stdout . write ( ""Checking %s for fixtures..."" % humanize ( fixture_dir ) )"
"where '%s' is replaced with result of the function humanize, called with an argument fixture_dir. fixture_files_in_dir is an empty list.",fixture_files_in_dir = [ ]
"join fixture_dir, fixture_name with appended character '*' into a valid file path,","for candidate in glob . iglob ( os . path . join ( fixture_dir , fixture_name + '*' ) ) :"
"use it as an argument for the call to the glob.iglob, for every candidate in result, call the method os.path.basename with an argument candidate, is result is contained in targets,",if os . path . basename ( candidate ) in targets :
"append tuple containing 3 elements: candidate, fixture_dir and fixture_name to list fixture_files_in_dir.","fixture_files_in_dir . append ( ( candidate , fixture_dir , fixture_name ) )"
"if self.verbosity is greater or equals integer 2 and fixture_files_in_dir is false,",if self . verbosity >= 2 and not fixture_files_in_dir :
"call the method self.stdout.write with an argument string ""No fixture '%s' in %s."", where '%s' is replaced with fixture_name,","self . stdout . write ( ""No fixture '%s' in %s."" % ( fixture_name , humanize ( fixture_dir ) ) )"
"and result of the function humanize called with an argument fixture_dir. if length of fixture_files_in_dir is greater than 1,",if len ( fixture_files_in_dir ) > 1 :
"raise an CommandError exception with an argument string ""Multiple fixtures named '%s' in %s. Aborting."", where '%s' is replaced with:","raise CommandError ( ""Multiple fixtures named '%s' in %s. Aborting."" % ( fixture_name , humanize ( fixture_dir ) ) )"
fixture_name and result of the function humanize called with an argument fixture_dir. extend fixture_files list with fixture_files_in_dir.,fixture_files . extend ( fixture_files_in_dir )
"if fixture_name is not equal to string 'initial_data' and fixture_files is false,",if fixture_name != 'initial_data' and not fixture_files :
"call the method warnings.warn with an argument string ""No fixture named '%s' found."" where '%s' is replaced with fixture_name.","warnings . warn ( ""No fixture named '%s' found."" % fixture_name )"
return fixture_files.,return fixture_files
"decorator cached_property,",@ cached_property
define the method fixture_dirs with an argument self.,def fixture_dirs ( self ) :
dirs is an empty dictionary.,dirs = [ ]
"for ever app_config in return value of the method apps.get_app_configs,",for app_config in apps . get_app_configs ( ) :
"if self.app_label is true and app_config.label is not equal to self.app_label,",if self . app_label and app_config . label != self . app_label :
skip this loop iteration.,continue
"join app_config.path and string 'fixtures' into a valid file path, substitute it for app_dir.","app_dir = os . path . join ( app_config . path , 'fixtures' )"
"if app_dir is a directory,",if os . path . isdir ( app_dir ) :
append app_dir to dirs list.,dirs . append ( app_dir )
"convert settings.FIXTURE_DIRS to a list, extend dirs by it.",dirs . extend ( list ( settings . FIXTURE_DIRS ) )
append an empty string to dirs list.,dirs . append ( '' )
"call the function os.path.realpath with an argument d, use the result as an argument for the call to the function os.path.abspath,",dirs = [ upath ( os . path . abspath ( os . path . realpath ( d ) ) ) for d in dirs ]
"use the result as an argument for the call to the upath function, for every d in dirs, append the results into a list, substitute the resulting list for dirs. return dirs.",return dirs
define the method parse_name with arguments self and fixture_name.,"def parse_name ( self , fixture_name ) :"
"call the method fixture_name.rsplit with 2 arguments: character '.' and integer 2, substitute the result for parts.","parts = fixture_name . rsplit ( '.' , 2 )"
"if length of parts is greater than integer 1 and last element of parts is contained in self.compression_formats,",if len ( parts ) > 1 and parts [ - 1 ] in self . compression_formats :
substitute the last element of parts for cmp_fmt.,cmp_fmt = parts [ - 1 ]
substitute the last element of parts for parts.,parts = parts [ : - 1 ]
"if not,",else :
cmp_fmt is None.,cmp_fmt = None
if length of parts is greater than integer 1.,if len ( parts ) > 1 :
"if last element of parts is contained in self.serialization_formats,",if parts [ - 1 ] in self . serialization_formats :
substitute the last element of parts for ser_fmt.,ser_fmt = parts [ - 1 ]
substitute the last element of parts for parts.,parts = parts [ : - 1 ]
"if not,",else :
"raise an CommandError with an argument string ""Problem installing fixture '%s': %s is not a known serialization format."",","raise CommandError ( ""Problem installing fixture '%s': %s is not a known "" ""serialization format."" % ( '' . join ( parts [ : - 1 ] ) , parts [ - 1 ] ) )"
"replace '%s' with: elements of last element of parts joined into a string and last element of parts. if not,",else :
ser_fmt is None.,ser_fmt = None
"join elements of parts into a string, separated with '.', substitute it for name.",name = '.' . join ( parts )
"return name, ser_fmt and cmp_fmt.","return name , ser_fmt , cmp_fmt"
derive class SingleZipReader for zipfile.ZipFile base class.,class SingleZipReader ( zipfile . ZipFile ) :
"define the method __init__ with 3 arguments: self, unpacked list args and unpacked dictionary kwargs.","def __init__ ( self , * args , ** kwargs ) :"
"call the method zipfile.ZipFile.__init___ with the arguments self, unpacked list args and unpacked dictionary kwargs.","zipfile . ZipFile . __init__ ( self , * args , ** kwargs )"
"call the method self.namelist, if the length of the result is not integer 1,",if len ( self . namelist ( ) ) != 1 :
"raise an ValueError with an string ""Zip-compressed fixtures must contain one file."".","raise ValueError ( ""Zip-compressed fixtures must contain one file."" )"
define the method read with an argument self.,def read ( self ) :
call the method zipfile.ZipFile.read with 2 arguments: self and first element of the result of the self.namelist method.,"return zipfile . ZipFile . read ( self , self . namelist ( ) [ 0 ] )"
define the function humanize with an argument dirname.,def humanize ( dirname ) :
"if dirname is true, return dirname converted to a string and surounded by single quotes, if not return string 'absolute path'.","return ""'%s'"" % dirname if dirname else 'absolute path'"
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
import module fnmatch.,import fnmatch
import module glob.,import glob
import module io.,import io
import module os.,import os
import module re.,import re
import module sys.,import sys
from itertools import dropwhile into default name space.,from itertools import dropwhile
import module django.,import django
from django.core.management.base import CommandError and BaseCommand into default name space.,"from django . core . management . base import CommandError , BaseCommand"
"from django.core.management.utils import handle_extensions, find_command and popen_wrapper into default name space.","from django . core . management . utils import ( handle_extensions , find_command , popen_wrapper )"
from django.utils.encoding import force_st into default name space.,from django . utils . encoding import force_str
from django.utils.functional import total_ordering into default name space.,from django . utils . functional import total_ordering
from django.utils import six into default name space.,from django . utils import six
from django.utils.text import get_text_list into default name space.,from django . utils . text import get_text_list
from django.utils.jslex import prepare_js_for_gettext into default name space.,from django . utils . jslex import prepare_js_for_gettext
"call the method re.compile with 2 arguments: raw string '^(?P<value>""Plural-Forms.+?\\n"")\s*$',","plural_forms_re = re . compile ( r'^(?P<value>""Plural-Forms.+?\\n"")\s*$' , re . MULTILINE | re . DOTALL )"
"and result of the bitwise OR performed on the re.MULTILINE and re.DOTALL operands, substitute the result for plural_forms_re/ STATUS_OK is integer 0.",STATUS_OK = 0
define the method check_programs with an argument unpacked list programs.,def check_programs ( * programs ) :
"for every program in programs,",for program in programs :
"call the function find_command with an argument program, if it evaluates to None,",if find_command ( program ) is None :
"raise an CommandError exception with an argument ""Can't find %s. Make sure you have GNU gettext tools 0.15 or newer installed."", where '%s' is replaced with program.","raise CommandError ( ""Can't find %s. Make sure you have GNU "" ""gettext tools 0.15 or newer installed."" % program )"
"total_ordering decorator,",@ total_ordering
derive the class TranslatableFile from the object class.,class TranslatableFile ( object ) :
"define the method __init__ with 4 arguments: self, dirpath, file_name and locale_dir.","def __init__ ( self , dirpath , file_name , locale_dir ) :"
substitute file_name for self.file_name.,self . file = file_name
substitute dirpath for self.dirpath.,self . dirpath = dirpath
substitute locale_dir for self.locale_dir.,self . locale_dir = locale_dir
define the method __repr__with an argument self.,def __repr__ ( self ) :
"join self.dirpath and self.file in a string, substitute with it '%s' in string ""<TranslatableFile: %s>"", return the result.","return ""<TranslatableFile: %s>"" % os . sep . join ( [ self . dirpath , self . file ] )"
define the method __eq__ with self and other arguments:,"def __eq__ ( self , other ) :"
"if self.path equals other.path, return boolean True, if not return boolean False.",return self . path == other . path
define the mehod __lt__ with self and other.,"def __lt__ ( self , other ) :"
"if self.path is lesser than other.path, return boolean True, otherwise return boolean False.",return self . path < other . path
property decorator.,@ property
define the method path with an argument self.,def path ( self ) :
"join self.dirpath and self.file into a file path, return it.","return os . path . join ( self . dirpath , self . file )"
"define the method process with 3 arguments: self, command and domain.","def process ( self , command , domain ) :"
from django.conf import settings into default namespace.,from django . conf import settings
from django.utils.translation import templatize into default namespace.,from django . utils . translation import templatize
"if command.verbosity is greater than integer 1,",if command . verbosity > 1 :
"substitute '%s' is string 'processing file %s in %s\n' with self.file and self.dirpath, write it to command.stdout.","command . stdout . write ( 'processing file %s in %s\n' % ( self . file , self . dirpath ) )"
"call the method os.path.splitext with an argument self.file, assign the result to _ and file_ext.","_ , file_ext = os . path . splitext ( self . file )"
"if domain equals a string 'djangojs' and file_ext is contained in command.extensions,",if domain == 'djangojs' and file_ext in command . extensions :
is_templatized is boolean True.,is_templatized = True
"join self.dirpath and self.file into a file path, substitute it for orig_file.","orig_file = os . path . join ( self . dirpath , self . file )"
"call the function io.open with orig_file and encoding set to settings.FILE_CHARSET, with the result renamed to fp,","with io . open ( orig_file , encoding = settings . FILE_CHARSET ) as fp :"
"perform the following: call the method fp.read, substitute the result for src_data.",src_data = fp . read ( )
"call the function prepare_js_for_gettext with an argument src_data, substitute it for src_data.",src_data = prepare_js_for_gettext ( src_data )
"convert self.file to a string and append '.c' string to it, substitute the result for thefile.",thefile = '%s.c' % self . file
"join self.dirpath and thefile in a string, substitute the result for work_file.","work_file = os . path . join ( self . dirpath , thefile )"
"call the function io.open with 3 arguments: work_file, string 'w' and encoding set to string 'utf-8' as arguments,","with io . open ( work_file , ""w"" , encoding = 'utf-8' ) as fp :"
"with the result renamed to fp, perform the following: call the method fp.write with an arguments src_data.",fp . write ( src_data )
"append command.xgettext_options to the list containing 10 elements: string 'xgettext', string '-d', domain, string '--language=C',","args = [ 'xgettext' , '-d' , domain , '--language=C' , '--keyword=gettext_noop' , '--keyword=gettext_lazy' , '--keyword=ngettext_lazy:1,2' , '--keyword=pgettext:1c,2' , '--keyword=npgettext:1c,2,3' , '--output=-' ] + command . xgettext_options"
"string '--keyword=gettext_noop', string '--keyword=gettext_lazy', string '--keyword=ngettext_lazy:1,2', string '--keyword=pgettext:1c,2', string '--keyword=npgettext:1c,2,3' and string '--output=-', substitute it for args. append work_file to args.",args . append ( work_file )
"otherwise if domains equals a string django' and, file_ext equals '.py' or file_ext is contained in command.extensions,",elif domain == 'django' and ( file_ext == '.py' or file_ext in command . extensions ) :
substitute self.file for thefile.,thefile = self . file
"join self.dirpath and self.file into a file path, substitute it for orig_file.","orig_file = os . path . join ( self . dirpath , self . file )"
"if file_ext is contained in command.extensions, is_templatized is boolean True, otherwise it is boolean False.",is_templatized = file_ext in command . extensions
"if is_templatized is true,",if is_templatized :
"call the function io.open with 3 arguments: work_file, string 'w' and encoding set to settings.FILE_CHARSET as arguments,","with io . open ( orig_file , 'r' , encoding = settings . FILE_CHARSET ) as fp :"
"with the result renamed to fp, perform the following: call the method fp.read, substitute the result for src_data.",src_data = fp . read ( )
"convert self.file to string and append string '.py' to it, substitute the result for thefile.",thefile = '%s.py' % self . file
"call the function templatize with 2 arguments: src_data and sliced orig_file, without first 2 elements, substitute the result for content.","content = templatize ( src_data , orig_file [ 2 : ] )"
"call the function io.open with 3 arguments: self.dirpath and thefile joined into a file path, string 'w',","with io . open ( os . path . join ( self . dirpath , thefile ) , ""w"" , encoding = 'utf-8' ) as fp :"
"and encoding set to string 'utf-8' as arguments, with the result renamed to fp, perform the following: call the method fp.write with an argument content.",fp . write ( content )
"join self.dirpath, thefile into a file path, substitute it for work_file.","work_file = os . path . join ( self . dirpath , thefile )"
"append command.xgettext_options to list containing 15 elements: string 'xgettext', string '-d', domain, string '--language=Python',","args = [ 'xgettext' , '-d' , domain , '--language=Python' , '--keyword=gettext_noop' , '--keyword=gettext_lazy' , '--keyword=ngettext_lazy:1,2' , '--keyword=ugettext_noop' , '--keyword=ugettext_lazy' , '--keyword=ungettext_lazy:1,2' , '--keyword=pgettext:1c,2' , '--keyword=npgettext:1c,2,3' , '--keyword=pgettext_lazy:1c,2' , '--keyword=npgettext_lazy:1c,2,3' , '--output=-' ] + command . xgettext_options"
"string '--keyword=gettext_noop', string '--keyword=gettext_lazy', string '--keyword=ngettext_lazy:1,2', string '--keyword=ugettext_noop', string '--keyword=ugettext_lazy', string '--keyword=ungettext_lazy:1,2', string '--keyword=pgettext:1c,2', string '--keyword=npgettext:1c,2,3', string '--keyword=pgettext_lazy:1c,2', string '--keyword=npgettext_lazy:1c,2,3' and string '--output=-', substitute the result for args. append work_file to args.",args . append ( work_file )
"if not,",else :
return nothing.,return
"call the function popen_wrapper with argument args, assign the result to msgs, errors and status.","msgs , errors , status = popen_wrapper ( args )"
"if errors is true,",if errors :
"if status is not equal to STATUS_OK,",if status != STATUS_OK :
"if is_templatized is true,",if is_templatized :
call the function os.unlink with an argument work_file.,os . unlink ( work_file )
"raise an CommandError exception with an argument string ""errors happened while running xgettext on %s\n%s"",","raise CommandError ( ""errors happened while running xgettext on %s\n%s"" % ( self . file , errors ) )"
"where '%s' are replaced by sel.file and errors, respectively. if command.verbosity is greater than integer 0,",elif command . verbosity > 0 :
call the method command.stdout.write with an argument errors.,command . stdout . write ( errors )
"if msgs is true,",if msgs :
"if six.PY2 is true,",if six . PY2 :
"call the method msgs.decode with an argument string 'utf-8', substitute the result for msgs.",msgs = msgs . decode ( 'utf-8' )
"join into a file path: self.locale_dir and string '.pot' appended to domain converted to string, substitute it for potfile.","potfile = os . path . join ( self . locale_dir , '%s.pot' % str ( domain ) )"
"if is_templatized is true,",if is_templatized :
"if os.name equals string 'nt',",if os . name == 'nt' :
"append work_file to string '#: ', substitute it for old.",old = '#: ' + work_file
"append orig_file to string '#: ', substitute it for new.",new = '#: ' + orig_file
"if not,",else :
"append work_file to string '#: ', substitute it for old.",old = '#: ' + work_file [ 2 : ]
"append orig_file to string '#: ', substitute it for new.",new = '#: ' + orig_file [ 2 : ]
"replace every occurrence of old for new in msgs, substitute the result for msgs.","msgs = msgs . replace ( old , new )"
call the function write_pot_file with 2 arguments: potfile and msgs.,"write_pot_file ( potfile , msgs )"
"if is_templatized is true,",if is_templatized :
call the function os.unlink with an argument work_file.,os . unlink ( work_file )
define the function write_pot_file with 2 arguments potfile and msgs.,"def write_pot_file ( potfile , msgs ) :"
"if potfile fie exists,",if os . path . exists ( potfile ) :
"call the function dropwhile with 2 arguments: function len and msgs spit into parts at newlines, join the result into a string,","msgs = '\n' . join ( dropwhile ( len , msgs . split ( '\n' ) ) )"
"separated by newline, substitute it for msgs. if not,",else :
"replace every occurrence of string 'charset=CHARSET' for string 'charset=UTF-8' in msgs, substitute the result for msgs.","msgs = msgs . replace ( 'charset=CHARSET' , 'charset=UTF-8' )"
"call the function io.open with 3 arguments: potfile, string 'a' and encoding set to string 'utf-8' as arguments,","with io . open ( potfile , 'a' , encoding = 'utf-8' ) as fp :"
"with the result renamed to fp, perform the following: call the method fp.write with an argument msgs.",fp . write ( msgs )
derive the class Command from the BaseCommands base class.,class Command ( BaseCommand ) :
"help is a string ""Runs over the entire source tree of the current directory and ""","help = ( ""Runs over the entire source tree of the current directory and "" ""pulls out all strings marked for translation. It creates (or updates) a message "" ""file in the conf/locale (in the django tree) or locale (for projects and "" ""applications) directory.\n\nYou must run this command with one of either the "" ""--locale, --exclude or --all options."" )"
"""pulls out all strings marked for translation. It creates (or updates) a message "" ""file in the conf/locale (in the django tree) or locale (for projects and "" ""applications) directory.\n\nYou must run this command with one of either the "" ""--locale, --exclude or --all options."". requires_system_checks is boolean False.",requires_system_checks = False
leave_locale_alone is boolean True,leave_locale_alone = True
msgmerge_options is an list with elements: strings '-q' and '--previous'.,"msgmerge_options = [ '-q' , '--previous' ]"
msguniq_options is an list with elements: string '--to-code=utf-8'.,msguniq_options = [ '--to-code=utf-8' ]
msgattrib_options is an list with elements: string '--no-obsolete'.,msgattrib_options = [ '--no-obsolete' ]
xgettext_options is an list with elements: strings '--from-code=UTF-8' and '--add-comments=Translators'.,"xgettext_options = [ '--from-code=UTF-8' , '--add-comments=Translators' ]"
define the method add_arguments with 2 arguments: self and parser.,"def add_arguments ( self , parser ) :"
"call the method parser.add_argument with 6 arguments: string '--locale', string '-l', default as an empty list,","parser . add_argument ( '--locale' , '-l' , default = [ ] , dest = 'locale' , action = 'append' , help = 'Creates or updates the message files for the given locale(s) (e.g. pt_BR). ' 'Can be used multiple times.' )"
"dest as a string 'locale', action as a string 'append' and help as a string, 'Creates or updates the message files for the given locale(s) (e.g. pt_BR). Can be used multiple times.'. call the method parser.add_argument with 5 arguments: string '--exclude', string '-x', default as a empty list,","parser . add_argument ( '--exclude' , '-x' , default = [ ] , dest = 'exclude' , action = 'append' , help = 'Locales to exclude. Default is none. Can be used multiple times.' )"
"dest as a string 'exclude', action as a string 'append' and help as a string 'Locales to exclude. Default is none. Can be used multiple times.'. call the method parser.add_argument with 5 arguments: string '--domain', string '-d', default as a string 'django',","parser . add_argument ( '--domain' , '-d' , default = 'django' , dest = 'domain' , help = 'The domain of the message files (default: ""django"").' )"
"dest set to string 'domain' and help as a string 'The domain of the message files (default: ""django"").'. call the method parser.add_argument with 6 arguments: string '--all', string '-a', action as a string'store_true',","parser . add_argument ( '--all' , '-a' , action = 'store_true' , dest = 'all' , default = False , help = 'Updates the message files for all existing locales.' )"
"dest as a string 'all' default as boolean False and help as a string 'Updates the message files for all existing locales.'. call the method parser.add_argument with 5 arguments: string '--extension', string '-e', dest set to string 'extensions',","parser . add_argument ( '--extension' , '-e' , dest = 'extensions' , help = 'The file extension(s) to examine (default: ""html,txt"", or ""js"" ' 'if the domain is ""djangojs""). Separate multiple extensions with ' 'commas, or use -e multiple times.' , action = 'append' )"
"help set to a string 'The file extension(s) to examine (default: ""html,txt"", or ""js"" ' 'if the domain is ""djangojs""). Separate multiple extensions with commas, or use -e multiple times.' and action as a string 'append'. call the method parser.add_argument with 6 arguments: string '--symlinks', string '-s', action as a string 'store_true',","parser . add_argument ( '--symlinks' , '-s' , action = 'store_true' , dest = 'symlinks' , default = False , help = 'Follows symlinks to directories when examining ' 'source code and templates for translation strings.' )"
"dest as a string 'symlinks', default as boolean False and help as a string 'Follows symlinks to directories when examining ' 'source code and templates for translation strings.'. call the method parser.add_argument with 7 arguments: string '--ignore', string '-i', action as a string 'append',","parser . add_argument ( '--ignore' , '-i' , action = 'append' , dest = 'ignore_patterns' , default = [ ] , metavar = 'PATTERN' , help = 'Ignore files or directories matching this glob-style pattern. ' 'Use multiple times to ignore more.' )"
"dest as a string 'ignore_patterns', default as an empty list, metavar as a string 'PATTERN', and help as a string 'Ignore files or directories matching this glob-style pattern. Use multiple times to ignore more.'. call the method parser.add_argument with 5 arguments: string '--no-default-ignore', action as a string 'store_false',","parser . add_argument ( '--no-default-ignore' , action = 'store_false' , dest = 'use_default_ignore_patterns' , default = True , help = ""Don't ignore the common glob-style patterns 'CVS', '.*', '*~' and '*.pyc'."" )"
"dest as a string 'use_default_ignore_patterns', default set to boolean True, and help as a string ""Don't ignore the common glob-style patterns 'CVS', '.*', '*~' and '*.pyc'."". call the method parser.add_argument with 5 arguments: string '--no-wrap', action as a string 'store_true', dest as a string 'no_wrap',","parser . add_argument ( '--no-wrap' , action = 'store_true' , dest = 'no_wrap' , default = False , help = ""Don't break long message lines into several lines."" )"
"default as boolean False and help as a string ""Don't break long message lines into several lines."". call the method parser.add_argument with 5 arguments: string '--no-location', action set to string 'store_true',","parser . add_argument ( '--no-location' , action = 'store_true' , dest = 'no_location' , default = False , help = ""Don't write '#: filename:line' lines."" )"
"dest set to string 'no_location', default as boolean False and help as a string ""Don't write '#: filename:line' lines."". call the method parser.add_argument with 5 arguments: string '--no-obsolete', action as a string 'store_true',","parser . add_argument ( '--no-obsolete' , action = 'store_true' , dest = 'no_obsolete' , default = False , help = ""Remove obsolete message strings."" )"
"dest as a string 'no_obsolete', default as boolean False and help as a string ""Remove obsolete message strings."". call the method parser.add_argument with 5 arguments: string '--keep-pot', action as a string 'store_true',","parser . add_argument ( '--keep-pot' , action = 'store_true' , dest = 'keep_pot' , default = False , help = ""Keep .pot file after making messages. Useful when debugging."" )"
"dest as a string 'keep_pot', default as boolean False and help as a string ""Keep .pot file after making messages. Useful when debugging."" define the method handle with 3 arguments: self, unpacked list args and unpacked dictionary options.","def handle ( self , * args , ** options ) :"
"get the value under the 'locale' key of the options dictionary, substitute it for locale.",locale = options . get ( 'locale' )
"get the value under the 'exclude' key of the options dictionary, substitute it for exclude.",exclude = options . get ( 'exclude' )
"get the value under the 'domain' key of the options dictionary, substitute it for self.domain.",self . domain = options . get ( 'domain' )
"get the value under the 'verbosity' key of the options dictionary, substitute it for self.verbosity.",self . verbosity = options . get ( 'verbosity' )
"get the value under the 'all' key of the options dictionary, substitute it for process_all.",process_all = options . get ( 'all' )
"get the value under the 'extensions' key of the options dictionary, substitute it for extensions.",extensions = options . get ( 'extensions' )
"get the value under the 'symlinks' key of the options dictionary, substitute it for self.symlinks.",self . symlinks = options . get ( 'symlinks' )
"get the value under the 'ignore_patterns' key of the options dictionary, substitute it for ignore_patterns.",ignore_patterns = options . get ( 'ignore_patterns' )
"get the value under the 'use_default_ignore_patterns' key of the options dictionary, if it is true,",if options . get ( 'use_default_ignore_patterns' ) :
"append list containing 4 elements: 'CVS', '.*', '*~' and '*.pyc', to ignore_patterns.","ignore_patterns += [ 'CVS' , '.*' , '*~' , '*.pyc' ]"
"put elements of ignore_patterns into a set, substitute the length of it for self.ignore_patterns.",self . ignore_patterns = list ( set ( ignore_patterns ) )
"get the value under the 'no_wrap' key of the options dictionary, if it is true,",if options . get ( 'no_wrap' ) :
append list containing string '--no-wrap' to self.msgmerge_options,self . msgmerge_options = self . msgmerge_options [ : ] + [ '--no-wrap' ]
append list containing string '--no-wrap' to self.msguniq_options.,self . msguniq_options = self . msguniq_options [ : ] + [ '--no-wrap' ]
append list containing string '--no-wrap' to self.msgattrib_options.,self . msgattrib_options = self . msgattrib_options [ : ] + [ '--no-wrap' ]
append list containing string '--no-wrap' to self.xgettext_options.,self . xgettext_options = self . xgettext_options [ : ] + [ '--no-wrap' ]
"get the value under the 'no_location' key of the options dictionary, if it is true,",if options . get ( 'no_location' ) :
append list containing string '--no-location' to self.msgmerge_options.,self . msgmerge_options = self . msgmerge_options [ : ] + [ '--no-location' ]
append list containing string '--no-location' to self.msguniq_options.,self . msguniq_options = self . msguniq_options [ : ] + [ '--no-location' ]
append list containing string '--no-location' to self.msgattrib_options.,self . msgattrib_options = self . msgattrib_options [ : ] + [ '--no-location' ]
append list containing string '--no-location' to self.xgettext_options.,self . xgettext_options = self . xgettext_options [ : ] + [ '--no-location' ]
"get the value under the 'no_obsolete' key of the options dictionary, substitute it for self.no_obsolete.",self . no_obsolete = options . get ( 'no_obsolete' )
"get the value under the 'keep_pot' key of the options dictionary, substitute it for self.keep_pot.",self . keep_pot = options . get ( 'keep_pot' )
"if self.domain is not equal to string 'django' or string 'djangojs',","if self . domain not in ( 'django' , 'djangojs' ) :"
"raise an CommandError exception with an argument string ""currently makemessages only supports domains 'django' and 'djangojs'"".","raise CommandError ( ""currently makemessages only supports domains "" ""'django' and 'djangojs'"" )"
"if self.domain equals to string 'djangojs',",if self . domain == 'djangojs' :
"if extensions is false, substitute it for exts, otherwise exts is a list containing string 'js'.",exts = extensions if extensions else [ 'js' ]
"if not,",else :
"if extensions is false, substitute it for exts, otherwise exts is a list containing 2 elements: string 'html' and string 'txt'.","exts = extensions if extensions else [ 'html' , 'txt' ]"
"call the function handle_extensions exts, substitute self.extensions.",self . extensions = handle_extensions ( exts )
"evaluate the boolean expression: locale is None and exclude is false and process_all is false,",if ( locale is None and not exclude and not process_all ) or self . domain is None :
"if the result is true or self.domain is not None, raise an CommandError exception with an argument string ""Type '%s help %s' for usage information."", where '%s' are replaced by:","raise CommandError ( ""Type '%s help %s' for usage information."" % ( os . path . basename ( sys . argv [ 0 ] ) , sys . argv [ 1 ] ) )"
"return value of the function os.path.basename called with first element of sys.argv as an argument, and second element of sys.argv. from django.conf import settings into default namespace.",from django . conf import settings
"if settings.configured,",if settings . configured :
settings.USE_I18N is boolean True.,settings . USE_I18N = True
"if not,",else :
call the method settings.configure with an argument USE_I18N set to boolean True.,settings . configure ( USE_I18N = True )
"if self.verbosity is integer 1,",if self . verbosity > 1 :
"call the method self.stdout.write with an argument string 'examining files with the extensions: %s\n',","self . stdout . write ( 'examining files with the extensions: %s\n' % get_text_list ( list ( self . extensions ) , 'and' ) )"
substitute '%s' with return value of the function get_text_list called with 2 arguments:self.extensions converted into a list and string 'and'. self.invoked_for_django is boolean False.,self . invoked_for_django = False
self.locale_paths is an empty list.,self . locale_paths = [ ]
self.default_locale_path is None.,self . default_locale_path = None
"join 'conf' and 'locale' into a file path, if it is a directory,","if os . path . isdir ( os . path . join ( 'conf' , 'locale' ) ) :"
"join 'conf' and 'locale' into a file path, use it as an argument for the call the method os.path.abspath,","self . locale_paths = [ os . path . abspath ( os . path . join ( 'conf' , 'locale' ) ) ]"
"put the results into a list, substitute self.locale_paths for it. substitute first element of self.locale_paths for self.default_locale_path.",self . default_locale_path = self . locale_paths [ 0 ]
self.invoked_for_django is boolean True.,self . invoked_for_django = True
"if not,",else :
convert settings.LOCALE_PATHS into a list and extend list self.locale_paths with it.,self . locale_paths . extend ( list ( settings . LOCALE_PATHS ) )
"if 'locale' is a directory,",if os . path . isdir ( 'locale' ) :
"call the function os.path.abspath with an argument 'locale', append the result to self.locale_paths.",self . locale_paths . append ( os . path . abspath ( 'locale' ) )
"if self.locale_paths is true,",if self . locale_paths :
substitute first element of self.locale_paths for self.default_locale_path.,self . default_locale_path = self . locale_paths [ 0 ]
"if self.default_locale_path directory doesnt exists,",if not os . path . exists ( self . default_locale_path ) :
create a directory self.default_locale_path.,os . makedirs ( self . default_locale_path )
"call the function glob.glob with an argument: string '/*' appended to self.default_locale_path converted into a string,","locale_dirs = filter ( os . path . isdir , glob . glob ( '%s/*' % self . default_locale_path ) )"
"filter out the results for which function os.path.isdir returns false, substitute the result for locale_dirs. map the locale_dirs elements with mapping function os.path.basename, substitute the result for all_locales.","all_locales = map ( os . path . basename , locale_dirs )"
"if process_all is true,",if process_all :
substitute all_locales for locales.,locales = all_locales
"if not,",else :
"if locale is not false or None, substitute it for locales, otherwise substitute all_locales for locales.",locales = locale or all_locales
locales is a difference between the locales and exclude sets.,locales = set ( locales ) - set ( exclude )
"if locales is true,",if locales :
"call the function check_programs with 3 arguments: strings 'msguniq', 'msgmerge' and 'msgattrib'.","check_programs ( 'msguniq' , 'msgmerge' , 'msgattrib' )"
call the function check_programs with an argument string 'xgettext'.,check_programs ( 'xgettext' )
"try,",try :
"call the method self.build_potfiles, substitute the result for potfiles.",potfiles = self . build_potfiles ( )
"for every locale in locales,",for locale in locales :
"if self.verbosity is greater than integer 0,",if self . verbosity > 0 :
"replace '%s' in string ""processing locale %s\n"" with locale, write it to self.stdout.","self . stdout . write ( ""processing locale %s\n"" % locale )"
"for every potfile in potfiles,",for potfile in potfiles :
call the method self.write_po_file with 2 arguments: potfile and locale.,"self . write_po_file ( potfile , locale )"
"finally perform,",finally :
"if self.keep_pot is false,",if not self . keep_pot :
call the method self.remove_potfiles.,self . remove_potfiles ( )
define the method build_potfiles with an argument self.,def build_potfiles ( self ) :
"call the method self.find_files with an argument string '.', substitute the result for file_list.","file_list = self . find_files ( ""."" )"
call the method self.remove_potfiles.,self . remove_potfiles ( )
"for f in file_list,",for f in file_list :
"try,",try :
call the function f.process with 2 arguments: self and self.domain.,"f . process ( self , self . domain )"
"if except UnicodeDecodeError exception is caught,",except UnicodeDecodeError :
"substitute '%s' in string ""UnicodeDecodeError: skipped file %s in %s"" with f.file and f.dirpath, write it to self.stdout.","self . stdout . write ( ""UnicodeDecodeError: skipped file %s in %s"" % ( f . file , f . dirpath ) )"
potfiles is an empty list.,potfiles = [ ]
"for every path in self.locale_paths,",for path in self . locale_paths :
"join into a path: path and string '%s.pot', where '%s' is replaced with self.domain converted into a string.","potfile = os . path . join ( path , '%s.pot' % str ( self . domain ) )"
"if potfile file path doesnt exist,",if not os . path . exists ( potfile ) :
skip this loop iteration.,continue
"append self.msguniq_options to a list containing a string 'msguniq', append list containing potfile to the result, substitute it for args.",args = [ 'msguniq' ] + self . msguniq_options + [ potfile ]
"call the function popen_wrapper with an argument args, assign the result to msgs, errors and status, respectively.","msgs , errors , status = popen_wrapper ( args )"
"if six.PY2 is true,",if six . PY2 :
"call the method msgs.decode with an argument string 'utf-8', substitute it for msgs.",msgs = msgs . decode ( 'utf-8' )
"if errors is true,",if errors :
"if status is not equal to STATUS_OK,",if status != STATUS_OK :
"raise an CommandError exception with an argument string ""errors happened while running msguniq\n%s"", where '%s' is replaced with errors.","raise CommandError ( ""errors happened while running msguniq\n%s"" % errors )"
"otherwise if self.verbosity is greater than integer 0,",elif self . verbosity > 0 :
write errors to self.stdout.,self . stdout . write ( errors )
"call the function io.open with 3 arguments: potfile, string 'w' and encoding set to string 'utf-8' as arguments,","with io . open ( potfile , 'w' , encoding = 'utf-8' ) as fp :"
"with the result renamed to fp, perform the following: write msgs to fp.",fp . write ( msgs )
append potfile to potfiles.,potfiles . append ( potfile )
return potfiles.,return potfiles
define the method remove_potfiles with an argument self.,def remove_potfiles ( self ) :
"for every path in self.locale_paths,",for path in self . locale_paths :
"join into a file path: path and string '%s.pot', where '%s' is replaced with self.domain converted into a string, substitute the result for pot_path.","pot_path = os . path . join ( path , '%s.pot' % str ( self . domain ) )"
"if pot_path file path exists,",if os . path . exists ( pot_path ) :
call the method os.unlink with an argument pot_path.,os . unlink ( pot_path )
define the method find_potfiles with an arguments self and root.,"def find_files ( self , root ) :"
define the function is_ignored with arguments path and ignore_patterns.,"def is_ignored ( path , ignore_patterns ) :"
"call the function os.path.basename with an arguments path, substitute the result for filename.",filename = os . path . basename ( path )
"ignore is a lambda function with pattern as an argument, return value is the return value of the function fnmatch.fnmatchcase,","ignore = lambda pattern : fnmatch . fnmatchcase ( filename , pattern )"
"called with arguments: filename and pattern. call the function ignore with an argument pattern, for every pattern in ignore_patterns,",return any ( ignore ( pattern ) for pattern in ignore_patterns )
"if any resulting element is true, return boolean True, otherwise return boolean False. convert os.sep into a string and append '*' to it, substitute the result for dir_suffix.",dir_suffix = '%s*' % os . sep
"for p in self.ignore_patterns if p ends with dir_suffix take sliced list p from the start,",norm_patterns = [ p [ : - len ( dir_suffix ) ] if p . endswith ( dir_suffix ) else p for p in self . ignore_patterns ]
"to the negative length of the dir_suffix as the end index and append it to a list, if p doesnt end with dir_suffix, append p to a list, substitute resulting list for norm_patterns. all_files is an empty list.",all_files = [ ]
"call the function os.walk with 3 arguments: root, topdown set to boolean True, followlinks set to self.symlinks,","for dirpath , dirnames , filenames in os . walk ( root , topdown = True , followlinks = self . symlinks ) :"
"for every dirpath, dirnames and filenames in the result, for every dirname in list dirnames,",for dirname in dirnames [ : ] :
"join dirpath and dirname into a file path, use is as an argument for the call to the function os.path.join,","if is_ignored ( os . path . normpath ( os . path . join ( dirpath , dirname ) ) , norm_patterns ) :"
"use the result as an argument for the call to the os.path.join function, use the result and the norm_patterns as arguments for the call to the is_ignored function, if it evaluates to true, remove dirname from the dirnames.",dirnames . remove ( dirname )
"if self.verbosity is greater than integer 1,",if self . verbosity > 1 :
"replace '%s' in string 'ignoring directory %s\n' with dirname, write it to self.stdout stream.",self . stdout . write ( 'ignoring directory %s\n' % dirname )
"otherwise if dirname equals string 'locale',",elif dirname == 'locale' :
remove dirname from the dirnames.,dirnames . remove ( dirname )
"call the method os.path.abspath with an argument dirpath, join the result and dirname into a file path, inset it at the beggining of self.locale_paths.","self . locale_paths . insert ( 0 , os . path . join ( os . path . abspath ( dirpath ) , dirname ) )"
"for every filename in filenames,",for filename in filenames :
"join dirpath and filename into path, use it as an argument for the call to the function os.path.normpath, substitute it for file_path.","file_path = os . path . normpath ( os . path . join ( dirpath , filename ) )"
"call the function is_ignored, with arguments: file_path and self.ignore_patterns, if it evaluates to true,","if is_ignored ( file_path , self . ignore_patterns ) :"
"if self.verbosity is greater than integer 1,",if self . verbosity > 1 :
"replace '%s' in string 'ignoring file %s in %s\n' with filename and dirpath, write it to self.stdout.","self . stdout . write ( 'ignoring file %s in %s\n' % ( filename , dirpath ) )"
"if not,",else :
locale_dir is None.,locale_dir = None
"for every path in self.locale_paths,",for path in self . locale_paths :
"call the function os.path.abspath with an argument dirpath, if it starts with return value of the method os.path.dirname,",if os . path . abspath ( dirpath ) . startswith ( os . path . dirname ( path ) ) :
"called with an argument path, substitute path for locale_dir.",locale_dir = path
break the loop execution.,break
"if locale_dir is false,",if not locale_dir :
substitute self.default_locale_path for locale_dir.,locale_dir = self . default_locale_path
"if locale_dir is false,",if not locale_dir :
"raise an CommandError with an argument string ""Unable to find a locale path to store translations for file %s"",","raise CommandError ( ""Unable to find a locale path to store translations for file %s"" % file_path )"
"where '%s' is replaced with file_path. create an object TranslatableFile with arguments: dirpath, filename and locale_dir, append it to all_files.","all_files . append ( TranslatableFile ( dirpath , filename , locale_dir ) )"
sort all_files and return it.,return sorted ( all_files )
"define the method write_po_file with arguments self, potfile and locale.","def write_po_file ( self , potfile , locale ) :"
"call the method os.path.dirname with an argument potfile, join the result, locale and string 'LC_MESSAGES' into a file path,","basedir = os . path . join ( os . path . dirname ( potfile ) , locale , 'LC_MESSAGES' )"
"substitute it for basedir. if basedir is not a directory,",if not os . path . isdir ( basedir ) :
"make basedir directory,",os . makedirs ( basedir )
"convert self.domain into a string and append string '.po' to it, join basedir and result in file path, substitute it for pofile.","pofile = os . path . join ( basedir , '%s.po' % str ( self . domain ) )"
"if pofile path exists,",if os . path . exists ( pofile ) :
"append self.msgmerge_options to a list containing string 'msgmerge', append to it a list containing pofile and potfile, substitute the result for args.","args = [ 'msgmerge' ] + self . msgmerge_options + [ pofile , potfile ]"
"call the function popen_wrapper with an argument args, assign the result to msgs, errors and status.","msgs , errors , status = popen_wrapper ( args )"
"if six.PY2 is true,",if six . PY2 :
"call the method msgs.decode with an argument string 'utf-8', substitute the result for msgs.",msgs = msgs . decode ( 'utf-8' )
"if errors is true,",if errors :
if statue is not equal to STATUS_OK.,if status != STATUS_OK :
"raise an CommandError with an argument string ""errors happened while running msgmerge\n%s"", where '%s' is replaced with errors.","raise CommandError ( ""errors happened while running msgmerge\n%s"" % errors )"
"otherwise if self.verbosity is greater than integer 0,",elif self . verbosity > 0 :
write errors to self.stdout.,self . stdout . write ( errors )
"if not,",else :
"call the function io.open with 3 arguments: potfile, string 'r' and encoding set to string 'utf-8' as arguments,","with io . open ( potfile , 'r' , encoding = 'utf-8' ) as fp :"
"with the result renamed to fp, perform the following: read file fp and substitute the result for msgs.",msgs = fp . read ( )
"if self.invoked_for_django is false,",if not self . invoked_for_django :
"call the method self.copy_plural_forms with arguments: msgs and locale, substitute it for msgs.","msgs = self . copy_plural_forms ( msgs , locale )"
"substitute '%s' in string ""#. #-#-#-#-# %s.pot (PACKAGE VERSION) #-#-#-#-#\n"" with self.domain,","msgs = msgs . replace ( ""#. #-#-#-#-# %s.pot (PACKAGE VERSION) #-#-#-#-#\n"" % self . domain , """" )"
"replace all the occurrences of previous string in msgs for an empty string, substitute the result for msgs. call the function io.open with 3 arguments: pofile, string 'w' and encoding set to string 'utf-8' as arguments,","with io . open ( pofile , 'w' , encoding = 'utf-8' ) as fp :"
"with the result renamed to fp, perform the following: write msgs to fp.",fp . write ( msgs )
"if self.no_obsolete is true,",if self . no_obsolete :
"append self.msgattrib_options to a list containing string 'msgattrib', append to it a list containing string '-o', pofile and pofile,","args = [ 'msgattrib' ] + self . msgattrib_options + [ '-o' , pofile , pofile ]"
"substitute the result for args. call the function popen_wrapper with an argument args, assign the result to msgs, errors and status, respectively.","msgs , errors , status = popen_wrapper ( args )"
"if errors is true,",if errors :
"if status is not equal to STATUS_OK,",if status != STATUS_OK :
"raise an CommandError with an argument string ""errors happened while running msgattrib\n%s"", where '%s' is replaced with errors.","raise CommandError ( ""errors happened while running msgattrib\n%s"" % errors )"
"otherwise if self.verbosity is greater than integer 0,",elif self . verbosity > 0 :
write errors to self.stdout.,self . stdout . write ( errors )
"define the method copy_plural_forms with arguments self, msgs and locale.","def copy_plural_forms ( self , msgs , locale ) :"
"call the function os.path.dirname with an argument django.__file__, join the result into a path,",django_dir = os . path . normpath ( os . path . join ( os . path . dirname ( django . __file__ ) ) )
"use it as an argument for the call to the function os.path.normpath, substitute the result for django_dir. if self.domain equals a string 'djangojs',",if self . domain == 'djangojs' :
domains is a tuple with 2 elements: strings 'djangojs' and 'django'.,"domains = ( 'djangojs' , 'django' )"
"if not,",else :
domains is a tuple with element string 'django'.,"domains = ( 'django' , )"
"for every domain in domains,",for domain in domains :
"join into a file path: django_dir, 'conf', 'locale', locale, 'LC_MESSAGES' and string '.po' appended to domain, substitute the result for django_po.","django_po = os . path . join ( django_dir , 'conf' , 'locale' , locale , 'LC_MESSAGES' , '%s.po' % domain )"
"if django_po file path exists,",if os . path . exists ( django_po ) :
"call the function io.open with 3 arguments: django_po, string 'r' and encoding set to string 'utf-8' as arguments,","with io . open ( django_po , 'r' , encoding = 'utf-8' ) as fp :"
"with the result renamed to fp, perform the following: read data from file fp, use the result as an argument for the call to the function plural_forms_re.search, substitute it for m.",m = plural_forms_re . search ( fp . read ( ) )
"if m is true,",if m :
"call the method m.group with an argument string 'value', use the result as an argument for the call to the force_str,",plural_form_line = force_str ( m . group ( 'value' ) )
"substitute the result for plural_form_line. if self.verbosity is greater than integer 1,",if self . verbosity > 1 :
"replace '%s' in string ""copying plural forms: %s\n"" with plural_form_line, write it to self.stdout.","self . stdout . write ( ""copying plural forms: %s\n"" % plural_form_line )"
lines is an empty list.,lines = [ ]
found is boolean False.,found = False
"split msgs by newline characters, for every line in result,",for line in msgs . split ( '\n' ) :
"if found is false and, line is false or return value of the function plural_forms_re.search called with an argument line is false,",if not found and ( not line or plural_forms_re . search ( line ) ) :
"append newline to plural_form_line, substitute the result for line.",line = '%s\n' % plural_form_line
found is boolean True.,found = True
append line to lines.,lines . append ( line )
"join elements of lines into a string, separated by newline characters, substitute it for msgs.",msgs = '\n' . join ( lines )
break the loop execution.,break
return msgs.,return msgs
import module sys.,import sys
import module os.,import os
import module operator.,import operator
from django.apps import apps into default name space.,from django . apps import apps
from django.core.management.base import BaseCommand and CommandError into default name space.,"from django . core . management . base import BaseCommand , CommandError"
from django.db.migrations import Migration into default name space.,from django . db . migrations import Migration
from django.db.migrations.loader import MigrationLoader into default name space.,from django . db . migrations . loader import MigrationLoader
from django.db.migrations.autodetector import MigrationAutodetector into default name space.,from django . db . migrations . autodetector import MigrationAutodetector
from django.db.migrations.questioner import MigrationQuestioner and InteractiveMigrationQuestioner into default name space.,"from django . db . migrations . questioner import MigrationQuestioner , InteractiveMigrationQuestioner"
from django.db.migrations.state import ProjectState into default name space.,from django . db . migrations . state import ProjectState
from django.db.migrations.writer import MigrationWriter into default name space.,from django . db . migrations . writer import MigrationWriter
from django.utils.six.moves import reduce into default name space.,from django . utils . six . moves import reduce
derive the class Command from the BaseCommand class.,class Command ( BaseCommand ) :
"help is a string ""Creates new migration(s) for apps."".","help = ""Creates new migration(s) for apps."""
define the method add_arguments with 2 arguments self and parser.,"def add_arguments ( self , parser ) :"
"call the method parser.add_argument with 4 arguments: string 'args', metavar set to string 'app_label', nargs set to character'*',","parser . add_argument ( 'args' , metavar = 'app_label' , nargs = '*' , help = 'Specify the app label(s) to create migrations for.' )"
"and help as a string 'Specify the app label(s) to create migrations for.'. call the method parser.add_argument with 5 arguments: string '--dry-run', action as a string 'store_true', dest as string 'dry_run',","parser . add_argument ( '--dry-run' , action = 'store_true' , dest = 'dry_run' , default = False , help = ""Just show what migrations would be made; don't actually write them."" )"
"default set to boolean False, help as a string ""Just show what migrations would be made; don't actually write them."". call the method parser.add_argument with 5 arguments: string '--merge', action as a string 'store_true', dest as a string 'merge',","parser . add_argument ( '--merge' , action = 'store_true' , dest = 'merge' , default = False , help = ""Enable fixing of migration conflicts."" )"
"default set to boolean False and help set to a string ""Enable fixing of migration conflicts."". call the method parser.add_argument with 5 arguments: string '--empty', action as a string 'store_true', dest as a string 'empty',","parser . add_argument ( '--empty' , action = 'store_true' , dest = 'empty' , default = False , help = ""Create an empty migration."" )"
"default set to boolean False and help as a string ""Create an empty migration."". call the method parser.add_argument with 5 arguments: string '--noinput', action as a string 'store_false',","parser . add_argument ( '--noinput' , action = 'store_false' , dest = 'interactive' , default = True , help = 'Tells Django to NOT prompt the user for input of any kind.' )"
"dest as a string 'interactive', default set to boolean True, and help as a string 'Tells Django to NOT prompt the user for input of any kind.'. define the method handle with 3 arguments: self, unpacked list app_labels and unpacked dictionary options.","def handle ( self , * app_labels , ** options ) :"
"get the value under the 'verbosity' key of the options dictionary, substitute it for self.verbosity.",self . verbosity = options . get ( 'verbosity' )
"get the value under the 'interactive' key of the options dictionary, substitute it for self.interactive.",self . interactive = options . get ( 'interactive' )
"get the value under the 'dry_run' key of the options dictionary, if the key exists substitute it for self.dry_run,","self . dry_run = options . get ( 'dry_run' , False )"
"if not, self.dry_run is boolean False. get the value under the 'merge' key of the options dictionary, if the key exists substitute it for self.merge,","self . merge = options . get ( 'merge' , False )"
"if not, self.merge is boolean False. get the value under the 'empty' key of the options dictionary, if the key exists substitute it for self.empty,","self . empty = options . get ( 'empty' , False )"
"if not, self.empty is boolean False. crate a set containing of app_labels elements, substitute it for app_labels.",app_labels = set ( app_labels )
bad_app_labels is an empty set.,bad_app_labels = set ( )
"for every app_label in app_labels,",for app_label in app_labels :
"try,",try :
call the method apps.get_app_config with an argument app_label.,apps . get_app_config ( app_label )
"if LookupError exception is caught,",except LookupError :
"call the method bad_app_labels with an argument app_label,",bad_app_labels . add ( app_label )
"if bad_app_labels is true,",if bad_app_labels :
"for every app_label in bad_app_labels,",for app_label in bad_app_labels :
"write string ""App '%s' could not be found. Is it in INSTALLED_APPS?"" with '%s' where '%s' is replaced with app_label,","self . stderr . write ( ""App '%s' could not be found. Is it in INSTALLED_APPS?"" % app_label )"
write it for self.stderr. exit the program with the integer 2 as exit code.,sys . exit ( 2 )
"loader is an instance of MigrationLoader class, created with 2 arguments: None and ignore_no_migrations set to boolean True.","loader = MigrationLoader ( None , ignore_no_migrations = True )"
"call the method loader.detect_conflicts, substitute the result for conflicts.",conflicts = loader . detect_conflicts ( )
"if conflicts is true and self.merge is false,",if conflicts and not self . merge :
"for every app and names in result of the method conflicts.items, join names into a string, separated by ', ',","name_str = ""; "" . join ( ""%s in %s"" % ( "", "" . join ( names ) , app ) for app , names in conflicts . items ( ) )"
"join it with app into a string, separated with string '; ', substitute it for name_str. substitute '%s\ in string ""Conflicting migrations detected (%s).\nTo fix them run 'python manage.py makemigrations --merge'"",","raise CommandError ( ""Conflicting migrations detected (%s).\nTo fix them run 'python manage.py makemigrations --merge'"" % name_str )"
"with name_str, use it as an argument to throw an CommandError exception. if self.merge is true and conflicts is false,",if self . merge and not conflicts :
"write string ""No conflicts detected to merge."" to self.stdout stream.","self . stdout . write ( ""No conflicts detected to merge."" )"
return nothing.,return
"if self.merge and conflicts are both true,",if self . merge and conflicts :
"call the method self.handle_merge with 2 arguments: loader and conflicts, return the result.","return self . handle_merge ( loader , conflicts )"
"autodetector is an instance of the MigrationAutodetector class, created with 3 arguments: result of the method loader.project_state,","autodetector = MigrationAutodetector ( loader . project_state ( ) , ProjectState . from_apps ( apps ) , InteractiveMigrationQuestioner ( specified_apps = app_labels , dry_run = self . dry_run ) , )"
"result of the method ProjectState.from_apps with an argument apps and result of the method InteractiveMigrationQuestioner, called with 2 arguments specified_apps set to app_labels and dry_run set to self.dry_run. if self.empty is true,",if self . empty :
"if app_labels is false,",if not app_labels :
"raise an CommandError with an argument string ""You must supply at least one app label when using --empty."".","raise CommandError ( ""You must supply at least one app label when using --empty."" )"
"crate a dictionary with app mapping and from the class Migration, created with arguments: string 'custom' and app,","changes = dict ( ( app , [ Migration ( ""custom"" , app ) ] ) for app in app_labels )"
"for every app in app_labels. call the method autodetector.arrange_for_graph with 2 arguments: changes, loader.graph, substitute the result for changes.","changes = autodetector . arrange_for_graph ( changes , loader . graph )"
call the method self.write_migration_files with an argument changes.,self . write_migration_files ( changes )
return nothing.,return
"call the method autodetector.changes with 3 arguments: graph set to loader.graph, trim_to_apps set to app_labels,","changes = autodetector . changes ( graph = loader . graph , trim_to_apps = app_labels or None , convert_apps = app_labels or None , )"
"if it exists or None if not and convert_apps set to app_labels, if it exists or None if not, substitute the result for changes. if changes is false and self.verbosity is greater than, or equal to iteger 1,",if not changes and self . verbosity >= 1 :
"if length of app_labels is equal to integer 1,",if len ( app_labels ) == 1 :
"substitute '%s' in string ""No changes detected in app '%s'"" with the result of the method app_labels.pop, write it to self.stdout.","self . stdout . write ( ""No changes detected in app '%s'"" % app_labels . pop ( ) )"
"otherwise if length of app_labels is greater than integer 1,",elif len ( app_labels ) > 1 :
"substitute '%s' in string ""No changes detected in apps '%s'"" with the app_labels joined into a string, separated by string ""', '"",","self . stdout . write ( ""No changes detected in apps '%s'"" % ( ""', '"" . join ( app_labels ) ) )"
"write it to self.stdout. if not,",else :
"write string ""No changes detected"" to self.stdout stream.","self . stdout . write ( ""No changes detected"" )"
return nothing.,return
call the method self.write_migration_files with an argument changes.,self . write_migration_files ( changes )
define the method write_migration_files with arguments self and changes.,"def write_migration_files ( self , changes ) :"
directory_created is an empty dictionary.,directory_created = { }
"for every app_label and app_migrations in result of the method changes.items,","for app_label , app_migrations in changes . items ( ) :"
"if self.verbosity is greater or equal to integer 1,",if self . verbosity >= 1 :
"substitute '%s' in a string ""Migrations for '%s':"" with app_label, append newline to it,","self . stdout . write ( self . style . MIGRATE_HEADING ( ""Migrations for '%s':"" % app_label ) + ""\n"" )"
"use it as an argument for the call to the method self.style.MIGRATE_HEADING, write the result to self.stdout. for every migration in app_migrations,",for migration in app_migrations :
"writer is an instance of MigrationWriter class, created with an argument migration.",writer = MigrationWriter ( migration )
"if self.verbosity is greater or equal to integer 1,",if self . verbosity >= 1 :
"substitute '%s' in a string "" %s:\n"" with return value of the self.style.MIGRATE_LABEL method called with argument writer.filename,","self . stdout . write ( "" %s:\n"" % ( self . style . MIGRATE_LABEL ( writer . filename ) , ) )"
"write the result to self.stdout. for every operation in migration.operations,",for operation in migration . operations :
"substitute '%s' in a string "" - %s\n"" with return value of the operation.describe method, write the result to self.stdout.","self . stdout . write ( "" - %s\n"" % operation . describe ( ) )"
"if self.dry_run is false,",if not self . dry_run :
"call the function os.path.dirname with an argument writer.path, substitute the result for migrations_directory.",migrations_directory = os . path . dirname ( writer . path )
"get the value under the app_label key of the directory_created dictionary, if exists and it is false,","if not directory_created . get ( app_label , False ) :"
"if migrations_directory is not a directory,",if not os . path . isdir ( migrations_directory ) :
make a directory migrations_directory.,os . mkdir ( migrations_directory )
"join migrations_directory and string ""__init__.py"" into a file path, substitute it for init_path.","init_path = os . path . join ( migrations_directory , ""__init__.py"" )"
"if init_path is not a file,",if not os . path . isfile ( init_path ) :
crate a file named init_path.,"open ( init_path , ""w"" ) . close ( )"
value under the all_label key of the directory_created dictionary is boolean True.,directory_created [ app_label ] = True
"call the method writer.as_string, substitute the result for migration_string.",migration_string = writer . as_string ( )
"open writer.path file in write mode, with the file descriptor as fh, perform,","with open ( writer . path , ""wb"" ) as fh :"
write migration_string to file fh.,fh . write ( migration_string )
"otherwise if self.verbosity equals integer 3,",elif self . verbosity == 3 :
"substitute '%s' in a string ""Full migrations file '%s':"" with writer.filename, append newline to it,","self . stdout . write ( self . style . MIGRATE_HEADING ( ""Full migrations file '%s':"" % writer . filename ) + ""\n"" )"
"use it as an argument for the call to the method self.style.MIGRATE_HEADING, write the result to self.stdout. call the method writer.as_string, append newline to the result, write it to self.stdout.","self . stdout . write ( ""%s\n"" % writer . as_string ( ) )"
"define the method handle_merge with arguments self, loader and conflicts.","def handle_merge ( self , loader , conflicts ) :"
"if self.interactive is true,",if self . interactive :
questioner is an instance of a InteractiveMigrationQuestioner class.,questioner = InteractiveMigrationQuestioner ( )
"if not,",else :
"questioner is an instance of a InteractiveMigrationQuestioner class, created with an argument: defaults set to dictionary with entry:",questioner = MigrationQuestioner ( defaults = { 'ask_merge' : True } )
"boolean True for 'ask_merge'. for every app_label and migration_names in result of the method conflicts.items,","for app_label , migration_names in conflicts . items ( ) :"
merge_migrations is an empty list.,merge_migrations = [ ]
"for every migration_name in migration_names,",for migration_name in migration_names :
"call the method loader.get_migration with arguments app_label and migration_name, substitute the result for migration.","migration = loader . get_migration ( app_label , migration_name )"
"call the method loader.graph.forwards_plan with argument a tuple, with 2 elements: app_label and migration_name,","migration . ancestry = loader . graph . forwards_plan ( ( app_label , migration_name ) )"
substitute the result for migration.ancestry. append migration to merge_migrations.,merge_migrations . append ( migration )
common_ancestor is None.,common_ancestor = None
"for m in merge_migrations append m.ancestry to a list, zip the resulting list into tuples of pairs, for every level in result,",for level in zip ( * [ m . ancestry for m in merge_migrations ] ) :
"apply operator.eq function to elements of level iterable, until level is reduced to a single value, if the result is true,","if reduce ( operator . eq , level ) :"
substitute first element of level for common_ancestor.,common_ancestor = level [ 0 ]
"if not,",else :
"break the loop execution,",break
"if common_ancestor is None,",if common_ancestor is None :
"raise an ValueError with an argument string ""Could not find common ancestor of %s"", where '%s' is replaced with migration_names.","raise ValueError ( ""Could not find common ancestor of %s"" % migration_names )"
"for every migration in merge_migrations,",for migration in merge_migrations :
"call the method migration.ancestry.index with an argument common_ancestor, increment the result by one,",migration . branch = migration . ancestry [ ( migration . ancestry . index ( common_ancestor ) + 1 ) : ]
"slice migration.ancestry list from the last result as an starting index to the end, substitute the slice for migration.branch. migration.merged_operations is an empty list.",migration . merged_operations = [ ]
"for every node_app and node_name in migration.branch,","for node_app , node_name in migration . branch :"
"call the method loader.get_migration with arguments node_app and node_name, extend the migration.merged_operations with the operations field of the result.","migration . merged_operations . extend ( loader . get_migration ( node_app , node_name ) . operations )"
"if self.verbosity is greater than integer 1,",if self . verbosity > 0 :
"substitute '%s' in a string ""Merging %s"" with app_label,","self . stdout . write ( self . style . MIGRATE_HEADING ( ""Merging %s"" % app_label ) )"
"use it as an argument for the call to the method self.style.MIGRATE_HEADING, write the result to self.stdout. for every migration in merge_migrations,",for migration in merge_migrations :
"substitute '%s' in a string "" Branch %s"" with migration.name,","self . stdout . write ( self . style . MIGRATE_LABEL ( "" Branch %s"" % migration . name ) )"
"use it as an argument for the call to the method self.style.MIGRATE_HEADING, write the result to self.stdout. for every operation in migration.merged_operations,",for operation in migration . merged_operations :
"substitute '%s' in a string "" - %s\n"" with return value of the operation.describe method, write the result to self.stdout.","self . stdout . write ( "" - %s\n"" % operation . describe ( ) )"
"call the method questioner.ask_merge with an argument app_label, if it evaluates to true,",if questioner . ask_merge ( app_label ) :
"numbers is a list containing return value of the MigrationAutodetector.parse_number method called with an argument migration.name,",numbers = [ MigrationAutodetector . parse_number ( migration . name ) for migration in merge_migrations ]
"for every migration in merge_migrations. try,",try :
biggest_number is maximum numbers element.,biggest_number = max ( [ x for x in numbers if x is not None ] )
"if ValueError exception is caught,",except ValueError :
biggest_number is integer 1.,biggest_number = 1
"subclass is a instance of a class named Migration, derived from the base class Migration, with 1 field:","subclass = type ( ""Migration"" , ( Migration , ) , { ""dependencies"" : [ ( app_label , migration . name ) for migration in merge_migrations ] , } )"
"dependencies set to a list of tuples with 2 elements: app_label and migration.name for every migration in merge_migrations. call the method subsclass with 2 arguments: string ""%04i_merge"", replace '%04i' with biggest_number incremented by one,","new_migration = subclass ( ""%04i_merge"" % ( biggest_number + 1 ) , app_label )"
"that occupies minimum 4 places within a string, and app_label, substitute the result for new_migration. writer is instance of MigrationWriter class, created with new_migration argument.",writer = MigrationWriter ( new_migration )
"open writer.path file in write mode, with the file descriptor as fh, perform the following,","with open ( writer . path , ""wb"" ) as fh :"
"call the method writer.as_string, write the result to fh file.",fh . write ( writer . as_string ( ) )
"if self.verbosity is greater than integer 0,",if self . verbosity > 0 :
"substitute '%s' in a string ""\nCreated new merge migration %s"" with writer path, write it to self.stdout.","self . stdout . write ( ""\nCreated new merge migration %s"" % writer . path )"
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
from collections import OrderedDict into default name space.,from collections import OrderedDict
from importlib import import_module into default name space.,from importlib import import_module
import module itertools.,import itertools
import module traceback.,import traceback
from django.apps import apps into default name space.,from django . apps import apps
from django.core.management import call_command into default name space.,from django . core . management import call_command
from django.core.management.base import BaseCommand and CommandError into default name space.,"from django . core . management . base import BaseCommand , CommandError"
from django.core.management.color import no_style into default name space.,from django . core . management . color import no_style
"from django.core.management.sql import custom_sql_for_model, emit_post_migrate_signal and emit_pre_migrate_signal into default name space.","from django . core . management . sql import custom_sql_for_model , emit_post_migrate_signal , emit_pre_migrate_signal"
"from django.db import connections, router, transaction and DEFAULT_DB_ALIAS into default name space.","from django . db import connections , router , transaction , DEFAULT_DB_ALIAS"
from django.db.migrations.executor import MigrationExecutor into default name space.,from django . db . migrations . executor import MigrationExecutor
from django.db.migrations.loader import MigrationLoader and AmbiguityError into default name space.,"from django . db . migrations . loader import MigrationLoader , AmbiguityError"
from django.db.migrations.state import ProjectState into default name space.,from django . db . migrations . state import ProjectState
from django.db.migrations.autodetector import MigrationAutodetector into default name space.,from django . db . migrations . autodetector import MigrationAutodetector
from django.utils.module_loading import module_has_submodule into default name space.,from django . utils . module_loading import module_has_submodule
derive the class Command from the base class BaseCommand.,class Command ( BaseCommand ) :
"help is a string ""Updates database schema. Manages both apps with migrations and those without."".","help = ""Updates database schema. Manages both apps with migrations and those without."""
define the method add_arguments with self class instance and parse as the arguments.,"def add_arguments ( self , parser ) :"
"call the method parser.add_argument with string 'app_label', nargs set to charcter '?', help containing string,","parser . add_argument ( 'app_label' , nargs = '?' , help = 'App label of an application to synchronize the state.' )"
"'App label of an application to synchronize the state.' as arguments. call the method parser.add_argument with string 'migration_name', nargs set to charcter '?', help containing string,","parser . add_argument ( 'migration_name' , nargs = '?' , help = 'Database state will be brought to the state after that migration.' )"
"'Database state will be brought to the state after that migration.' as arguments. call the method parser.add_argument with string '--noinput', action containing string 'store_false', dest set to string 'interactive',","parser . add_argument ( '--noinput' , action = 'store_false' , dest = 'interactive' , default = True , help = 'Tells Django to NOT prompt the user for input of any kind.' )"
"default set to True, help containing string 'Tells Django to NOT prompt the user for input of any kind.' as arguments. call the method parser.add_argument with string '--no-initial-data', action containing string 'store_false',","parser . add_argument ( '--no-initial-data' , action = 'store_false' , dest = 'load_initial_data' , default = True , help = 'Tells Django not to load any initial data after database synchronization.' )"
"dest set to string 'load_initial_data', default set to True, help containing string 'Tells Django not to load any initial data after database synchronization.' as arguments. call the method parser.add_argument with string '--database', action containing string 'store', dest set to string 'database',","parser . add_argument ( '--database' , action = 'store' , dest = 'database' , default = DEFAULT_DB_ALIAS , help = 'Nominates a database to synchronize. ' 'Defaults to the ""default"" database.' )"
"default set to DEFAULT_DB_ALIAS, help containing string 'Nominates a database to synchronize. Defaults to the ""default"" database.' as arguments. call the method parser.add_argument with string '--fake', action containing string 'store_true', dest set to string 'fake',","parser . add_argument ( '--fake' , action = 'store_true' , dest = 'fake' , default = False , help = 'Mark migrations as run without actually running them' )"
"default set to False, help containing string 'Mark migrations as run without actually running them' as arguments. call the method parser.add_argument with string '--list', string '-l', action contains string 'store_true', dest set to string 'list',","parser . add_argument ( '--list' , '-l' , action = 'store_true' , dest = 'list' , default = False , help = 'Show a list of all known migrations and which are applied' )"
"default set to False, help containing string 'Show a list of all known migrations and which are applied' as arguments. define the method handle with self instance of a class, list args, dictionary options as arguments.","def handle ( self , * args , ** options ) :"
"get the value from the options dictionary under the key 'verbosity', substitute it for self.verbosity.",self . verbosity = options . get ( 'verbosity' )
"get the value from the options dictionary under the key 'interactive', substitute it for self.interactive.",self . interactive = options . get ( 'interactive' )
"get the value from the options dictionary under the key 'traceback', substitute it for self.show_traceback.",self . show_traceback = options . get ( 'traceback' )
"get the value from the options dictionary under the key 'load_initial_data', substitute it for self.load_initial_data.",self . load_initial_data = options . get ( 'load_initial_data' )
"get the value from the options dictionary under the key 'test_database', or False if the key dont exists, substitute it for self.test_database.","self . test_database = options . get ( 'test_database' , False )"
"for every app_config in return value of the call to the function apps.get_app_configs,",for app_config in apps . get_app_configs ( ) :
"if call to the function module_has_submodule with app_config.module and ""management"" evaluates to True.","if module_has_submodule ( app_config . module , ""management"" ) :"
import module '.management' from the package app_config.name.,"import_module ( '.management' , app_config . name )"
"get the value under the key 'database' of the options dictionary, substitute it for db.",db = options . get ( 'database' )
substitute connections element at the index of the value db for connections.,connection = connections [ db ]
"get the value under the 'list' key of options dictionary, if key doesnt exist return False, if the return value is True,","if options . get ( ""list"" , False ) :"
"call the method self.show_migration_list with connection as first argument, as second argument use value under the 'app_label' key of options dictionary,","return self . show_migration_list ( connection , [ options [ 'app_label' ] ] if options [ 'app_label' ] else None )"
"if exists, if not use None as the second argument, return the result. call the function MigrationExecutor with connection and self.migration_progress_callback as arguments, substitute the result fro executor.","executor = MigrationExecutor ( connection , self . migration_progress_callback )"
"call the executor.loader.detect_conflicts, substitute the result fr conflicts.",conflicts = executor . loader . detect_conflicts ( )
"if conflicts is true,",if conflicts :
"for every app and names in key, value tuple pairs of conflicts dictionary join names into a string separated by commas,","name_str = ""; "" . join ( ""%s in %s"" % ( "", "" . join ( names ) , app ) for app , names in conflicts . items ( ) )"
"in ""%s in %s"" substitute '%s' with names string and app, respective, join all the previous pairs into a string separated by ';', substitute it for name_str. raise CommandError exception, with ""Conflicting migrations detected (%s).\nTo fix them run 'python manage.py makemigrations --merge'"",","raise CommandError ( ""Conflicting migrations detected (%s).\nTo fix them run 'python manage.py makemigrations --merge'"" % name_str )"
"with '%s' substituted for name_str, as argument. run_syncdb is boolean False.",run_syncdb = False
target_app_labels_only is boolean True.,target_app_labels_only = True
"if values under the 'app_label' and 'migration_name' keys of the options dictionary are True,",if options [ 'app_label' ] and options [ 'migration_name' ] :
"assign values under the 'app_label' and 'migration_name' keys of the options dictionary to the app_label and migration_name, respectively.","app_label , migration_name = options [ 'app_label' ] , options [ 'migration_name' ]"
"if app_label is not contained in executor.loader.migrated_apps,",if app_label not in executor . loader . migrated_apps :
"raise CommandError exception with ""App '%s' does not have migrations (you cannot selectively sync unmigrated apps)"",","raise CommandError ( ""App '%s' does not have migrations (you cannot selectively sync unmigrated apps)"" % app_label )"
"with '%s' substituted for app_label, as arguments. if migration_name equals to string 'zero',","if migration_name == ""zero"" :"
"targets is a list containing tuple with two elements, app_label and None.","targets = [ ( app_label , None ) ]"
"if not,",else :
"try,",try :
"call the executor.loader.get_migration_by_prefix with app_label and migration_name, substitute the result for migration.","migration = executor . loader . get_migration_by_prefix ( app_label , migration_name )"
"if AmbiguityError exception is caught,",except AmbiguityError :
"raise CommandError exception with ""More than one migration matches '%s' in app '%s'. Please be more specific."",","raise CommandError ( ""More than one migration matches '%s' in app '%s'. Please be more specific."" % ( migration_name , app_label ) )"
"with '%s' substituted for migration_name and app_label, respectively, as arguments. if KeyError exception is caught,",except KeyError :
"raise CommandError exception with ""Cannot find a migration matching '%s' from app '%s'."",","raise CommandError ( ""Cannot find a migration matching '%s' from app '%s'."" % ( migration_name , app_label ) )"
"with '%s' substituted for migration_name and app_label, respectively, as arguments. targets is a list containing tuple with two elements, app_label and migration.name.","targets = [ ( app_label , migration . name ) ]"
target_app_labels_only is boolean False.,target_app_labels_only = False
"otherwise if value under the 'app_label' key of options dictionary is true,",elif options [ 'app_label' ] :
substitute the value under the 'app_label' key of options dictionary for app_label.,app_label = options [ 'app_label' ]
"if app_label is not contained in executor.loader.migrated_apps,",if app_label not in executor . loader . migrated_apps :
"raise CommandError exception with ""App '%s' does not have migrations (you cannot selectively sync unmigrated apps)"",","raise CommandError ( ""App '%s' does not have migrations (you cannot selectively sync unmigrated apps)"" % app_label )"
"with '%s' substituted for app_label, as arguments. for every key in return vale of the method executor.loader.graph.leaf_nodes, check if the first element of key equals to app_label,",targets = [ key for key in executor . loader . graph . leaf_nodes ( ) if key [ 0 ] == app_label ]
"if it does append it to targets list. if not,",else :
call the method executor.loader.graph.leaf_nodes and substitute its result for targets.,targets = executor . loader . graph . leaf_nodes ( )
run_syncdb is boolean True.,run_syncdb = True
"call the executor.migration_plan method with targets as the argument, substitute the result for plan.",plan = executor . migration_plan ( targets )
if self.verbosity is greater or equal to integer 1.,if self . verbosity >= 1 :
"call the self.style.MIGRATE_HEADING method, with string ""Operations to perform:"" as an argument,","self . stdout . write ( self . style . MIGRATE_HEADING ( ""Operations to perform:"" ) )"
"use the result as an argument for the call to the self.stdout.write method. if run_syncdb and executor.loader.unmigrated_apps exist,",if run_syncdb and executor . loader . unmigrated_apps :
"join the executor.loader.unmigrated_apps into a string separated by string ', ' append it to the end of a string "" Synchronize unmigrated apps: "",","self . stdout . write ( self . style . MIGRATE_LABEL ( "" Synchronize unmigrated apps: "" ) + ( "", "" . join ( executor . loader . unmigrated_apps ) ) )"
"use it as an argument for the call to the self.style.MIGRATE_LABEL method, use the result of the previous method as an argument for the call to the self.stdout.write method. if target_app_labels_only is true,",if target_app_labels_only :
"for every a and n in targets, put a into a set, join all the set elements into a string separated by string ', ',","self . stdout . write ( self . style . MIGRATE_LABEL ( "" Apply all migrations: "" ) + ( "", "" . join ( set ( a for a , n in targets ) ) or ""(none)"" ) )"
"if set is empty return string '(none)' instead, append the previous to the string "" Apply all migrations: "", use the previous string as the argument for the call to the method self.style.MIGRATE_LABEL, use the result as an argument for the call to the method self.stdout.write. if not,",else :
"if element of targets in first row and second column is None,",if targets [ 0 ] [ 1 ] is None :
"convert the first element of the first row of targets to string, append it to the string "" Unapply all migrations: "",","self . stdout . write ( self . style . MIGRATE_LABEL ( "" Unapply all migrations: "" ) + ""%s"" % ( targets [ 0 ] [ 0 ] , ) )"
"use the it as an argument for the call to the self.style.MIGRATE_LABEL method, use the result to cal the self.stdout.write method. if not,",else :
"replace '%s' in string ""%s, from %s"" with second and first element of the first targets row, respectively,","self . stdout . write ( self . style . MIGRATE_LABEL ( "" Target specific migration: "" ) + ""%s, from %s"" % ( targets [ 0 ] [ 1 ] , targets [ 0 ] [ 0 ] ) )"
"append it to the string "" Target specific migration: "", use it as the argument for the call to the self.style.MIGRATE_LABEL method, call the self.stdout.write method with previous return value as an argument. if run_syncdb and executor.loader.unmigrated_apps is true,",if run_syncdb and executor . loader . unmigrated_apps :
if self.verbosity is greater or equal to integer 1.,if self . verbosity >= 1 :
"call the self.style.MIGRATE_HEADING with string ""Synchronizing apps without migrations:"" as an argument,","self . stdout . write ( self . style . MIGRATE_HEADING ( ""Synchronizing apps without migrations:"" ) )"
"use the result as an argument for the call to the self.stdout.write. call the self.sync_apps method with connection and executor.loader.unmigrated_apps as arguments, substitute it for created_models.","created_models = self . sync_apps ( connection , executor . loader . unmigrated_apps )"
"if not,",else :
create_models is an empty list.,created_models = [ ]
"if the value under the 'test_flush' key of the options dictionary exists,","if options . get ( ""test_flush"" , False ) :"
"call the function call_command with string 'flush', verbosity set to greater element, self.verbosity decremented by 1 or integer 0,","call_command ( 'flush' , verbosity = max ( self . verbosity - 1 , 0 ) , interactive = False , database = db , reset_sequences = False , inhibit_post_migrate = True , )"
"interactive set to boolean False, database set to db, reset_sequences set to boolean False, inhibit_post_migrate set to boolean True. if self.verbosity is greater or equal to integer 1,",if self . verbosity >= 1 :
"call the self.style.MIGRATE_HEADING method with string ""Running migrations:"" as an argument, use the result as an argument for the call to the self.stdout.write method.","self . stdout . write ( self . style . MIGRATE_HEADING ( ""Running migrations:"" ) )"
"if plan is not true,",if not plan :
"if self.verbosity is greater or equal to integer 1,",if self . verbosity >= 1 :
"call the method self.stdout.write with string "" No migrations to apply."" as an argument.","self . stdout . write ( "" No migrations to apply."" )"
"call the MigrationAutodetector function with arguments, return value of the call to the method executor.loader.project_state,","autodetector = MigrationAutodetector ( executor . loader . project_state ( ) , ProjectState . from_apps ( apps ) , )"
"and return value of the call to the method ProjectState.from_apps with apps as an argument, assign it to the autodetector. call the method autodetector.changes with the graph set to executor.loader.graph as an argument, substitute it for the changes.",changes = autodetector . changes ( graph = executor . loader . graph )
"if changes is true,",if changes :
"call the method self.style.NOTICE with string "" Your models have changes that are not yet reflected in a migration, and so won't be applied."" as an argument, use the result as an argument for the call to the self.stdout.write method.","self . stdout . write ( self . style . NOTICE ( "" Your models have changes that are not yet reflected in a migration, and so won't be applied."" ) )"
"call the method self.style.NOTICE with string "" Run 'manage.py makemigrations' to make new migrations, and then re-run 'manage.py migrate' to apply them."" as an argument, use the result as an argument for the call to the self.stdout.write method.","self . stdout . write ( self . style . NOTICE ( "" Run 'manage.py makemigrations' to make new migrations, and then re-run 'manage.py migrate' to apply them."" ) )"
"if not,",else :
"call the executor.migrate method with, targets, plan and fake set to the value under the 'fake' key of options dictionary,","executor . migrate ( targets , plan , fake = options . get ( ""fake"" , False ) )"
"if the 'fake' key doesnt exists set fake to boolean False, as arguments. call the method emit_post_migrate_signal with created_models, self.verbosity, self.interactive and connection.alias as arguments.","emit_post_migrate_signal ( created_models , self . verbosity , self . interactive , connection . alias )"
"define the method migration_progress_callback with self class instance, action, migration and fake set to boolean False as arguments.","def migration_progress_callback ( self , action , migration , fake = False ) :"
"if self.verbosity is greater or equal to integer 1,",if self . verbosity >= 1 :
"if action equals to string ""apply_start"",","if action == ""apply_start"" :"
"call the self.stdout.write method, with string "" Applying %s..."" with '%s' replaced with migration and ending set to '', as arguments.","self . stdout . write ( "" Applying %s..."" % migration , ending = """" )"
flush the output buffer of the self.stdout object.,self . stdout . flush ( )
"otherwise if action equals to string 'apply_success',","elif action == ""apply_success"" :"
"if fake is true,",if fake :
"wrte to the standard output result of the call to the method self.style.MIGRATE_SUCCESS with string "" FAKED"" as a argument.","self . stdout . write ( self . style . MIGRATE_SUCCESS ( "" FAKED"" ) )"
"if not,",else :
"wrte to the standard output result of the call to the method self.style.MIGRATE_SUCCESS with string "" OK"" as a argument.","self . stdout . write ( self . style . MIGRATE_SUCCESS ( "" OK"" ) )"
otherwise if action equals to string 'unapply_start'.,"elif action == ""unapply_start"" :"
"call the self.stdout.write method, with string "" Unapplying %s..."" with '%s' replaced with migration and ending set to '', as arguments.","self . stdout . write ( "" Unapplying %s..."" % migration , ending = """" )"
flush the output buffer of the self.stdout object.,self . stdout . flush ( )
"otherwise if action equals to string ""unapply_success"".","elif action == ""unapply_success"" :"
"if fake is true,",if fake :
"wrte to the standard output result of the call to the method self.style.MIGRATE_SUCCESS with string "" FAKED"" as a argument.","self . stdout . write ( self . style . MIGRATE_SUCCESS ( "" FAKED"" ) )"
"if not,",else :
"wrte to the standard output result of the call to the method self.style.MIGRATE_SUCCESS with string "" OK"" as a argument.","self . stdout . write ( self . style . MIGRATE_SUCCESS ( "" OK"" ) )"
"define the method sync_apps with self class instance, connection and app_labels as arguments.","def sync_apps ( self , connection , app_labels ) :"
"call the connection.cursor method, substitute the result for cursor.",cursor = connection . cursor ( )
"try,",try :
"call the connection.introspection.table_names with cursor as argument, store the result in tables.",tables = connection . introspection . table_names ( cursor )
"call the connection.introspection.table_names with tables as argument, store the result in seen_models.",seen_models = connection . introspection . installed_models ( tables )
created_models is a set.,created_models = set ( )
pending_references is a empty dictionary.,pending_references = { }
"for every app_config in return value of the method apps.get_app_configs if app_config.models_module is not None,","all_models = [ ( app_config . label , router . get_migratable_models ( app_config , connection . alias , include_auto_created = True ) ) for app_config in apps . get_app_configs ( ) if app_config . models_module is not None and app_config . label in app_labels ]"
"and app_config.label is contained in app_labels, create a tuple containing app_config.label and return value of the method router.get_migratable_models called with app_config, connection.alias and include_auto_created set to True, append the tuple to the list all_models. define the method model_installed with model as an argument.",def model_installed ( model ) :
substitute model._meta for opts.,opts = model . _meta
substitute connection.introspection.table_name_converter for converter.,converter = connection . introspection . table_name_converter
"evaluate next boolean expression, value of converter function with opts.db_table as argument is contained in tables,",return not ( ( converter ( opts . db_table ) in tables ) or ( opts . auto_created and converter ( opts . auto_created . _meta . db_table ) in tables ) )
"or opts.auto_created is True and return value of converter function with opts.auto_created._meta.db_table is contained in tables, invert the evaluated expression and return it. manifest is OrderDict class instance, created with tuple of two elements, app_name and list of elements of model_list for which model_installed function returned true, for every app_name and model_list in all_modules.","manifest = OrderedDict ( ( app_name , list ( filter ( model_installed , model_list ) ) ) for app_name , model_list in all_models )"
"unpack the manifest.values function return value and feed it to the itertools.chain function, create_models is a set containing chanied list.",create_models = set ( itertools . chain ( * manifest . values ( ) ) )
"call the emit_pre_migrate_signal with create_models, self.verbosity, self.interactive. connection.alias as arguments.","emit_pre_migrate_signal ( create_models , self . verbosity , self . interactive , connection . alias )"
"if self.verbosity is greater or equal than integer 1,",if self . verbosity >= 1 :
"write the string "" Creating tables...\n"" to the standard output.","self . stdout . write ( "" Creating tables...\n"" )"
"with the call to the transaction.atomic method with using set to connection.alias, savepoint set to connection.features.can_rollback_ddl as arguments,","with transaction . atomic ( using = connection . alias , savepoint = connection . features . can_rollback_ddl ) :"
"for every app_name and model_list in return value of manifest.items function,","for app_name , model_list in manifest . items ( ) :"
"for every model in model_list,",for model in model_list :
"if self.verbosity is greater or equal to 3,",if self . verbosity >= 3 :
"call the self.stdout.write method with string "" Processing %s.%s model\n"" as argument, with all occurrences of '%s' replaced with,","self . stdout . write ( "" Processing %s.%s model\n"" % ( app_name , model . _meta . object_name ) )"
"app_name and model._meta.object_name, respectively. evaluate connection.creation.sql_create_model method with model, no_style() and seen_models as arguments,","sql , references = connection . creation . sql_create_model ( model , no_style ( ) , seen_models )"
"assign the result to the sql and references, respectively. add model to seen_models set.",seen_models . add ( model )
add model to created_models set.,created_models . add ( model )
for every refto and refs in return value of references.items method.,"for refto , refs in references . items ( ) :"
"call the method extend with refs as argument, on the result call the pending_references.setdefault method with refto and empty list as arguments.","pending_references . setdefault ( refto , [ ] ) . extend ( refs )"
"if refto is contained in seen_models,",if refto in seen_models :
"call the connection.creation.sql_for_pending_references method with refto, no_style() and pending_references as arguments,","sql . extend ( connection . creation . sql_for_pending_references ( refto , no_style ( ) , pending_references ) )"
"use the result as the argument for the call to the sql.extend method. call the connection.creation.sql_for_pending_references method with refto, no_style() and pending_references as arguments,","sql . extend ( connection . creation . sql_for_pending_references ( model , no_style ( ) , pending_references ) )"
"use the result as the argument for the call to the sql.extend method. if self.verbosity is greater or equal than integer 1 and sql is true,",if self . verbosity >= 1 and sql :
"call the self.stdout.write method with string "" Creating table %s\n"" as argument, with all occurrences of '%s' replaced with model._meta.db_table.","self . stdout . write ( "" Creating table %s\n"" % model . _meta . db_table )"
"for statements is sql,",for statement in sql :
call the cursor.execute method with statement as argument.,cursor . execute ( statement )
"evaluate the method connection.introspection.table_name_converter with model._meta.db_table as argument, append it to tables.",tables . append ( connection . introspection . table_name_converter ( model . _meta . db_table ) )
"finally, perform,",finally :
call the cursor.close method.,cursor . close ( )
"call the connection.cursor method, substitute it for cursor.",cursor = connection . cursor ( )
"try,",try :
"if self.verbosity is greater or equal than integer 1,",if self . verbosity >= 1 :
"write the string "" Installing custom SQL...\n"" to the standard output.","self . stdout . write ( "" Installing custom SQL...\n"" )"
"for every app_name and mode_list in return value of manifest.items method,","for app_name , model_list in manifest . items ( ) :"
"for model in model_list,",for model in model_list :
"if model is contained in created_models,",if model in created_models :
"call the method custom_sql_for_model with model, no_style() and connection as arguments, substitute the result for custom_sql.","custom_sql = custom_sql_for_model ( model , no_style ( ) , connection )"
"if custom_sql is empty,",if custom_sql :
"if self.verbosity is greater or equal to integer 2,",if self . verbosity >= 2 :
"call the self.stdout.write method with string "" Installing custom SQL for %s.%s model\n"" as argument,","self . stdout . write ( "" Installing custom SQL for %s.%s model\n"" % ( app_name , model . _meta . object_name ) )"
"with all occurrences of '%s' replaced with app_name and model._meta.object_name, respectively. try,",try :
"with call to the function transaction.atomic with using set to connection.alias as argument,",with transaction . atomic ( using = connection . alias ) :
"for every sql in custom_sql,",for sql in custom_sql :
call the cursor.execute method with sql as argument.,cursor . execute ( sql )
"if exception of class Exception, as e, is caught,",except Exception as e :
"call the self.stderr.write method with string "" Failed to install custom SQL for %s.%s model: %s\n"" as argument,","self . stderr . write ( "" Failed to install custom SQL for %s.%s model: %s\n"" % ( app_name , model . _meta . object_name , e ) )"
"with all occurrences of '%s' replaced with app_name and model._meta.object_name and e, respectively. if self.show_traceback is true,",if self . show_traceback :
call the traceback.print_exc method.,traceback . print_exc ( )
"if not,",else :
"if self.verbosity is greater or equal to integer 3,",if self . verbosity >= 3 :
"call the self.stderr.write method with string "" No custom SQL for %s.%s model\n"" as argument,","self . stdout . write ( "" No custom SQL for %s.%s model\n"" % ( app_name , model . _meta . object_name ) )"
"with all occurrences of '%s' replaced with app_name and model._meta.object_name, respectively. if self.verbosity is greater or equal to integer 1,",if self . verbosity >= 1 :
"write string "" Installing indexes...\n"" to the standard output.","self . stdout . write ( "" Installing indexes...\n"" )"
"for every app_name and model_list in return value of manifest.items method,","for app_name , model_list in manifest . items ( ) :"
"for every model in model_list,",for model in model_list :
"if model is contained in created_models,",if model in created_models :
"call the connection.creation.sql_indexes_for_model with model and no_style() as arguments, substitute the result for index_squl.","index_sql = connection . creation . sql_indexes_for_model ( model , no_style ( ) )"
"if index_sql is not empty,",if index_sql :
"if self.verbosity is greater or equal to integer 2,",if self . verbosity >= 2 :
"call the self.stderr.write method with string "" Installing index for %s.%s model\n"" as argument,","self . stdout . write ( "" Installing index for %s.%s model\n"" % ( app_name , model . _meta . object_name ) )"
"with all occurrences of '%s' replaced with app_name and model._meta.object_name, respectively. try,",try :
"with call to the function transaction.atomic with using set to connection.alias and savepoint set to connection.features.can_rollback_ddl, as arguments.","with transaction . atomic ( using = connection . alias , savepoint = connection . features . can_rollback_ddl ) :"
"for every sql in index_sql,",for sql in index_sql :
call the method cursor.execute with sql as argument.,cursor . execute ( sql )
"if exception of the class Exception, as e, is caught,",except Exception as e :
"call the self.stderr.write method with string "" Failed to install index for %s.%s model: %s\n"" as argument,","self . stderr . write ( "" Failed to install index for %s.%s model: %s\n"" % ( app_name , model . _meta . object_name , e ) )"
"with all occurrences of '%s' replaced with app_name and model._meta.object_name and e, respectively. finally perform,",finally :
call the cursor.close method.,cursor . close ( )
"if self.load_initial_data is not empty,",if self . load_initial_data :
"for every app_label in app_labels,",for app_label in app_labels :
"call the method call_command with string 'loaddata', string 'initial_data', verbosity set to self.verbosity,","call_command ( 'loaddata' , 'initial_data' , verbosity = self . verbosity , database = connection . alias , skip_validation = True , app_label = app_label , hide_empty = True )"
"database set to connection.alias, skip_validation set to boolean True, app_label set to app_label and hide_empty set to boolean True. return created_models",return created_models
"define show_migration_list with self class instance, connection and app_names set to None, as arguments.","def show_migration_list ( self , connection , app_names = None ) :"
loader is instance of MigrationLoader initialized with connection as an argument.,loader = MigrationLoader ( connection )
substitute loader.graph for graph.,graph = loader . graph
"if app_names is not empty,",if app_names :
invalid_apps is an empty list.,invalid_apps = [ ]
"for every app_name is app_names,",for app_name in app_names :
"if app_name is not contained in loader.migrated_apps,",if app_name not in loader . migrated_apps :
append app_name to the invalid_apps.,invalid_apps . append ( app_name )
"if invalid_apps in not empty,",if invalid_apps :
"raise a CommandError exception, with string ""No migrations present for: %s"" as argument, substitute '%s' in previous string with,","raise CommandError ( ""No migrations present for: %s"" % ( "", "" . join ( invalid_apps ) ) )"
"string joined from invalided_apps list and separated with string ', '. if not,",else :
"sort loader.migrated_apps, substitute it for app_names.",app_names = sorted ( loader . migrated_apps )
for every app_name in app_names.,for app_name in app_names :
call self.stdout.write method with app_name and self.style.MIGRATE_LABEL as arguments.,"self . stdout . write ( app_name , self . style . MIGRATE_LABEL )"
shown is an empty set.,shown = set ( )
"for every node in return value of the graph.leaf_nodes method called with the app_name argument,",for node in graph . leaf_nodes ( app_name ) :
for every plan_node in return value of the graph.forwards_plan method called with node as argument.,for plan_node in graph . forwards_plan ( node ) :
"if plan_node is not contained in shown and first element of plan_node equals to app_name,",if plan_node not in shown and plan_node [ 0 ] == app_name :
substitute second element of plan_node for title.,title = plan_node [ 1 ]
"if replaces filed of graph.nodes element at the plan_node index is true,",if graph . nodes [ plan_node ] . replaces :
"substitute '%s' in the string "" (%s squashed migrations)"" with length of replaces filed of graph.nodes element at the plan_node index, append the string to the title.","title += "" (%s squashed migrations)"" % len ( graph . nodes [ plan_node ] . replaces )"
"if plan_node is contained in loader.applied_migrations,",if plan_node in loader . applied_migrations :
"substitute '%s' with title in the string "" [X] %s"", write it to the standard output.","self . stdout . write ( "" [X] %s"" % title )"
"if not,",else :
"substitute '%s' with title in the string "" [ ] %s"", write it to the standard output.","self . stdout . write ( "" [ ] %s"" % title )"
add plan_node to the shown set.,shown . add ( plan_node )
"if shown is an empty set,",if not shown :
"call the self.stdout.write method with string "" (no migrations)"" and self.style.MIGRATE_FAILURE as arguments.","self . stdout . write ( "" (no migrations)"" , self . style . MIGRATE_FAILURE )"
import module argparse.,import argparse
import module warnings.,import warnings
from django.core.management.base import BaseCommand into default name space.,from django . core . management . base import BaseCommand
from django.utils.deprecation import RemovedInDjango19Warning into default name space.,from django . utils . deprecation import RemovedInDjango19Warning
derive the class Command from the BaseCommand class.,class Command ( BaseCommand ) :
"help is a string ""Runs this project as a FastCGI application. Requires flup."".","help = ""Runs this project as a FastCGI application. Requires flup."""
define the method add_arguments with 2 arguments self and parser.,"def add_arguments ( self , parser ) :"
"call the method parser.add_argument with 3 arguments: string 'args', nargs set to argparse.REMAINDER and help as a string 'Various KEY=val options.'","parser . add_argument ( 'args' , nargs = argparse . REMAINDER , help = 'Various KEY=val options.' )"
"define the method handle with 3 arguments: self, unpacked list args and unpacked dictionary options.","def handle ( self , * args , ** options ) :"
"call the method warnings.warn with 2 arguments: string ""FastCGI support has been deprecated and will be removed in Django 1.9."",","warnings . warn ( ""FastCGI support has been deprecated and will be removed in Django 1.9."" , RemovedInDjango19Warning )"
and RemovedInDjango19Warning. from django.conf import settings into default namespace.,from django . conf import settings
from django.utils import translation into default namespace.,from django . utils import translation
"try,",try :
call the method translation.activate with an argument settings.LANGUAGE_CODE.,translation . activate ( settings . LANGUAGE_CODE )
"if AttributeError exception is caught,",except AttributeError :
do nothing.,pass
from django.core.servers.fastcgi import runfastcgi into default namespace.,from django . core . servers . fastcgi import runfastcgi
call the function runfastcgi with an argument args.,runfastcgi ( args )
define the method usage with 2 argument: self and subcommand.,"def usage ( self , subcommand ) :"
from django.core.servers.fastcgi import FASTCGI_HELP into default namespace.,from django . core . servers . fastcgi import FASTCGI_HELP
return FASTCGI_HELP.,return FASTCGI_HELP
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
from datetime import datetime into default name space.,from datetime import datetime
import module errno.,import errno
import module os.,import os
import module re.,import re
import module sys.,import sys
import module socket.,import socket
from django.core.management.base import BaseCommand and CommandError into default name space.,"from django . core . management . base import BaseCommand , CommandError"
from django.core.servers.basehttp import run and get_internal_wsgi_application into default name space.,"from django . core . servers . basehttp import run , get_internal_wsgi_application"
from django.db import connections and DEFAULT_DB_ALIAS into default name space.,"from django . db import connections , DEFAULT_DB_ALIAS"
from django.db.migrations.executor import MigrationExecutor into default name space.,from django . db . migrations . executor import MigrationExecutor
from django.utils import autoreload into default name space.,from django . utils import autoreload
from django.utils import six into default name space.,from django . utils import six
from django.core.exceptions import ImproperlyConfigured into default name space.,from django . core . exceptions import ImproperlyConfigured
"call the method re.compile with 2 arguments: raw string """"""^(?: (?P<addr> (?P<ipv4>\d{1,3}(?:\.\d{1,3}){3}) |""""""","naiveip_re = re . compile ( r""""""^(?: (?P<addr> (?P<ipv4>\d{1,3}(?:\.\d{1,3}){3}) | # IPv4 address (?P<ipv6>\[[a-fA-F0-9:]+\]) | # IPv6 address (?P<fqdn>[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*) # FQDN ):)?(?P<port>\d+)$"""""" , re . X )"
"""""""(?P<ipv6>\[[a-fA-F0-9:]+\]) | (?P<fqdn>[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*) ):)?(?P<port>\d+)$"""""", re.X DEFAULT_PORT is a string ""8000"".","DEFAULT_PORT = ""8000"""
derive the class Command from the BaseCommand class.,class Command ( BaseCommand ) :
"help is a string ""Starts a lightweight Web server for development."".","help = ""Starts a lightweight Web server for development."""
requires_system_checks is boolean False.,requires_system_checks = False
define the method add_arguments with 2 arguments self and parser.,"def add_arguments ( self , parser ) :"
"call the method parser.add_argument with 3 arguments: string 'addrport', nargs='?' and help as a string 'Optional port number, or ipaddr:port'.","parser . add_argument ( 'addrport' , nargs = '?' , help = 'Optional port number, or ipaddr:port' )"
"call the method parser.add_argument with 6 arguments: string '--ipv6', string '-6', action set to string 'store_true',","parser . add_argument ( '--ipv6' , '-6' , action = 'store_true' , dest = 'use_ipv6' , default = False , help = 'Tells Django to use an IPv6 address.' )"
"dest set to string 'use_ipv6', default set to boolean False and help set to string 'Tells Django to use an IPv6 address.'. call the method parser.add_argument with 5 arguments: string '--nothreading', action set to string 'store_false',","parser . add_argument ( '--nothreading' , action = 'store_false' , dest = 'use_threading' , default = True , help = 'Tells Django to NOT use threading.' )"
"dest set to string 'use_threading', default set to boolean True and help set to 'Tells Django to NOT use threading.'. call the method parser.add_argument with 5 arguments: string '--noreload', action set to string 'store_false',","parser . add_argument ( '--noreload' , action = 'store_false' , dest = 'use_reloader' , default = True , help = 'Tells Django to NOT use the auto-reloader.' )"
"dest set to string 'use_reloader', default set to boolean True and help is a string 'Tells Django to NOT use the auto-reloader.'. def get_handler with 3 arguments: self, unpacked list args and unpacked dictionary options.","def get_handler ( self , * args , ** options ) :"
"call the function get_internal_wsgi_application, return the result.",return get_internal_wsgi_application ( )
"define the method handle with 3 arguments: self, unpacked list args and unpacked dictionary options.","def handle ( self , * args , ** options ) :"
from django.conf import settings into default namespace.,from django . conf import settings
"if not settings.DEBUG is true and settings.ALLOWED_HOSTS is false,",if not settings . DEBUG and not settings . ALLOWED_HOSTS :
raise an CommandError exception with an argument string 'You must set settings.ALLOWED_HOSTS if DEBUG is False.'.,raise CommandError ( 'You must set settings.ALLOWED_HOSTS if DEBUG is False.' )
substitute value under the 'use_ipv6' key of the options dictionary for self.use_ipv6.,self . use_ipv6 = options . get ( 'use_ipv6' )
"if self.use_ipv6 is true and socket.has_ipv6 is false,",if self . use_ipv6 and not socket . has_ipv6 :
raise an CommandError exception with an argument string 'Your Python does not support IPv6.'.,raise CommandError ( 'Your Python does not support IPv6.' )
self._raw_ipv6 is boolean False.,self . _raw_ipv6 = False
"get the value under the 'addrport' key of the options dictionary, if it is false,",if not options . get ( 'addrport' ) :
self.addr is an empty string.,self . addr = ''
substitute DEFAULT_PORT for self.port.,self . port = DEFAULT_PORT
"if not,",else :
"call the method re.match with 2 arguments: naiveip_re and value under the 'addrport' key of the options dictionary, substitute the result for m.","m = re . match ( naiveip_re , options [ 'addrport' ] )"
"if m is None,",if m is None :
"raise an CommandError exception with an argument string '""%s"" is not a valid port number or address:port pair.',","raise CommandError ( '""%s"" is not a valid port number ' 'or address:port pair.' % options [ 'addrport' ] )"
"where '%s' is replaced with value under the 'addrport' key of the options dictionary. call the method m.groups, assign the result to self.addr, _ipv4, _ipv6, _fqdn and self.port, respectively.","self . addr , _ipv4 , _ipv6 , _fqdn , self . port = m . groups ( )"
"call the method self.port.isdigit, if it evaluates to false,",if not self . port . isdigit ( ) :
"raise an CommandError exception with an argument string ""%r is not a valid port number."", where '%r' is repaced with self.port.","raise CommandError ( ""%r is not a valid port number."" % self . port )"
"if self.addr is true,",if self . addr :
"if _ipv6 is true,",if _ipv6 :
substitute self.addr without the first and last element for self.addr.,self . addr = self . addr [ 1 : - 1 ]
self.use_ipv6 is boolean True.,self . use_ipv6 = True
self._raw_ipv6 is boolean True.,self . _raw_ipv6 = True
"otherwise if self.use_ipv6 is true and _fqdn is false,",elif self . use_ipv6 and not _fqdn :
"raise an CommandError exception with an argument string '""%s"" is not a valid IPv6 address.' where '%s' is replaced with self.addr.","raise CommandError ( '""%s"" is not a valid IPv6 address.' % self . addr )"
"if self.addr is false,",if not self . addr :
"if self.use_ipv6 substitute string '::1' for self.addr, if not substitute '127.0.0.1' for self.addr.",self . addr = '::1' if self . use_ipv6 else '127.0.0.1'
"convert self.use_ipv6 to boolean, substitute it for self._raw_ipv6.",self . _raw_ipv6 = bool ( self . use_ipv6 )
call the self.run method with unpacked dictionary options as an argument.,self . run ( ** options )
define the method run with 3 arguments: self and unpacked dictionary options.,"def run ( self , ** options ) :"
substitute value under the 'use_reloader' key of the options dictionary for use_reloader.,use_reloader = options . get ( 'use_reloader' )
"if use_reloader is true,",if use_reloader :
"call the method autoreload.main with 3 arguments: self.inner_run, None and options.","autoreload . main ( self . inner_run , None , options )"
"if not,",else :
call the method self.inner_run with 2 arguments: None and unpacked dictionary options.,"self . inner_run ( None , ** options )"
"define the method inner_run with 3 arguments: self, unpacked list args and unpacked dictionary options.","def inner_run ( self , * args , ** options ) :"
from django.conf import settings into default namespace.,from django . conf import settings
django.utils import translation into default namespace.,from django . utils import translation
substitute value under the 'use_threading' key of the options dictionary for threading.,threading = options . get ( 'use_threading' )
"get the value under the 'shutdown_message' key of the options dictionary, if it exists substitute it for shutdown_message,","shutdown_message = options . get ( 'shutdown_message' , '' )"
"if not, shutdown_message is an empty string. if sys.platform equals string win32', substitute string 'CTRL-BREAK' for quit_command, if not substitute string 'CONTROL-C' for quit_command.",quit_command = 'CTRL-BREAK' if sys . platform == 'win32' else 'CONTROL-C'
"write string ""Performing system checks...\n\n"" to self.stdout stream.","self . stdout . write ( ""Performing system checks...\n\n"" )"
call the method self.validate with an argument display_num_errors set to boolean True.,self . validate ( display_num_errors = True )
"try,",try :
call the method self.check_migrations.,self . check_migrations ( )
"if ImproperlyConfigured exception is caught,",except ImproperlyConfigured :
do nothing.,pass
"call the function datetime.now, on the result call the method strftime with an argument string '%B %d, %Y - %X', substitute the result for now.","now = datetime . now ( ) . strftime ( '%B %d, %Y - %X' )"
"if six.PY2 is true,",if six . PY2 :
"call the method now.decode with an argument string 'utf-8', substitute the result for now.",now = now . decode ( 'utf-8' )
"call the method self.stdout.write with an argument: string ""%(started_at)s\nDjango version %(version)s, using settings %(settings)r\n""","self . stdout . write ( ( ""%(started_at)s\n"" ""Django version %(version)s, using settings %(settings)r\n"" ""Starting development server at http://%(addr)s:%(port)s/\n"" ""Quit the server with %(quit_command)s.\n"" ) % { ""started_at"" : now , ""version"" : self . get_version ( ) , ""settings"" : settings . SETTINGS_MODULE , ""addr"" : '[%s]' % self . addr if self . _raw_ipv6 else self . addr , ""port"" : self . port , ""quit_command"" : quit_command , } )"
"""Starting development server at http://%(addr)s:%(port)s/\n Quit the server with %(quit_command)s.\n"", where '""%(started_at)s' is replaced with now, '%(version)s' is replaced with return value of the method self.get_version, '%(settings)r' is replaced with settings.SETTINGS_MODULE, '%(addr)s' is replaced with self.addr if self._raw_ipv6 is true, or with self.addr if it is false, '%(port)s' is replaced with self.port and '%(quit_command)s' is replaced with quit_command. call the method translation.activate with an argument settings.LANGUAGE_CODE.",translation . activate ( settings . LANGUAGE_CODE )
"try,",try :
"call the method self.get_handler with 2 arguments unpacked list args and unpacked dictionary options, substitute the result for handler.","handler = self . get_handler ( * args , ** options )"
"call the function run with 5 arguments: self.addr, self.port converted to an integer, handler, ipv6 set to self.use_ipv6, and threading set to threading.","run ( self . addr , int ( self . port ) , handler , ipv6 = self . use_ipv6 , threading = threading )"
"if socket.error, renamed to e, exception is caught,",except socket . error as e :
"ERRORS is a dictionary with 3 initial entries: string ""You don't have permission to access that port."" for errno.EACCES,","ERRORS = { errno . EACCES : ""You don't have permission to access that port."" , errno . EADDRINUSE : ""That port is already in use."" , errno . EADDRNOTAVAIL : ""That IP address can't be assigned-to."" , }"
"""That port is already in use."" for errno.EADDRINUSE and ""That IP address can't be assigned-to."" for errno.EADDRNOTAVAIL. try,",try :
"get the value under the e.errno key of the ERRORS dictionary, substitute it for error_text.",error_text = ERRORS [ e . errno ]
if KeyError exception is caught.,except KeyError :
"convert e to a string, substitute it for error_text.",error_text = str ( e )
"replace '%s' in a string ""Error: %s"" with error_text, write it to self.stderr.","self . stderr . write ( ""Error: %s"" % error_text )"
exit the program with the code integer 1.,os . _exit ( 1 )
"if KeyboardInterrupt exception is caught,",except KeyboardInterrupt :
"if shutdown_message is true,",if shutdown_message :
write shutdown_message to self.stdout file stream.,self . stdout . write ( shutdown_message )
exit program with code integer 0.,sys . exit ( 0 )
define the method check_migrations with an argument self.,def check_migrations ( self ) :
executor is an instance of the class MigrationExecutor created with an argument: value under the DEFAULT_DB_ALIAS key of the connections dictionary.,executor = MigrationExecutor ( connections [ DEFAULT_DB_ALIAS ] )
"call the method executor.migration_plan wiht return value of te method executor.loader.graph.leaf_nodes as argument, substitute it for plan.",plan = executor . migration_plan ( executor . loader . graph . leaf_nodes ( ) )
"if plan is true,",if plan :
call the method self.style.NOTICE with an argument:,"self . stdout . write ( self . style . NOTICE ( ""\nYou have unapplied migrations; your app may not work properly until they are applied."" ) )"
"string: ""\nYou have unapplied migrations; your app may not work properly until they are applied."", write it to self.stdout. call the method self.style.NOTICE with an argument string ""Run 'python manage.py migrate' to apply them.\n"",","self . stdout . write ( self . style . NOTICE ( ""Run 'python manage.py migrate' to apply them.\n"" ) )"
write it to self.stdout. substitute Command for BaseRunserverCommand.,BaseRunserverCommand = Command
import module os.,import os
from django.core.management.base import BaseCommand into default name space.,from django . core . management . base import BaseCommand
derive the class Command from the BaseCommand class.,class Command ( BaseCommand ) :
"help is a string ""Runs a Python interactive interpreter. Tries to use IPython or bpython, if one of them is available."".","help = ""Runs a Python interactive interpreter. Tries to use IPython or bpython, if one of them is available."""
requires_system_checks is boolean False.,requires_system_checks = False
shells is a list containing 2 elements: string 'ipython' and string 'bpython'.,"shells = [ 'ipython' , 'bpython' ]"
define the method add_arguments with 2 arguments self and parser.,"def add_arguments ( self , parser ) :"
"call the method parser.add_argument with 4 arguments: string '--plain', action set to string 'store_true', dest as a string 'plain',","parser . add_argument ( '--plain' , action = 'store_true' , dest = 'plain' , help = 'Tells Django to use plain Python, not IPython or bpython.' )"
"and help is a string 'Tells Django to use plain Python, not IPython or bpython.'. call the method parser.add_argument with 4 arguments: string '--no-startup', action as a string 'store_true',","parser . add_argument ( '--no-startup' , action = 'store_true' , dest = 'no_startup' , help = 'When using plain Python, ignore the PYTHONSTARTUP environment variable and ~/.pythonrc.py script.' )"
"dest as a string 'no_startup' and help as a string 'When using plain Python, ignore the PYTHONSTARTUP environment variable and ~/.pythonrc.py script.'. call the method parser.add_argument with 5 arguments: string '-i', string '--interface', choices set to string self.shells,","parser . add_argument ( '-i' , '--interface' , choices = self . shells , dest = 'interface' , help = 'Specify an interactive interpreter interface. Available options: ""ipython"" and ""bpython""' )"
"dest as a string 'interface' and help as a string 'Specify an interactive interpreter interface. Available options: ""ipython"" and ""bpython""'. define the method _ipython_pre_011 with an argument self.",def _ipython_pre_011 ( self ) :
from IPython.Shell import IPShell into default namespace.,from IPython . Shell import IPShell
"shell is an instance of IPShell class, created with an argument argv as an empty list.",shell = IPShell ( argv = [ ] )
call the method shell.mainloop.,shell . mainloop ( )
define the method _ipython_pre_100 with an argument self.,def _ipython_pre_100 ( self ) :
from IPython.frontend.terminal.ipapp import TerminalIPythonApp into default namespace.,from IPython . frontend . terminal . ipapp import TerminalIPythonApp
"call the method instance of TerminalIPythonApp class, substitute the result for app.",app = TerminalIPythonApp . instance ( )
call the method app.initialize with an argument argv as an empty list.,app . initialize ( argv = [ ] )
call the method app.start.,app . start ( )
define the method _ipython with an argument self.,def _ipython ( self ) :
from IPython import start_ipython into default namespace.,from IPython import start_ipython
call the method start_ipython with an argument argv as an empty list.,start_ipython ( argv = [ ] )
define the method ipython with an argument self.,def ipython ( self ) :
"for every ip in tuple containing 3 elements: self._ipython, self._ipython_pre_100 and self._ipython_pre_011,","for ip in ( self . _ipython , self . _ipython_pre_100 , self . _ipython_pre_011 ) :"
"try,",try :
call the function ip.,ip ( )
"if ImportError exception is caught,",except ImportError :
do nothing.,pass
"if not,",else :
return nothing.,return
"raise an ImportError exception with an argument string ""No IPython"".","raise ImportError ( ""No IPython"" )"
define the method bpython with an argument self.,def bpython ( self ) :
import bpython.,import bpython
call the method bpython.embed.,bpython . embed ( )
define the method run_shell with an arguments self and shell set to None.,"def run_shell ( self , shell = None ) :"
"if shell is true substitute list with element shell for available_shells, if not substitute self.shells for available_shells.",available_shells = [ shell ] if shell else self . shells
"for every shell in available_shells,",for shell in available_shells :
"try,",try :
"get shell attribute of the self object, call it and return the result.","return getattr ( self , shell ) ( )"
"if ImportError exception is caught,",except ImportError :
do nothing.,pass
raise an ImportError exception.,raise ImportError
define the method handle with 3 arguments: self and unpacked dictionary options.,"def handle ( self , ** options ) :"
"try,",try :
"if value under 'plain' key of the options dictionary is true,",if options [ 'plain' ] :
raise an ImportError exception.,raise ImportError
call the method self.run_shell with an argument shell set to value under the 'interface' key of the options dictionary.,self . run_shell ( shell = options [ 'interface' ] )
"if ImportError exception is caught,",except ImportError :
import code.,import code
imported_objects is an empty dictionary.,imported_objects = { }
"try,",try :
import readline.,import readline
"if ImportError exception is caught,",except ImportError :
do nothing.,pass
"if not,",else :
import rlcompleter.,import rlcompleter
"call the method rlcompleter.Completer with an argument imported_objects, use the complete field of the result as an argument for the call to the method readline.set_completer.",readline . set_completer ( rlcompleter . Completer ( imported_objects ) . complete )
"call the method readline.parse_and_bind with an argument string ""tab:complete"".","readline . parse_and_bind ( ""tab:complete"" )"
"get the value under the 'no_startup' key of the options dictionary, if it evaluates to false,",if not options [ 'no_startup' ] :
"for every pythonrc in tuple containing 2 elements: return value of the function os.environ.get called with a string ""PYTHONSTARTUP"",","for pythonrc in ( os . environ . get ( ""PYTHONSTARTUP"" ) , '~/.pythonrc.py' ) :"
"and string '~/.pythonrc.py' as tuples second element. if pythonrc is true,",if not pythonrc :
skip this loop iteration.,continue
"call the function os.path.expanduser with an argument pythonrc, substitute the result for pythonrc.",pythonrc = os . path . expanduser ( pythonrc )
"if pythonrc is not a file,",if not os . path . isfile ( pythonrc ) :
skip this loop iteration.,continue
"try,",try :
"open pythonrc, with the file handle renamed to handle perform the following,",with open ( pythonrc ) as handle :
"compile the handle.read in mode 'exec' source is read from file pythonrc, execute the compiled script with imported_objects variables.","exec ( compile ( handle . read ( ) , pythonrc , 'exec' ) , imported_objects )"
"if NameError exception is caught,",except NameError :
do nothing.,pass
call the method code.interact with an argument local set to imported_objects.,code . interact ( local = imported_objects )
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
from django.core.management.base import AppCommand into default name space.,from django . core . management . base import AppCommand
from django.core.management.sql import sql_create into default name space.,from django . core . management . sql import sql_create
from django.db import connections and DEFAULT_DB_ALIAS into default name space.,"from django . db import connections , DEFAULT_DB_ALIAS"
derive the class Command from the AppCommand base class.,class Command ( AppCommand ) :
"help is a string ""Prints the CREATE TABLE SQL statements for the given app name(s)."".","help = ""Prints the CREATE TABLE SQL statements for the given app name(s)."""
output_transaction is boolean True.,output_transaction = True
define the method add_arguments with 2 arguments self and parser.,"def add_arguments ( self , parser ) :"
"call the method add_arguments from the base class of the class Command, with an argument parser.","super ( Command , self ) . add_arguments ( parser )"
"call the method parser.add_argument with 3 arguments: string '--database', default set to DEFAULT_DB_ALIAS,","parser . add_argument ( '--database' , default = DEFAULT_DB_ALIAS , help = 'Nominates a database to print the SQL for. Defaults to the ' '""default"" database.' )"
"and help set to a string 'Nominates a database to print the SQL for. Defaults to the ""default"" database.'. define the method handle_app_config with 3 arguments: self, app_config and unpacked dictionary options.","def handle_app_config ( self , app_config , ** options ) :"
"if app_config.models_module is None,",if app_config . models_module is None :
return nothing.,return
"get the value under the 'database' key of the options dictionary, use it as the key to get the value from the connections dictionary, substitute the result for connection.",connection = connections [ options [ 'database' ] ]
"call the function sql_create with 3 arguments: app_config, self.style and connection, substitute the result for statements.","statements = sql_create ( app_config , self . style , connection )"
"join statements into a string, separated by newlines, return it.",return '\n' . join ( statements )
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
from django.core.management.base import AppCommand into default name space.,from django . core . management . base import AppCommand
from django.core.management.sql import sql_all into default name space.,from django . core . management . sql import sql_all
from django.db import connections and DEFAULT_DB_ALIAS into default name space.,"from django . db import connections , DEFAULT_DB_ALIAS"
derive the class Command from the AppCommand base class.,class Command ( AppCommand ) :
"help is a string ""Prints the CREATE TABLE, custom SQL and CREATE INDEX SQL statements for the given model module name(s)."".","help = ""Prints the CREATE TABLE, custom SQL and CREATE INDEX SQL statements for the given model module name(s)."""
output_transaction is boolean True.,output_transaction = True
define the method add_arguments with 2 arguments self and parser.,"def add_arguments ( self , parser ) :"
"call the method add_arguments from the base class of the class Command, with an argument parser.","super ( Command , self ) . add_arguments ( parser )"
"call the method parser.add_argument with 3 arguments: string '--database', default set to DEFAULT_DB_ALIAS,","parser . add_argument ( '--database' , default = DEFAULT_DB_ALIAS , help = 'Nominates a database to print the SQL for. Defaults to the ' '""default"" database.' )"
"and help set to a string 'Nominates a database to print the SQL for. Defaults to the ""default"" database.'. define the method handle_app_config with 3 arguments: self, app_config and unpacked dictionary options.","def handle_app_config ( self , app_config , ** options ) :"
"if app_config.models_module is None,",if app_config . models_module is None :
return nothing.,return
"get the value under the 'database' key of the options dictionary, use it as the key to get the value from the connections dictionary, substitute the result for connection.",connection = connections [ options [ 'database' ] ]
"call the function sql_all with 3 arguments: app_config, self.style and connection, substitute the result for statements.","statements = sql_all ( app_config , self . style , connection )"
"join statements into a string, separated by newlines, return it.",return '\n' . join ( statements )
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
from django.core.management.base import AppCommand into default name space.,from django . core . management . base import AppCommand
from django.core.management.sql import sql_delete into default name space.,from django . core . management . sql import sql_delete
from django.db import connections and DEFAULT_DB_ALIAS into default name space.,"from django . db import connections , DEFAULT_DB_ALIAS"
derive the class Command from the AppCommand base class.,class Command ( AppCommand ) :
"help is a string ""Prints the DROP TABLE SQL statements for the given app name(s)."".","help = ""Prints the DROP TABLE SQL statements for the given app name(s)."""
output_transaction is boolean True.,output_transaction = True
define the method add_arguments with 2 arguments self and parser.,"def add_arguments ( self , parser ) :"
"call the method add_arguments from the base class of the class Command, with an argument parser.","super ( Command , self ) . add_arguments ( parser )"
"call the method parser.add_argument with 3 arguments: string '--database', default set to DEFAULT_DB_ALIAS,","parser . add_argument ( '--database' , default = DEFAULT_DB_ALIAS , help = 'Nominates a database to print the SQL for. Defaults to the ' '""default"" database.' )"
"and help set to a string 'Nominates a database to print the SQL for. Defaults to the ""default"" database.'. define the method handle_app_config with 3 arguments: self, app_config and unpacked dictionary options.","def handle_app_config ( self , app_config , ** options ) :"
"if app_config.models_module is None,",if app_config . models_module is None :
return nothing.,return
"get the value under the 'database' key of the options dictionary, use it as the key to get the value from the connections dictionary, substitute the result for connection.",connection = connections [ options [ 'database' ] ]
"call the function sql_destroy_indexes with 3 arguments: app_config, self.style and connection, substitute the result for statements.","statements = sql_delete ( app_config , self . style , connection )"
"join statements into a string, separated by newlines, return it.",return '\n' . join ( statements )
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
from django.core.management.base import AppCommand into default name space.,from django . core . management . base import AppCommand
from django.core.management.sql import sql_custom into default name space.,from django . core . management . sql import sql_custom
from django.db import connections and DEFAULT_DB_ALIAS into default name space.,"from django . db import connections , DEFAULT_DB_ALIAS"
derive class Command from the base class AppCommand.,class Command ( AppCommand ) :
"help is a string, ""Prints the custom table modifying SQL statements for the given app name(s)."".","help = ""Prints the custom table modifying SQL statements for the given app name(s)."""
substitute True for output_transaction.,output_transaction = True
define method add_arguments with class instance self and parser as the input arguments.,"def add_arguments ( self , parser ) :"
"call the function add_arguments with parser as an argument, from the base class of the Command class.","super ( Command , self ) . add_arguments ( parser )"
"call the parser.add_argument method with the string '--database', default set to DEFAULT_DB_ALIAS and help containig string,","parser . add_argument ( '--database' , default = DEFAULT_DB_ALIAS , help = 'Nominates a database to print the SQL for. Defaults to the ' '""default"" database.' )"
"'Nominates a database to print the SQL for. Defaults to the ""default"" database.' as the arguments. define method handle_app_config with self class instance, app_config and dictionary options as arguments.","def handle_app_config ( self , app_config , ** options ) :"
"if app_config.models_module is None,",if app_config . models_module is None :
return nothing.,return
"extract the value under the key 'database' from the options dictionary, use the value for indexing connections list, substitute the result for connection.",connection = connections [ options [ 'database' ] ]
"call the function sql_custom with app_config, self.style and connection as the arguments, substitute the result for statements.","statements = sql_custom ( app_config , self . style , connection )"
"join the list of statements into a string separated by new lines, return it.",return '\n' . join ( statements )
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
from django.core.management.base import AppCommand into default name space.,from django . core . management . base import AppCommand
from django.core.management.sql import sql_destroy_indexes into default name space.,from django . core . management . sql import sql_destroy_indexes
from django.db import connections and DEFAULT_DB_ALIAS into default name space.,"from django . db import connections , DEFAULT_DB_ALIAS"
derive the class Command from the AppCommand base class.,class Command ( AppCommand ) :
"help is an string ""Prints the DROP INDEX SQL statements for the given model module name(s)."".","help = ""Prints the DROP INDEX SQL statements for the given model module name(s)."""
output_transaction is boolean True.,output_transaction = True
define the method add_arguments with 2 arguments: self and parser.,"def add_arguments ( self , parser ) :"
call the add_arguments method from the base class of the class Command with parser as an argument.,"super ( Command , self ) . add_arguments ( parser )"
"call the method parser.add_argument with 3 arguments: string '--database', default set to DEFAULT_DB_ALIAS,","parser . add_argument ( '--database' , default = DEFAULT_DB_ALIAS , help = 'Nominates a database to print the SQL for. Defaults to the ' '""default"" database.' )"
"and help set to string 'Nominates a database to print the SQL for. Defaults to the ""default"" database.'. define the handle_app_config with 3 arguments self, app_config and unpacked dictionary options.","def handle_app_config ( self , app_config , ** options ) :"
if app_config.models_module is None.,if app_config . models_module is None :
return nothing.,return
"get the value under the 'database' key of the options dictionary, use it as the key to get the value from the connections dictionary, substitute the result for connection.",connection = connections [ options [ 'database' ] ]
"call the function sql_destroy_indexes with 3 arguments: app_config, self.style and connection, substitute the result for statements.","statements = sql_destroy_indexes ( app_config , self . style , connection )"
"join statements into a string, separated by newlines, return it.",return '\n' . join ( statements )
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
from django.core.management.base import BaseCommand into default name space.,from django . core . management . base import BaseCommand
from django.core.management.sql import sql_flush into default name space.,from django . core . management . sql import sql_flush
from django.db import connections and DEFAULT_DB_ALIAS into default name space.,"from django . db import connections , DEFAULT_DB_ALIAS"
derive the class Command from the base class BaseCommand.,class Command ( BaseCommand ) :
"help is a string, containing ""Returns a list of the SQL statements required to return all tables in the database to the state they were in just after they were installed."".","help = ""Returns a list of the SQL statements required to return all tables in the database to the state they were in just after they were installed."""
output_transaction is boolean True.,output_transaction = True
define method add_arguments with self class instance and parser as the arguments.,"def add_arguments ( self , parser ) :"
call the parent class of Command class add_arguments method and parser as the arguments.,"super ( Command , self ) . add_arguments ( parser )"
"call the add_argument method on parser object, use string '--database', default set to DEFAULT_DB_ALIAS and help set to string,","parser . add_argument ( '--database' , default = DEFAULT_DB_ALIAS , help = 'Nominates a database to print the SQL for. Defaults to the ' '""default"" database.' )"
"'Nominates a database to print the SQL for. Defaults to the ""default"" database.' as the arguments. define the method handle with self class instance and dictionary options as the arguments.","def handle ( self , ** options ) :"
"call the sql_flush function with self.style, connections under the key with the value of options dictionary under the 'database' key,","return '\n' . join ( sql_flush ( self . style , connections [ options [ 'database' ] ] , only_django = True ) )"
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
from django.core.management.base import AppCommand into default name space.,from django . core . management . base import AppCommand
from django.core.management.sql import sql_indexes into default name space.,from django . core . management . sql import sql_indexes
from django.db import connections and DEFAULT_DB_ALIAS into default name space.,"from django . db import connections , DEFAULT_DB_ALIAS"
derive the class Command from the base class AppCommand.,class Command ( AppCommand ) :
"help is a string ""Prints the CREATE INDEX SQL statements for the given model module name(s)."".","help = ""Prints the CREATE INDEX SQL statements for the given model module name(s)."""
output_transaction is boolean True.,output_transaction = True
define the method add_arguments with self class instance and parser as the arguments.,"def add_arguments ( self , parser ) :"
call the add_arguments method with parser as argument form the base class of the class Command.,"super ( Command , self ) . add_arguments ( parser )"
"call parse.add_argument method, with string '--database', default set to DEFAULT_DB_ALIAS,","parser . add_argument ( '--database' , default = DEFAULT_DB_ALIAS , help = 'Nominates a database to print the SQL for. Defaults to the ' '""default"" database.' )"
"and help as a string 'Nominates a database to print the SQL for. Defaults to the ""default"" database.', as arguments. define the method handle_app_config with self class instance, app_config and dictionary options as arguments.","def handle_app_config ( self , app_config , ** options ) :"
"if app_config.models_module is None,",if app_config . models_module is None :
return nothing.,return
"get the value under the 'database' key of options dictionary, use it as a index to get connections list element, store it in connection.",connection = connections [ options [ 'database' ] ]
"call the function sql_indexes with app_config, self.style and connection as arguments, store the result in statements.","statements = sql_indexes ( app_config , self . style , connection )"
"join statements in a string separated by newline, return the result.",return '\n' . join ( statements )
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
from django.core.management.base import BaseCommand and CommandError into default name space.,"from django . core . management . base import BaseCommand , CommandError"
from django.db import connections and DEFAULT_DB_ALIAS into default name space.,"from django . db import connections , DEFAULT_DB_ALIAS"
from django.db.migrations.executor import MigrationExecutor into default name space.,from django . db . migrations . executor import MigrationExecutor
from django.db.migrations.loader import AmbiguityError into default name space.,from django . db . migrations . loader import AmbiguityError
derive class Command from the base class BaseCommand.,class Command ( BaseCommand ) :
"help is a string ""Prints the SQL statements for the named migration.""","help = ""Prints the SQL statements for the named migration."""
def method add_arguments with self class instance and parser as the arguments.,"def add_arguments ( self , parser ) :"
"call the add_argument method on the parser object, with string 'app_label', and help set to string 'App label of the application containing the migration.' as arguments.","parser . add_argument ( 'app_label' , help = 'App label of the application containing the migration.' )"
"call the add_argument method on the parser object, with string 'migration_name', and help set to string 'Migration name to print the SQL for.' as arguments.","parser . add_argument ( 'migration_name' , help = 'Migration name to print the SQL for.' )"
"call the add_argument method on the parser object, with string '--database', default set to DEFAULT_DB_ALIAS and help set to string 'Nominates a database to create SQL for. Defaults to the default"" database.' as arguments.","parser . add_argument ( '--database' , default = DEFAULT_DB_ALIAS , help = 'Nominates a database to create SQL for. Defaults to the ' '""default"" database.' )"
"call the add_argument method on the parser object with string '--backwards', asction set to 'store_true', dest set to 'backwards',","parser . add_argument ( '--backwards' , action = 'store_true' , dest = 'backwards' , default = False , help = 'Creates SQL to unapply the migration, rather than to apply it' )"
"default set to False and help set to string'Creates SQL to unapply the migration, rather than to apply it' as arguments. define the method handle with self class instance, list of arguments args and options dictionary as the arguments.","def handle ( self , * args , ** options ) :"
"get the value under the key 'database' of the options dictionary, use it as a index to get an element from connections, substitute it for connection.",connection = connections [ options [ 'database' ] ]
"call the MigrationExecutor with the connection as the argument, substitute it for executor.",executor = MigrationExecutor ( connection )
"get the values under the keys 'app_label' and 'migration_name' of the options dictionary, substitute the results for app_label and migration_name, respectively.","app_label , migration_name = options [ 'app_label' ] , options [ 'migration_name' ]"
"if app_label is not contained in executor.loader.migrated_apps,",if app_label not in executor . loader . migrated_apps :
"raise a exception of CommandError class, with string ""App '%s' does not have migrations"" with '%s' replaced with app_label as the argument.","raise CommandError ( ""App '%s' does not have migrations"" % app_label )"
"try,",try :
"call the executor.loader.get_migration_by_prefix with app_label and migration_name with arguments, substitute the result fr migration.","migration = executor . loader . get_migration_by_prefix ( app_label , migration_name )"
"if AmbiguityError exception is raised,",except AmbiguityError :
"raise a exception of ComandError class with string ""More than one migration matches '%s' in app '%s'. Please be more specific."",","raise CommandError ( ""More than one migration matches '%s' in app '%s'. Please be more specific."" % ( migration_name , app_label ) )"
"with all '%s' strings replaced with migration_name and app_label, respectively, as an argument. if KeyError exception is raised,",except KeyError :
"raise a exception of CommandError class, with string ""Cannot find a migration matching '%s' from app '%s'. Is it in INSTALLED_APPS?"",","raise CommandError ( ""Cannot find a migration matching '%s' from app '%s'. Is it in INSTALLED_APPS?"" % ( migration_name , app_label ) )"
"replace all the '%s' occurrences with migration_name and app_label, respectively. target is a list containing tuple with two elements app_label and migration.name.","targets = [ ( app_label , migration . name ) ]"
"get executor.loader.graph.nodes list item at the index of the first element of targets list, get the value under the 'backwards' key of options dictionary, put previous two elements is a tuple, tuple is contained in a plan list.","plan = [ ( executor . loader . graph . nodes [ targets [ 0 ] ] , options [ 'backwards' ] ) ]"
"call method executor.collect_sql with plan as the argument, substitute the result for sql_statements.",sql_statements = executor . collect_sql ( plan )
for every statements in sql_statements:,for statement in sql_statements :
call method self.stdout.write with statement as an argument.,self . stdout . write ( statement )
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
from django.core.management.base import AppCommand into default name space.,from django . core . management . base import AppCommand
from django.core.management.sql import check_for_migrations into default name space.,from django . core . management . sql import check_for_migrations
from django.db import connections and DEFAULT_DB_ALIAS into default name space.,"from django . db import connections , DEFAULT_DB_ALIAS"
derive the class Command from the AppCommand base class.,class Command ( AppCommand ) :
help is a string 'Prints the SQL statements for resetting sequences for the given app name(s).'.,help = 'Prints the SQL statements for resetting sequences for the given app name(s).'
output_transaction is boolean True.,output_transaction = True
"define the method add_arguments, with 2 arguments self and parser.","def add_arguments ( self , parser ) :"
"call the method add_arguments from the base class of the Command class, with an argument parser.","super ( Command , self ) . add_arguments ( parser )"
"call the method parser.add_argument with 3 arguments: string '--database', default set to DEFAULT_DB_ALIAS,","parser . add_argument ( '--database' , default = DEFAULT_DB_ALIAS , help = 'Nominates a database to print the SQL for. Defaults to the ' '""default"" database.' )"
"and help set to string 'Nominates a database to print the SQL for. Defaults to the ""default"" database.'. define the method handle_app_config with 3 arguments: self, app_config and unpacked dictionary options.","def handle_app_config ( self , app_config , ** options ) :"
"if app_config.models_module is None,",if app_config . models_module is None :
return nothing.,return
"get the value under the 'database' key of the options dictionary,",connection = connections [ options . get ( 'database' ) ]
"use the result as a key to get the value from the connections dictionary, substitute the result for connection. call the function check_for_migrations with 2 arguments: app_config and connection.","check_for_migrations ( app_config , connection )"
"call the method app_config.get_models with include_auto_created set to boolean True, substitute the result for models.",models = app_config . get_models ( include_auto_created = True )
"call the method connection.ops.sequence_reset_sql with 2 arguments self.style and models, substitute the result for statements.","statements = connection . ops . sequence_reset_sql ( self . style , models )"
"join statements into a string, separated by newline characters, return it.",return '\n' . join ( statements )
from django.core.management.base import BaseCommand and CommandError into default name space.,"from django . core . management . base import BaseCommand , CommandError"
from django.utils import six into default name space.,from django . utils import six
"from django.db import connections, DEFAULT_DB_ALIAS and migrations into default name space.","from django . db import connections , DEFAULT_DB_ALIAS , migrations"
from django.db.migrations.loader import AmbiguityError into default name space.,from django . db . migrations . loader import AmbiguityError
from django.db.migrations.executor import MigrationExecutor into default name space.,from django . db . migrations . executor import MigrationExecutor
from django.db.migrations.writer import MigrationWriter into default name space.,from django . db . migrations . writer import MigrationWriter
from django.db.migrations.optimizer import MigrationOptimizer into default name space.,from django . db . migrations . optimizer import MigrationOptimizer
derive the class Command from the BaseCommand class.,class Command ( BaseCommand ) :
"help is a string ""Squashes an existing set of migrations (from first until specified) into a single new one."".","help = ""Squashes an existing set of migrations (from first until specified) into a single new one."""
define the method add_arguments with 2 arguments self and parser.,"def add_arguments ( self , parser ) :"
"call the method parser.add_argument with 2 arguments: string 'app_label',","parser . add_argument ( 'app_label' , help = 'App label of the application to squash migrations for.' )"
"and help is a string 'App label of the application to squash migrations for.'. call the method parser.add_argument with 2 arguments: string 'migration_name',","parser . add_argument ( 'migration_name' , help = 'Migrations will be squashed until and including this migration.' )"
"and help is a string 'Migrations will be squashed until and including this migration.'. call the method parser.add_argument with 5 arguments: string '--no-optimize', action as a string 'store_true',","parser . add_argument ( '--no-optimize' , action = 'store_true' , dest = 'no_optimize' , default = False , help = 'Do not try to optimize the squashed operations.' )"
"dest as a string 'no_optimize', default set to boolean False and help as a string 'Do not try to optimize the squashed operations.'. call the method parser.add_argument with 5 arguments: string '--noinput', action set to string 'store_false',","parser . add_argument ( '--noinput' , action = 'store_false' , dest = 'interactive' , default = True , help = 'Tells Django to NOT prompt the user for input of any kind.' )"
"dest as a string 'interactive', default as boolean True help as a string 'Tells Django to NOT prompt the user for input of any kind.'. define the method handle with 3 arguments: self and unpacked dictionary options.","def handle ( self , ** options ) :"
"get the value under the 'verbosity' key of the options dictionary, substitute it for self.verbosity.",self . verbosity = options . get ( 'verbosity' )
"get the value under the 'interactive' key of the options dictionary, substitute it for self.interactive.",self . interactive = options . get ( 'interactive' )
"get the values under the 'app_label' and 'migration_name' keys of the options dictionary,","app_label , migration_name = options [ 'app_label' ] , options [ 'migration_name' ]"
"substitute them for app_label and migration_name, respectively. executor is an instance of MigrationExecutor, created with value under the DEFAULT_DB_ALIAS key of the connections dictionary.",executor = MigrationExecutor ( connections [ DEFAULT_DB_ALIAS ] )
"if app_label is not contained in executor.loader.migrated_apps,",if app_label not in executor . loader . migrated_apps :
"raise an CommandError with an argument string ""App '%s' does not have migrations (so squashmigrations on it makes no sense)"",","raise CommandError ( ""App '%s' does not have migrations (so squashmigrations on it makes no sense)"" % app_label )"
"where '%s' is replaced with app_label. try,",try :
"call the method executor.loader.get_migration_by_prefix with arguments app_label, migration_name, substitute the result for migration.","migration = executor . loader . get_migration_by_prefix ( app_label , migration_name )"
"if AmbiguityError exception is caught,",except AmbiguityError :
"raise an CommandError with an argument string ""More than one migration matches '%s' in app '%s'. Please be more specific."",","raise CommandError ( ""More than one migration matches '%s' in app '%s'. Please be more specific."" % ( migration_name , app_label ) )"
"where '%s' is replaced with migration_name and app_label. if KeyError exception is caught,",except KeyError :
"raise an CommandError with an argument string ""Cannot find a migration matching '%s' from app '%s'."",","raise CommandError ( ""Cannot find a migration matching '%s' from app '%s'."" % ( migration_name , app_label ) )"
"where '%s' is replaced with migration_name and app_label. migrations_to_squash is a list created dynamically with elements: return value of the method executor.loader.get_migration called,","migrations_to_squash = [ executor . loader . get_migration ( al , mn ) for al , mn in executor . loader . graph . forwards_plan ( ( migration . app_label , migration . name ) ) if al == migration . app_label ]"
"with arguments al and mn, for every al, mn in executor.loader.graph.forwards_plan method return value called with 2 arguments: migration.app_label, migration.name, only if al equals migration.app_label. if self.verbosity is greater than integer 0 or self.interactive is true,",if self . verbosity > 0 or self . interactive :
"call the method self.style.MIGRATE_HEADING with an argument string ""Will squash the following migrations:"",","self . stdout . write ( self . style . MIGRATE_HEADING ( ""Will squash the following migrations:"" ) )"
"write it to self.stdout. for every migration in migrations_to_squash,",for migration in migrations_to_squash :
"append migration.name to string ' - ', write it to self.stdout stream.","self . stdout . write ( "" - %s"" % migration . name )"
"if self.interactive is true,",if self . interactive :
answer is None.,answer = None
"while answer is false or answer is not contained in string ""yn"", perform the following,","while not answer or answer not in ""yn"" :"
"call the method six.moves.input with an argument string ""Do you wish to proceed? [yN] "", substitute the result for answer.","answer = six . moves . input ( ""Do you wish to proceed? [yN] "" )"
"if answer is false,",if not answer :
substitute 'n' for answer.,"answer = ""n"""
"break from the loop execution,",break
"if not,",else :
convert first element of answer to lowercase and substitute it for answer.,answer = answer [ 0 ] . lower ( )
"if answer equals a string 'y',","if answer != ""y"" :"
return nothing.,return
operations is an empty list.,operations = [ ]
"for every smigration in migrations_to_squash,",for smigration in migrations_to_squash :
call the method operations.extend with an argument smigration.operations.,operations . extend ( smigration . operations )
"if self.verbosity is greater than integer 0,",if self . verbosity > 0 :
"call the method self.style.MIGRATE_HEADING with an argument string ""Optimizing..."", write it to self.stdout.","self . stdout . write ( self . style . MIGRATE_HEADING ( ""Optimizing..."" ) )"
optimizer is an instance of MigrationOptimizer class.,optimizer = MigrationOptimizer ( )
"call the method optimizer.optimize with 2 arguments operations and migration.app_label, substitute the result for new_operations.","new_operations = optimizer . optimize ( operations , migration . app_label )"
"if self.verbosity is greater than integer 0,",if self . verbosity > 0 :
"if lengths of new_operations and operations are the same,",if len ( new_operations ) == len ( operations ) :
"write string "" No optimizations possible."" to self.stdout stream.","self . stdout . write ( "" No optimizations possible."" )"
"if not,",else :
"replace '%s' in string "" Optimized from %s operations to %s operations."" with lengths of operations and ew_operations, respectively,","self . stdout . write ( "" Optimized from %s operations to %s operations."" % ( len ( operations ) , len ( new_operations ) ) )"
write it to self.stdout stream. replaces is an empty list.,replaces = [ ]
"for every migration in migrations_to_squash,",for migration in migrations_to_squash :
"if migration.replaces is true,",if migration . replaces :
"extend replaces list with migration.replaces,",replaces . extend ( migration . replaces )
"if not,",else :
append tuple with 2 elements: migration.app_label and migration.name to replaces.,"replaces . append ( ( migration . app_label , migration . name ) )"
"subclass is a class named Migration, sub classed from migrations.Migration base class, with fields dependencies set to an empty list,","subclass = type ( ""Migration"" , ( migrations . Migration , ) , { ""dependencies"" : [ ] , ""operations"" : new_operations , ""replaces"" : replaces , } )"
"dependencies set to new_operations and replaces set to replaces. call the function subclass with 2 arguments string ""0001_squashed_%s"", where '%s' is replaced with migration.name and app_label,","new_migration = subclass ( ""0001_squashed_%s"" % migration . name , app_label )"
"substitute the result for new_migration. writer is an instance of a class MigrationWriter, created with an argument new_migration.",writer = MigrationWriter ( new_migration )
"open writer.path file in write mode, with file descriptor as fh, perform the following,","with open ( writer . path , ""wb"" ) as fh :"
"call the method writer.as_string, write the result to file fh.",fh . write ( writer . as_string ( ) )
"if self.verbosity is greater than integer 0,",if self . verbosity > 0 :
"replace '%s' in a string ""Created new squashed migration %s"" with writer.path, use it as an argument for the call to the method,","self . stdout . write ( self . style . MIGRATE_HEADING ( ""Created new squashed migration %s"" % writer . path ) )"
"self.style.MIGRATE_HEADING, write the result to self.stdout. write string "" You should commit this migration but leave the old ones in place;"" to self.stdout.","self . stdout . write ( "" You should commit this migration but leave the old ones in place;"" )"
"write string "" the new migration will be used for new installs. Once you are sure"" to self.stdout.","self . stdout . write ( "" the new migration will be used for new installs. Once you are sure"" )"
"write string "" all instances of the codebase have applied the migrations you squashed,"" to self.stdout.","self . stdout . write ( "" all instances of the codebase have applied the migrations you squashed,"" )"
"write string "" you can delete them."" to self.stdout.","self . stdout . write ( "" you can delete them."" )"
from importlib import import_module into default name space.,from importlib import import_module
from django.core.management.base import CommandError into default name space.,from django . core . management . base import CommandError
from django.core.management.templates import TemplateCommand into default name space.,from django . core . management . templates import TemplateCommand
derive the class Command from the TemplateCommand base class.,class Command ( TemplateCommand ) :
"help is a tuple containing a string ""Creates a Django app directory structure for the given app name in the current directory or optionally in the given directory."".","help = ( ""Creates a Django app directory structure for the given app "" ""name in the current directory or optionally in the given "" ""directory."" )"
"missing_args_message is a string ""You must provide an application name."".","missing_args_message = ""You must provide an application name."""
define the method handle with 2 arguments: self and unpacked dictionary options.,"def handle ( self , ** options ) :"
"remove values under the keys 'name' and 'directory' of the options dictionary and substitute it for app_name and target, respectively.","app_name , target = options . pop ( 'name' ) , options . pop ( 'directory' )"
call the method self.validate_name with 2 arguments: app_name and string 'app'.,"self . validate_name ( app_name , ""app"" )"
"try,",try :
call the function import_module with an argument app_name.,import_module ( app_name )
"if ImportError exception is caught,",except ImportError :
do nothing.,pass
"in not,",else :
"raise an CommandError exception with an argument string ""%r conflicts with the name of an existing Python module and cannot be used ""","raise CommandError ( ""%r conflicts with the name of an existing "" ""Python module and cannot be used as an app "" ""name. Please try another name."" % app_name )"
"""as an app name. Please try another name."", where '%r' is replaced with app_name. call the method handle from the base class of Command class, with 4 arguments: string 'app', app_name, target and unpacked dictionary options.","super ( Command , self ) . handle ( 'app' , app_name , target , ** options )"
from importlib import import_module into default name space.,from importlib import import_module
from django.core.management.base import CommandError into default name space.,from django . core . management . base import CommandError
from django.core.management.templates import TemplateCommand into default name space.,from django . core . management . templates import TemplateCommand
from django.utils.crypto import get_random_string into default name space.,from django . utils . crypto import get_random_string
derive class Command from the TemplateCommand base class.,class Command ( TemplateCommand ) :
"help is a tuple containing string ""Creates a Django project directory structure for the given ""","help = ( ""Creates a Django project directory structure for the given "" ""project name in the current directory or optionally in the "" ""given directory."" )"
"""project name in the current directory or optionally in the given directory."". missing_args_message is a string ""You must provide a project name."".","missing_args_message = ""You must provide a project name."""
define the method handle with arguments self and unpacked dictionary options.,"def handle ( self , ** options ) :"
"remove the elements from the 'name' and 'dictionary' keys of the options dictionary, substitute them for project_name and target, respectively.","project_name , target = options . pop ( 'name' ) , options . pop ( 'directory' )"
"call the method self.validate_name with arguments project_name and string ""project"".","self . validate_name ( project_name , ""project"" )"
"try,",try :
call the function import_module with an argument project_name.,import_module ( project_name )
"if ImportError exception is caught,",except ImportError :
do nothing.,pass
"if not,",else :
"raise an exception CommandError, with argument string ""%r conflicts with the name of an existing Python module and cannot be used as a project name. Please try another name."", where '%r' is replaced with project_name.","raise CommandError ( ""%r conflicts with the name of an existing "" ""Python module and cannot be used as a "" ""project name. Please try another name."" % project_name )"
chars is a string 'abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(-_=+)'.,chars = 'abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(-_=+)'
"call the function get_random_string with 2 arguments: integer 50 and chars, substitute it for value under the 'secret_key' of the options dictionary.","options [ 'secret_key' ] = get_random_string ( 50 , chars )"
"call the handle method of the base class of the Command class, with 4 arguments: string 'project', project_name, target,","super ( Command , self ) . handle ( 'project' , project_name , target , ** options )"
import module warnings.,import warnings
from django.apps import apps into default name space.,from django . apps import apps
from django.contrib.auth import get_user_model into default name space.,from django . contrib . auth import get_user_model
from django.db import DEFAULT_DB_ALIAS into default name space.,from django . db import DEFAULT_DB_ALIAS
from django.core.management import call_command into default name space.,from django . core . management import call_command
from django.core.management.base import BaseCommand into default name space.,from django . core . management . base import BaseCommand
from django.utils.deprecation import RemovedInDjango19Warning into default name space.,from django . utils . deprecation import RemovedInDjango19Warning
from django.utils.six.moves import input into default name space.,from django . utils . six . moves import input
derive class Command from the BaseCommand base class.,class Command ( BaseCommand ) :
"help is a string ""Deprecated - use 'migrate' instead."".","help = ""Deprecated - use 'migrate' instead."""
define the method add_arguments with self and parser as arguments.,"def add_arguments ( self , parser ) :"
"call the method parser.add_argument with 5 arguments: string '--noinput', action set to string 'store_false',","parser . add_argument ( '--noinput' , action = 'store_false' , dest = 'interactive' , default = True , help = 'Tells Django to NOT prompt the user for input of any kind.' )"
"dest set to string 'interactive', default set to boolean True and help as 'Tells Django to NOT prompt the user for input of any kind.' call the method parser.add_argument with 5 arguments: string '--no-initial-data', action set to string 'store_false',","parser . add_argument ( '--no-initial-data' , action = 'store_false' , dest = 'load_initial_data' , default = True , help = 'Tells Django not to load any initial data after database synchronization.' )"
"dest set to string 'load_initial_data', default set to boolean True, and help as a string 'Tells Django not to load any initial data after database synchronization.' call the method parser.add_argument with 3 arguments: string '--database', default set to DEFAULT_DB_ALIAS,","parser . add_argument ( '--database' , default = DEFAULT_DB_ALIAS , help = 'Nominates a database to synchronize. Defaults to the ""default"" database.' )"
"and help set to string 'Nominates a database to synchronize. Defaults to the ""default"" database.'. define the method handle with 2 arguments: self and unpacked dictionary options.","def handle ( self , ** options ) :"
"call the method warnings.warn with 2 arguments: string ""The syncdb command will be removed in Django 1.9"" and RemovedInDjango19Warning.","warnings . warn ( ""The syncdb command will be removed in Django 1.9"" , RemovedInDjango19Warning )"
call the function call_command with 2 arguments: string migrate and unpacked dictionary options.,"call_command ( ""migrate"" , ** options )"
"try,",try :
call the method apps.get_model with 2 arguments: string 'auth' and string 'Permission'.,"apps . get_model ( 'auth' , 'Permission' )"
if LookupError exception is caught.,except LookupError :
return nothing.,return
"call the function get_user_model, substitute the result for UserModel.",UserModel = get_user_model ( )
"if return value of the method UserModel._default_manager.exists is false and value under the 'interactive' key of the options dictionary is true,",if not UserModel . _default_manager . exists ( ) and options . get ( 'interactive' ) :
"msg is a tuple containing string ""\nYou have installed Django's auth system, and don't have any superusers defined.\nWould you like to create one now? (yes/no): "".","msg = ( ""\nYou have installed Django's auth system, and "" ""don't have any superusers defined.\nWould you like to create one "" ""now? (yes/no): "" )"
call the method input with an argument msg and store the result in confirm.,confirm = input ( msg )
"endless loop,",while 1 :
"if confirm is not equal to string 'yes' or string 'no',","if confirm not in ( 'yes' , 'no' ) :"
"query a string 'Please enter either ""yes"" or ""no"": ' and store the result in confirm.","confirm = input ( 'Please enter either ""yes"" or ""no"": ' )"
skip this loop iteration.,continue
"if confirm equals string 'yes',",if confirm == 'yes' :
"call the function call_command with 3 arguments: string ""createsuperuser"", interactive is boolean True,","call_command ( ""createsuperuser"" , interactive = True , database = options [ 'database' ] )"
and database set to value under the 'database' key of the options dictionary. break the loop execution.,break
import module logging.,import logging
import module sys.,import sys
import module os.,import os
from django.conf import settings into default name space.,from django . conf import settings
from django.core.management.base import BaseCommand into default name space.,from django . core . management . base import BaseCommand
from django.test.utils import get_runner into default name space.,from django . test . utils import get_runner
derive class Command from the BaseCommand base class.,class Command ( BaseCommand ) :
help is a string 'Discover and run tests in the specified modules or the current directory.'.,help = 'Discover and run tests in the specified modules or the current directory.'
requires_system_checks is boolean False.,requires_system_checks = False
define the method __init__ with an argument self.,def __init__ ( self ) :
self.test_runner is None.,self . test_runner = None
call the method __init__ form the base class of the Command class.,"super ( Command , self ) . __init__ ( )"
define the method run_from_argv with arguments self and argv.,"def run_from_argv ( self , argv ) :"
option is a string '--testrunner='.,option = '--testrunner='
"for arg in argv list without the first two elements,",for arg in argv [ 2 : ] :
"if arg starts with options,",if arg . startswith ( option ) :
"get the length of the options, use it as a starting index for the slicing arg list, substitute it for self.test_runner.",self . test_runner = arg [ len ( option ) : ]
break the loop execution.,break
"call the run_from_argv function from the base class of the Command class with argv as a argument,.","super ( Command , self ) . run_from_argv ( argv )"
define the method add_arguments with arguments self and parser.,"def add_arguments ( self , parser ) :"
"call the method parser.add_argument with 4 arguments: string 'args', metavar set to string 'test_label', nargs set to string '*',","parser . add_argument ( 'args' , metavar = 'test_label' , nargs = '*' , help = 'Module paths to test; can be modulename, modulename.TestCase or modulename.TestCase.test_method' )"
"and help is a string 'Module paths to test; can be modulename, modulename.TestCase or modulename.TestCase.test_method'. call the method parser.add_argument with 5 arguments: string '--noinput', action set to 'store_false', dest set to 'interactive',","parser . add_argument ( '--noinput' , action = 'store_false' , dest = 'interactive' , default = True , help = 'Tells Django to NOT prompt the user for input of any kind.' ) ,"
"default set to boolean True, help set to string 'Tells Django to NOT prompt the user for input of any kind.'. call the method parser.add_argument with 5 arguments: string '--failfast', action set to string 'store_true', dest set to 'failfast',","parser . add_argument ( '--failfast' , action = 'store_true' , dest = 'failfast' , default = False , help = 'Tells Django to stop running the test suite after first ' 'failed test.' ) ,"
"default set to boolean False and help set to string 'Tells Django to stop running the test suite after first failed test.'. call the method parser.add_argument with 4 arguments: string '--testrunner', action set to string 'store', dest set to 'testrunner',","parser . add_argument ( '--testrunner' , action = 'store' , dest = 'testrunner' , help = 'Tells Django to use specified test runner class instead of ' 'the one specified by the TEST_RUNNER setting.' ) ,"
"and help set to a string 'Tells Django to use specified test runner class instead of the one specified by the TEST_RUNNER setting.'. call the method parser.add_argument with 5 arguments: string '--liveserver', action set to string 'store', dest set to 'liveserver',","parser . add_argument ( '--liveserver' , action = 'store' , dest = 'liveserver' , default = None , help = 'Overrides the default address where the live server (used ' 'with LiveServerTestCase) is expected to run from. The ' 'default value is localhost:8081.' ) ,"
"default set to None and help set to string 'Overrides the default address where the live server (used ' 'with LiveServerTestCase) is expected to run from. The default value is localhost:8081.' call the function get_runner with arguments settings and self.test_runner, substitute the result for test_runner_class.","test_runner_class = get_runner ( settings , self . test_runner )"
"if test_runner_class has an 'option_list' attribute,","if hasattr ( test_runner_class , 'option_list' ) :"
"raise an RuntimeError exception with an argument string ""The method to extend accepted command-line arguments by the ""","raise RuntimeError ( ""The method to extend accepted command-line arguments by the "" ""test management command has changed in Django 1.8. Please "" ""create an add_arguments class method to achieve this."" )"
"""test management command has changed in Django 1.8. Please create an add_arguments class method to achieve this."" if test_runner_class has an attribute 'add_arguments',","if hasattr ( test_runner_class , 'add_arguments' ) :"
call the method test_runner_class.add_arguments with an argument parser.,test_runner_class . add_arguments ( parser )
"define the method execute with 3 arguments self, unpacked list args and unpacked dictionary options.","def execute ( self , * args , ** options ) :"
"if value under the 'verbosity' key of the options dictionary is greater than zero,",if options [ 'verbosity' ] > 0 :
"call the method logging.getLogger with an argument string 'py.warnings', substitute the result for logger.",logger = logging . getLogger ( 'py.warnings' )
"call the method logging.StreamHandler, substitute the result for handler.",handler = logging . StreamHandler ( )
call the method logger.addHandler with an argument handler.,logger . addHandler ( handler )
"call the method execute form the base class of the class Command, with 2 arguments: unpacked list args and unpacked dictionary options.","super ( Command , self ) . execute ( * args , ** options )"
"if value under the 'verbosity' key of the options dictionary is greater than zero,",if options [ 'verbosity' ] > 0 :
call the method logger.removeHandler with an argument handler.,logger . removeHandler ( handler )
"define the method handle with 3 arguments: self, unpacked list test_labels and unpacked dictionary options.","def handle ( self , * test_labels , ** options ) :"
from django.conf import settings into default namespace.,from django . conf import settings
from django.test.utils import get_runner into default namespace.,from django . test . utils import get_runner
"call the method get_runner with 2 arguments: settings and value under the 'testrunner' key of the options dictionary, substitute it for the TestRunner.","TestRunner = get_runner ( settings , options . get ( 'testrunner' ) )"
"if value under the 'liveserver' key of the options dictionary is not None,",if options . get ( 'liveserver' ) is not None :
substitute value under the 'liveserver' key of the options dictionary for value under the 'DJANGO_LIVE_TEST_SERVER_ADDRESS' key of the os.environ dictionary.,os . environ [ 'DJANGO_LIVE_TEST_SERVER_ADDRESS' ] = options [ 'liveserver' ]
delete the value under the 'liveserver' key of the options dictionary.,del options [ 'liveserver' ]
"test_runner is an instance of TestRunner class, called with an argument unpacked dictionary options.",test_runner = TestRunner ( ** options )
"call the method test_runner.run_tests with an argument test_labels, substitute it for failures.",failures = test_runner . run_tests ( test_labels )
"if failures is true,",if failures :
exit the program with failures converted to boolean as a message.,sys . exit ( bool ( failures ) )
from django.core.management import call_command into default name space.,from django . core . management import call_command
from django.core.management.base import BaseCommand into default name space.,from django . core . management . base import BaseCommand
from django.db import connection into default name space.,from django . db import connection
derive class Command from the BaseCommand base class.,class Command ( BaseCommand ) :
help is a string 'Runs a development server with data from the given fixture(s).'.,help = 'Runs a development server with data from the given fixture(s).'
args is a string '[fixture ...]'.,args = '[fixture ...]'
requires_system_checks is boolean False.,requires_system_checks = False
define the method with self class instance and parser as arguments.,"def add_arguments ( self , parser ) :"
"call parser.add_argument method with 'args', metavar set to string 'fixture', nargs set to string '*' and help set to string 'Path(s) to fixtures to load before running the server.'.","parser . add_argument ( 'args' , metavar = 'fixture' , nargs = '*' , help = 'Path(s) to fixtures to load before running the server.' )"
"call parser.add_argument method with '--noinput', action set to string 'store_false', dest set to string 'interactive',","parser . add_argument ( '--noinput' , action = 'store_false' , dest = 'interactive' , default = True , help = 'Tells Django to NOT prompt the user for input of any kind.' )"
"default set to boolean True and help set to string 'Tells Django to NOT prompt the user for input of any kind.'. call the parser.add_argument with string '--addrport', default set to an empty string and help as string 'Port number or ipaddr:port to run the server on.'.","parser . add_argument ( '--addrport' , default = '' , help = 'Port number or ipaddr:port to run the server on.' )"
"call parser.add_argument method with '--ipv6', string '-6', action set to string 'store_true', dest set to string 'use_ipv6',","parser . add_argument ( '--ipv6' , '-6' , action = 'store_true' , dest = 'use_ipv6' , default = False , help = 'Tells Django to use an IPv6 address.' )"
"default set to boolean False and help set to string 'Tells Django to use an IPv6 address.'. define the method handle with self class instance, list of arguments fixture_labels and dictionary options as arguments.","def handle ( self , * fixture_labels , ** options ) :"
"get the value under the key 'verbosity' of options dictionary, substitute it for verbosity.",verbosity = options . get ( 'verbosity' )
"get the value under the key 'interactive' of options dictionary, substitute it for interactive.",interactive = options . get ( 'interactive' )
"call the method connection.creation.create_test_db with verbosity set to verbosity, autoclobber set to inverse value of interactive,","db_name = connection . creation . create_test_db ( verbosity = verbosity , autoclobber = not interactive , serialize = False )"
"serialize set to boolean False, substitute the return value for db_name. call the method call_command with 3 arguments, string 'loaddata', unpacked list fixture_labels and unpacked dictionary containing 1 element: verbosity for 'verbosity'.","call_command ( 'loaddata' , * fixture_labels , ** { 'verbosity' : verbosity } )"
"replace '%r' from string '\nServer stopped.\nNote that the test database, %r, has not been deleted. You can explore it on your own.', with db_name, substitute it for shutdown_message.","shutdown_message = '\nServer stopped.\nNote that the test database, %r, has not been deleted. You can explore it on your own.' % db_name"
substitute connection.features.test_db_allows_multiple_connections for use_threading.,use_threading = connection . features . test_db_allows_multiple_connections
"call the function call_command with 6 arguments, string 'runserver', addrport as the value under the 'addrport' key of options dictionary,","call_command ( 'runserver' , addrport = options [ 'addrport' ] , shutdown_message = shutdown_message , use_reloader = False , use_ipv6 = options [ 'use_ipv6' ] , use_threading = use_threading )"
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
import module warnings.,import warnings
from django.core.management.commands.check import Command as CheckCommand into default name space.,from django . core . management . commands . check import Command as CheckCommand
from django.utils.deprecation import RemovedInDjango19Warning into default name space.,from django . utils . deprecation import RemovedInDjango19Warning
derive class Command from CheckCommand base class.,class Command ( CheckCommand ) :
"concatenate CheckCommand.help to string 'Deprecated. Use ""check"" command instead. ', substitute it for help.","help = 'Deprecated. Use ""check"" command instead. ' + CheckCommand . help"
define the method handle with self class instance and dictionary pair of elements options as arguments.,"def handle ( self , ** options ) :"
"call the method warnings.warn with string '""validate"" has been deprecated in favor of ""check"".' and RemovedInDjango19Warning as arguments.","warnings . warn ( '""validate"" has been deprecated in favor of ""check"".' , RemovedInDjango19Warning )"
call the handle function with dictionary pair of elements options from the base class of the class Command.,"super ( Command , self ) . handle ( ** options )"
from __future__ import unicode_literals into default name space.,from __future__ import unicode_literals
import module codecs.,import codecs
import module os.,import os
import module re.,import re
import module warnings.,import warnings
from django.apps import apps into default name space.,from django . apps import apps
from django.conf import settings into default name space.,from django . conf import settings
from django.core.management.base import CommandError into default name space.,from django . core . management . base import CommandError
from django.db import models and router into default name space.,"from django . db import models , router"
from django.utils.deprecation import RemovedInDjango19Warning into default name space.,from django . utils . deprecation import RemovedInDjango19Warning
define the function check_for_migrations with 2 arguments: app_config and connection.,"def check_for_migrations ( app_config , connection ) :"
from django.db.migrations.loader import MigrationLoader into default name space.,from django . db . migrations . loader import MigrationLoader
"loader is an instance of MigrationLoader class, created with an argument connection.",loader = MigrationLoader ( connection )
"if app_config.label is contained in loader.migrated_apps,",if app_config . label in loader . migrated_apps :
"raise an CommandError exception, with an arguent: string ""App '%s' has migrations. Only the sqlmigrate and sqlflush commands can be used when an app has migrations."", where '%s' is replaced for app_config.label.","raise CommandError ( ""App '%s' has migrations. Only the sqlmigrate and sqlflush commands can be used when an app has migrations."" % app_config . label )"
"define the function sql_create with 3 arguments: app_config, style and connection.","def sql_create ( app_config , style , connection ) :"
"call the function check_for_migrations with an arguments app_config, connection.","check_for_migrations ( app_config , connection )"
"if value under the 'ENGINE' key of the connection.settings_dict dictionary equals a string 'django.db.backends.dummy',",if connection . settings_dict [ 'ENGINE' ] == 'django.db.backends.dummy' :
"raise an CommandError exception with an argument string ""Django doesn't know which syntax to use for your SQL statements,\n""","raise CommandError ( ""Django doesn't know which syntax to use for your SQL statements,\n"" + ""because you haven't properly specified the ENGINE setting for the database.\n"" + ""see: https://docs.djangoproject.com/en/dev/ref/settings/#databases"" )"
"""because you haven't properly specified the ENGINE setting for the database.\n see: https://docs.djangoproject.com/en/dev/ref/settings/#databases"". call the method app_config.get_models with an argument include_auto_created set to boolean True, substitute it for app_models.",app_models = app_config . get_models ( include_auto_created = True )
final_output is an empty list.,final_output = [ ]
"call the method connection.introspection.table_names, substitute the result for tables.",tables = connection . introspection . table_names ( )
"if model is not contained in app_models for every model in return value of the connection.introspection.installed_models function return value,",known_models = set ( model for model in connection . introspection . installed_models ( tables ) if model not in app_models )
"add model to a set, substitute the result for known_models. pending_references is an empty dictionary.",pending_references = { }
"for every model in return value of the function router.get_migratable_models, called with arguments:","for model in router . get_migratable_models ( app_config , connection . alias , include_auto_created = True ) :"
"app_config, connection.alias and include_auto_created set to boolean True. call the method connection.creation.sql_create_model with arguments model, style and known_models, substitute the result for output and references.","output , references = connection . creation . sql_create_model ( model , style , known_models )"
call the method final_output.extend with an argument output.,final_output . extend ( output )
"for every refto and refs in return value of the method references.items,","for refto , refs in references . items ( ) :"
"call the method pending_references.setdefault with 2 arguments: refto and an empty list, extend the result with refs.","pending_references . setdefault ( refto , [ ] ) . extend ( refs )"
"if refto is contained in known_models,",if refto in known_models :
"call the method connection.creation.sql_for_pending_references with 3 arguments: refo, style and pending_references,","final_output . extend ( connection . creation . sql_for_pending_references ( refto , style , pending_references ) )"
"use the result as an argument for the call to the method final_output.extend. call the method connection.creation.sql_for_pending_references with 3 arguments: refo, style and pending_references,","final_output . extend ( connection . creation . sql_for_pending_references ( model , style , pending_references ) )"
use the result as an argument for the call to the method final_output.extend. add model to known_models set.,known_models . add ( model )
"call the method pending_references.keys, put the result into a set and substitute it for not_installed_models.",not_installed_models = set ( pending_references . keys ( ) )
"if not_installed_models is true,",if not_installed_models :
alter_sql is an empty list.,alter_sql = [ ]
"for every model in not_installed_models,",for model in not_installed_models :
"for every sql in return value of the function connection.creation.sql_for_pending_references called with arguments: model, style,","alter_sql . extend ( [ '-- ' + sql for sql in connection . creation . sql_for_pending_references ( model , style , pending_references ) ] )"
"and pending_references append sql to the string '-- ', put the results in a list, extend alter_sql with the result. if alter_sql,",if alter_sql :
append string '-- The following references should be added but depend on non-existent tables:' to the final_output.,final_output . append ( '-- The following references should be added but depend on non-existent tables:' )
extend final_output with alter_sql.,final_output . extend ( alter_sql )
return final_output.,return final_output
"define the function sql_delete with 4 arguments: app_config, style, connection and close_connection set to boolean True.","def sql_delete ( app_config , style , connection , close_connection = True ) :"
call the function check_for_migrations with arguments app_config and connection.,"check_for_migrations ( app_config , connection )"
"try,",try :
"call the method connection.cursor, substitute the result for cursor.",cursor = connection . cursor ( )
"if Exception exception is caught,",except Exception :
cursor is None.,cursor = None
"try,",try :
"if cursor is true,",if cursor :
"call the method connection.introspection.table_names with an argument cursor, substitute the result for table_names.",table_names = connection . introspection . table_names ( cursor )
"if not,",else :
table_names is an empty list.,table_names = [ ]
output is an empty list.,output = [ ]
to_delete is an empty set.,to_delete = set ( )
references_to_delete is an empty dictionary.,references_to_delete = { }
"call the method router.get_migratable_models with argument: app_config, connection.alias and include_auto_created set to True, substitute the result for app_models.","app_models = router . get_migratable_models ( app_config , connection . alias , include_auto_created = True )"
"for every model in app_models,",for model in app_models :
"if cursor is true and return value of the function connection.introspection.table_name_converter called with an arugment: model._meta.db_table is contained in table_names,",if cursor and connection . introspection . table_name_converter ( model . _meta . db_table ) in table_names :
substitute model._meta for opts.,opts = model . _meta
"for every f in opts.local_fields,",for f in opts . local_fields :
"if f.rel and f.rel.to are not contained in to_delete,",if f . rel and f . rel . to not in to_delete :
"call the method references_to_delete.setdefault with arguments: r.rel.to and an empty list, append to the result tuple with 2 entries: model and f.","references_to_delete . setdefault ( f . rel . to , [ ] ) . append ( ( model , f ) )"
call the method to_delete.add with an argument model.,to_delete . add ( model )
"for every model in app_models,",for model in app_models :
if return value of the function connection.introspection.table_name_converter called with an arugment: model._meta.db_table is contained in table_names,if connection . introspection . table_name_converter ( model . _meta . db_table ) in table_names :
"call the method connection.creation.sql_destroy_model with arguments: model, references_to_delete and style, extend with the result the list output.","output . extend ( connection . creation . sql_destroy_model ( model , references_to_delete , style ) )"
"finally perform,",finally :
"if both cursor and close_connection are true,",if cursor and close_connection :
"call the method cursor.close,",cursor . close ( )
"call the method connection.close,",connection . close ( )
return reversed list output.,return output [ : : - 1 ]
"define the function sql_flush with 4 arguments: style, connection, only_django set to boolean False,","def sql_flush ( style , connection , only_django = False , reset_sequences = True , allow_cascade = False ) :"
"if only_django,",if only_django :
"call the method connection.introspection.django_table_names with an argument boolean true, substitute the result for tables.",tables = connection . introspection . django_table_names ( only_existing = True )
"if not,",else :
"call the method connection.introspection.table_names, substitute the result for tables.",tables = connection . introspection . table_names ( )
"call the method connection.introspection.sequence_list if reset_sequences is true, substitute the result for seqs, if not, seqs is an empty tuple.",seqs = connection . introspection . sequence_list ( ) if reset_sequences else ( )
"call the method connection.ops.sql_flush with arguments: style, tables, seqs and allow_cascade, substitute the result for statements.","statements = connection . ops . sql_flush ( style , tables , seqs , allow_cascade )"
return statements.,return statements
"define the function sql_custom with 3 arguments: app_config, style and connection.","def sql_custom ( app_config , style , connection ) :"
call the method check_for_migrations with arguments: app_config and connection.,"check_for_migrations ( app_config , connection )"
output is an empty list.,output = [ ]
call the method router.get_migratable_models with arguments app_config and connection.alias.,"app_models = router . get_migratable_models ( app_config , connection . alias )"
"for every model in app_models,",for model in app_models :
"call the function custom_sql_for_model with 3 arguments: model, style and connection, extend the output with the result.","output . extend ( custom_sql_for_model ( model , style , connection ) )"
return output.,return output
"define the function sql_indexes with 3 arguments: app_config, style and connection.","def sql_indexes ( app_config , style , connection ) :"
call the function check_for_migrations with an arguments app_config and connection.,"check_for_migrations ( app_config , connection )"
outut is an empty list.,output = [ ]
"for model in router.get_migratable_models method return value, called with 3 arguments: app_config, connection.alias,","for model in router . get_migratable_models ( app_config , connection . alias , include_auto_created = True ) :"
"and include_auto_created set to boolean True, call the method connection.creation.sql_indexes_for_model with arguments model and style, extend output with the result.","output . extend ( connection . creation . sql_indexes_for_model ( model , style ) )"
return output.,return output
"define the function sql_destroy_indexes with 3 arguments: app_config, style and connection.","def sql_destroy_indexes ( app_config , style , connection ) :"
call the function check_for_migrations with arguments app_config and connection.,"check_for_migrations ( app_config , connection )"
output is an empty list.,output = [ ]
"for model in return value of the method router.get_migratable_models with arguments app_config, connection.alias,","for model in router . get_migratable_models ( app_config , connection . alias , include_auto_created = True ) :"
"and include_auto_created set to boolean True, call the method connection.creation.sql_destroy_indexes_for_model with arguments model and style, extend the output with the result.","output . extend ( connection . creation . sql_destroy_indexes_for_model ( model , style ) )"
return output.,return output
"define the function sql_all with 3 arguments: app_config, style and connection.","def sql_all ( app_config , style , connection ) :"
call the function check_for_migrations with arguments app_config and connection.,"check_for_migrations ( app_config , connection )"
"use the app_config, style and connection as arguments for the call to the sql_create, sql_custom and sql_indexes functions, append the results respectively, return the result.","return sql_create ( app_config , style , connection ) + sql_custom ( app_config , style , connection ) + sql_indexes ( app_config , style , connection )"
